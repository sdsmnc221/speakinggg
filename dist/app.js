/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/acorn/dist/acorn.mjs":
/*!*******************************************!*\
  !*** ./node_modules/acorn/dist/acorn.mjs ***!
  \*******************************************/
/*! exports provided: Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, tokContexts, tokTypes, tokenizer, version */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Node", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Position", function() { return Position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SourceLocation", function() { return SourceLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokContext", function() { return TokContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultOptions", function() { return defaultOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineInfo", function() { return getLineInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierChar", function() { return isIdentifierChar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIdentifierStart", function() { return isIdentifierStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNewLine", function() { return isNewLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keywordTypes", function() { return keywords$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreak", function() { return lineBreak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineBreakG", function() { return lineBreakG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nonASCIIwhitespace", function() { return nonASCIIwhitespace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseExpressionAt", function() { return parseExpressionAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokContexts", function() { return types$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokTypes", function() { return types; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tokenizer", function() { return tokenizer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code, ecma2019String) {
  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = {};

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

// Switch to a getter for 7.0.0.
Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

Parser.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser.prototype, prototypeAccessors );

var pp = Parser.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
pp.strictDirective = function(start) {
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") { return true }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$1.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91) { return true } // '['
  if (context) { return false }

  if (nextCh === 123) { return true } // '{'
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock(true, node)
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (this.options.ecmaVersion > 10 && starttype === types._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40) // '('
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types.parenL);
  if (this.type === types.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLVal(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types.braceR;) {
    if (this.type === types._case || this.type === types._default) {
      var isCase = this.type === types._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types.parenR);
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope, node) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (!this.eat(types.braceR)) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var isForIn = this.type === types._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  } else if (init.type === "AssignmentPattern") {
    this.raise(init.start, "Invalid left-hand side in for-loop");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  this.strict = oldStrict;
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassElement = function(constructorAllowsSuper) {
  var this$1 = this;

  if (this.eat(types.semi)) { return null }

  var method = this.startNode();
  var tryContextual = function (k, noLineBreak) {
    if ( noLineBreak === void 0 ) noLineBreak = false;

    var start = this$1.start, startLoc = this$1.startLoc;
    if (!this$1.eatContextual(k)) { return false }
    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
    if (method.key) { this$1.unexpected(); }
    method.computed = false;
    method.key = this$1.startNodeAt(start, startLoc);
    method.key.name = k;
    this$1.finishNode(method.key, "Identifier");
    return false
  };

  method.kind = "method";
  method.static = tryContextual("static");
  var isGenerator = this.eat(types.star);
  var isAsync = false;
  if (!isGenerator) {
    if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    } else if (tryContextual("get")) {
      method.kind = "get";
    } else if (tryContextual("set")) {
      method.kind = "set";
    }
  }
  if (!method.key) { this.parsePropertyName(method); }
  var key = method.key;
  var allowsDirectSuper = false;
  if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
      key.type === "Literal" && key.value === "constructor")) {
    if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
    method.kind = "constructor";
    allowsDirectSuper = constructorAllowsSuper;
  } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && method.value.params.length !== 0)
    { this.raiseRecoverable(method.value.start, "getter should have no params"); }
  if (method.kind === "set" && method.value.params.length !== 1)
    { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && method.value.params[0].type === "RestElement")
    { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
  return method
};

pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  return this.finishNode(method, "MethodDefinition")
};

pp$1.parseClassId = function(node, isStatement) {
  if (this.type === types.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLVal(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    if (this.type !== types.string) { this.unexpected(); }
    node.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(null);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this.startNode();
    node.local = this.parseIdent(true);
    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
    this.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this.startNode();
    node$2.imported = this.parseIdent(true);
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLVal(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      // falls through to AssignmentPattern

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types.comma); }
    if (allowEmpty && this.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (bindingType === BIND_LEXICAL && expr.name === "let")
      { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this.checkLVal(prop, bindingType, checkClashes);
  }
    break

  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLVal(expr.value, bindingType, checkClashes);
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }
        // Backwards-compat kludge. Can be removed in version 6.0
        else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(noIn) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldShorthandAssign = refDestructuringErrors.shorthandAssign;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types.parenL || this.type === types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLVal(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
    if (element === base || element.type === "ArrowFunctionExpression") { return element }
    base = element;
  }
};

pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
  var computed = this.eat(types.bracketL);
  if (computed || this.eat(types.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
    node.computed = !!computed;
    if (computed) { this.expect(types.bracketR); }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && base.type !== "Import", false, refDestructuringErrors);
    if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (node$1.callee.type === "Import") {
      if (node$1.arguments.length !== 1) {
        this.raise(node$1.start, "import() requires exactly one argument");
      }

      var importArg = node$1.arguments[0];
      if (importArg && importArg.type === "SpreadElement") {
        this.raise(importArg.start, "... is not allowed in import()");
      }
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types.backQuote) {
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  case types._import:
    if (this.options.ecmaVersion > 10) {
      return this.parseDynamicImport()
    } else {
      return this.unexpected()
    }

  default:
    this.unexpected();
  }
};

pp$3.parseDynamicImport = function() {
  var node = this.startNode();
  this.next();
  if (this.type !== types.parenL) {
    this.unexpected();
  }
  return this.finishNode(node, "Import")
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types.parenR) {
      first ? first = false : this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target" || containsEsc)
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inNonArrowFunction())
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.options.ecmaVersion > 10 && node.callee.type === "Import") {
    this.raise(node.callee.start, "Cannot use new with import(...)");
  }
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8 && node.callee.type !== "Import", false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this.expect(types.comma);
      if (this.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // To disallow parenthesized identifier via `this.toAssignable()`.
    if (this.type === types.parenL && refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0) {
        refDestructuringErrors.parenthesizedAssign = this.start;
      }
      if (refDestructuringErrors.parenthesizedBind < 0) {
        refDestructuringErrors.parenthesizedBind = this.start;
      }
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types.comma && this.type !== types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();

  // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
  if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types.comma)
      { elt = null; }
    else if (this.type === types.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function(noIn) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign(noIn);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$5.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$5.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$5.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$5.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$5.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$5.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$5.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType === types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
    { return true }
  if (prevType === types.braceL)
    { return parent === types$1.b_stat }
  if (prevType === types._var || prevType === types._const || prevType === types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// This file contains Unicode properties extracted from the ECMAScript
// specification. The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues
};

var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
buildUnicodeData(9);
buildUnicodeData(10);
buildUnicodeData(11);

var pp$8 = Parser.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i);
  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current () {
  return this.at(this.pos)
};

RegExpValidationState.prototype.lookahead = function lookahead () {
  return this.at(this.nextIndex(this.pos))
};

RegExpValidationState.prototype.advance = function advance () {
  this.pos = this.nextIndex(this.pos);
};

RegExpValidationState.prototype.eat = function eat (ch) {
  if (this.current() === ch) {
    this.advance();
    return true
  }
  return false
};

function codePointToString(ch) {
  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
  ch -= 0x10000;
  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
}

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$8.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$8.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$8.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$8.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$8.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$8.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$8.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$8.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$8.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$8.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$8.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$8.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$8.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier[U] ::
//   [empty]
//   `?` GroupName[?U]
pp$8.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName[U] ::
//   `<` RegExpIdentifierName[?U] `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName[U] ::
//   RegExpIdentifierStart[?U]
//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$8.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart[U] ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
pp$8.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart[U] ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[?U]
//   <ZWNJ>
//   <ZWJ>
pp$8.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var ch = state.current();
  state.advance();

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$8.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$8.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$8.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$8.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$8.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$8.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$8.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
  var start = state.pos;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      state.switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$8.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$8.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$8.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true
  }

  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    (ch === 0x50 /* P */ || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    if (
      state.eat(0x7B /* { */) &&
      this.regexp_eatUnicodePropertyValueExpression(state) &&
      state.eat(0x7D /* } */)
    ) {
      return true
    }
    state.raise("Invalid property name");
  }

  return false
};
function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return true
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true
  }
  return false
};
pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!has(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};
pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue))
    { state.raise("Invalid property name"); }
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$8.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$8.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    state.eat(0x5E /* ^ */);
    this.regexp_classRanges(state);
    if (state.eat(0x5D /* [ */)) {
      return true
    }
    // Unreachable since it threw "unterminated regular expression" error before.
    state.raise("Unterminated character class");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$8.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$8.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* [ */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$8.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$8.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$8.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$8.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$8.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$8.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$9 = Parser.prototype;

// Move to the next token

pp$9.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$9.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$9[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$9.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$9.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$9.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$9.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$9.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this.curLine;
      this.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$9.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$9.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$9.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$9.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$9.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$9.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$9.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$9.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$9.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$9.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$9.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$9.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
};

pp$9.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp$9.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$9.readInt = function(radix, len) {
  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$9.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$9.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var str$1 = this.input.slice(start, this.pos);
    var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types.num, val$1)
  }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos);
  var val = octal ? parseInt(str, 8) : parseFloat(str);
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$9.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString$1(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$9.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else {
      if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$9.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$9.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$9.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$9.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$9.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString$1(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$9.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$9.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString$1(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$9.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.

var version = "6.3.0";

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse(input, options) {
  return Parser.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options)
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return Parser.tokenizer(input, options)
}




/***/ }),

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),

/***/ "./node_modules/animejs/lib/anime.es.js":
/*!**********************************************!*\
  !*** ./node_modules/animejs/lib/anime.es.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; }
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.round(t * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  switch (path.property) {
    case 'x': return (p.x - svg.x) * svg.w;
    case 'y': return (p.y - svg.y) * svg.h;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = (function () {
  function play() { 
    raf = requestAnimationFrame(step);
  }
  function step(t) {
    var activeInstancesLength = activeInstances.length;
    if (activeInstancesLength) {
      var i = 0;
      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];
        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);
          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }
        i++;
      }
      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }
  return play;
})();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) { return ins.pause(); });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) { return ins.play(); });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    if (!raf) { engine(); }
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);
    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);
      if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
    }
    if (!animations.length && !children.length) { instance.pause(); }
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

/* harmony default export */ __webpack_exports__["default"] = (anime);


/***/ }),

/***/ "./node_modules/arraybuffer.slice/index.js":
/*!*************************************************!*\
  !*** ./node_modules/arraybuffer.slice/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/blob/index.js":
/*!************************************!*\
  !*** ./node_modules/blob/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :
  typeof WebKitBlobBuilder !== 'undefined' ? WebKitBlobBuilder :
  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :
  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : 
  false;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  return ary.map(function(chunk) {
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      return buf;
    }

    return chunk;
  });
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary).forEach(function(part) {
    bb.append(part);
  });

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  return new Blob(mapArrayBufferViews(ary), options || {});
};

if (typeof Blob !== 'undefined') {
  BlobBuilderConstructor.prototype = Blob.prototype;
  BlobConstructor.prototype = Blob.prototype;
}

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
function log(...args) {
	// This hackery is required for IE8/9, where
	// the `console.log` function doesn't have 'apply'
	return typeof console === 'object' &&
		console.log &&
		console.log(...args);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return match;
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		createDebug.instances.push(debug);

		return debug;
	}

	function destroy() {
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) {
			createDebug.instances.splice(index, 1);
			return true;
		}
		return false;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}

		for (i = 0; i < createDebug.instances.length; i++) {
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(/*! ./socket */ "./node_modules/engine.io-client/lib/socket.js");

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");


/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('engine.io-client:socket');
var index = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (typeof location !== 'undefined' && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (typeof location !== 'undefined' ? location.hostname : 'localhost');
  this.port = opts.port || (typeof location !== 'undefined' && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.withCredentials = false !== opts.withCredentials;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.transportOptions = opts.transportOptions || {};
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // detect ReactNative environment
  this.isReactNative = (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative');

  // other options for Node.js or ReactNative client
  if (typeof self === 'undefined' || this.isReactNative) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(/*! ./transport */ "./node_modules/engine.io-client/lib/transport.js");
Socket.transports = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io-client/lib/transports/index.js");
Socket.parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // per-transport options
  var options = this.transportOptions[name] || {};

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    query: query,
    socket: this,
    agent: options.agent || this.agent,
    hostname: options.hostname || this.hostname,
    port: options.port || this.port,
    secure: options.secure || this.secure,
    path: options.path || this.path,
    forceJSONP: options.forceJSONP || this.forceJSONP,
    jsonp: options.jsonp || this.jsonp,
    forceBase64: options.forceBase64 || this.forceBase64,
    enablesXDR: options.enablesXDR || this.enablesXDR,
    withCredentials: options.withCredentials || this.withCredentials,
    timestampRequests: options.timestampRequests || this.timestampRequests,
    timestampParam: options.timestampParam || this.timestampParam,
    policyPort: options.policyPort || this.policyPort,
    pfx: options.pfx || this.pfx,
    key: options.key || this.key,
    passphrase: options.passphrase || this.passphrase,
    cert: options.cert || this.cert,
    ca: options.ca || this.ca,
    ciphers: options.ciphers || this.ciphers,
    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
    extraHeaders: options.extraHeaders || this.extraHeaders,
    forceNode: options.forceNode || this.forceNode,
    localAddress: options.localAddress || this.localAddress,
    requestTimeout: options.requestTimeout || this.requestTimeout,
    protocols: options.protocols || void (0),
    isReactNative: this.isReactNative
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(JSON.parse(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // results of ReactNative environment detection
  this.isReactNative = opts.isReactNative;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var XHR = __webpack_require__(/*! ./polling-xhr */ "./node_modules/engine.io-client/lib/transports/polling-xhr.js");
var JSONP = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js");
var websocket = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io-client/lib/transports/websocket.js");

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module requirements.
 */

var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * Until https://github.com/tc39/proposal-global is shipped.
 */
function glob () {
  return typeof self !== 'undefined' ? self
      : typeof window !== 'undefined' ? window
      : typeof global !== 'undefined' ? global : {};
}

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    var global = glob();
    callbacks = global.___eio = (global.___eio || []);
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (typeof addEventListener === 'function') {
    addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global attachEvent */

/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
var Polling = __webpack_require__(/*! ./polling */ "./node_modules/engine.io-client/lib/transports/polling.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/engine.io-client/node_modules/component-emitter/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;
  this.extraHeaders = opts.extraHeaders;

  if (typeof location !== 'undefined') {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = (typeof location !== 'undefined' && opts.hostname !== location.hostname) ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;
  opts.withCredentials = this.withCredentials;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.withCredentials = opts.withCredentials;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = this.withCredentials;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 2) {
          try {
            var contentType = xhr.getResponseHeader('Content-Type');
            if (self.supportsBinary && contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
              xhr.responseType = 'arraybuffer';
            }
          } catch (e) {}
        }
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(typeof xhr.status === 'number' ? xhr.status : 0);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (typeof document !== 'undefined') {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (typeof document !== 'undefined') {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type');
    } catch (e) {}
    if (contentType === 'application/octet-stream' || contentType === 'application/octet-stream; charset=UTF-8') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      data = this.xhr.responseText;
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (typeof document !== 'undefined') {
  if (typeof attachEvent === 'function') {
    attachEvent('onunload', unloadHandler);
  } else if (typeof addEventListener === 'function') {
    var terminationEvent = 'onpagehide' in self ? 'pagehide' : 'unload';
    addEventListener(terminationEvent, unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ "./node_modules/engine.io-client/lib/xmlhttprequest.js");
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(/*! ../transport */ "./node_modules/engine.io-client/lib/transport.js");
var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/lib/browser.js");
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var inherit = __webpack_require__(/*! component-inherit */ "./node_modules/component-inherit/index.js");
var yeast = __webpack_require__(/*! yeast */ "./node_modules/yeast/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('engine.io-client:websocket');

var BrowserWebSocket, NodeWebSocket;

if (typeof WebSocket !== 'undefined') {
  BrowserWebSocket = WebSocket;
} else if (typeof self !== 'undefined') {
  BrowserWebSocket = self.WebSocket || self.MozWebSocket;
}

if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(/*! ws */ 2);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocketImpl = BrowserWebSocket || NodeWebSocket;

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  this.protocols = opts.protocols;
  if (!this.usingBrowserWebSocket) {
    WebSocketImpl = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = this.protocols;
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws =
      this.usingBrowserWebSocket && !this.isReactNative
        ? protocols
          ? new WebSocketImpl(uri, protocols)
          : new WebSocketImpl(uri)
        : new WebSocketImpl(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocketImpl && !('__initialize' in WebSocketImpl && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/engine.io-client/lib/xmlhttprequest.js":
/*!*************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/xmlhttprequest.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(/*! has-cors */ "./node_modules/has-cors/index.js");

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new self[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};


/***/ }),

/***/ "./node_modules/engine.io-client/node_modules/component-emitter/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/engine.io-client/node_modules/component-emitter/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/browser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var keys = __webpack_require__(/*! ./keys */ "./node_modules/engine.io-parser/lib/keys.js");
var hasBinary = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");
var sliceBuffer = __webpack_require__(/*! arraybuffer.slice */ "./node_modules/arraybuffer.slice/index.js");
var after = __webpack_require__(/*! after */ "./node_modules/after/index.js");
var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/engine.io-parser/lib/utf8.js");

var base64encoder;
if (typeof ArrayBuffer !== 'undefined') {
  base64encoder = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(/*! blob */ "./node_modules/blob/index.js");

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data === 'string') {
    if (data.charAt(0) === 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data, { strict: false });
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data !== 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '', n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    }

    if (length === '' || (length != (n = Number(length)))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = exports.decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var ret = callback(packet, i + n, l);
      if (false === ret) return;
    }

    // advance cursor
    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] === 255) break;

      // 310 = char length of Number.MAX_VALUE
      if (msgLength.length > 310) {
        return callback(err, 0, 1);
      }

      msgLength += tailArray[i];
    }

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),

/***/ "./node_modules/engine.io-parser/lib/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/utf8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/utf8js v2.1.2 by @mathias */

var stringFromCharCode = String.fromCharCode;

// Taken from https://mths.be/punycode
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	var value;
	var extra;
	while (counter < length) {
		value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// high surrogate, and there is a next character
			extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // low surrogate
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// unmatched surrogate; only append this code unit, in case the next
				// code unit is the high surrogate of a surrogate pair
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

// Taken from https://mths.be/punycode
function ucs2encode(array) {
	var length = array.length;
	var index = -1;
	var value;
	var output = '';
	while (++index < length) {
		value = array[index];
		if (value > 0xFFFF) {
			value -= 0x10000;
			output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
			value = 0xDC00 | value & 0x3FF;
		}
		output += stringFromCharCode(value);
	}
	return output;
}

function checkScalarValue(codePoint, strict) {
	if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
		if (strict) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
		return false;
	}
	return true;
}
/*--------------------------------------------------------------------------*/

function createByte(codePoint, shift) {
	return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
}

function encodeCodePoint(codePoint, strict) {
	if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
		return stringFromCharCode(codePoint);
	}
	var symbol = '';
	if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
		symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
	}
	else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
		if (!checkScalarValue(codePoint, strict)) {
			codePoint = 0xFFFD;
		}
		symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
		symbol += createByte(codePoint, 6);
	}
	else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
		symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
		symbol += createByte(codePoint, 12);
		symbol += createByte(codePoint, 6);
	}
	symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
	return symbol;
}

function utf8encode(string, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	var codePoints = ucs2decode(string);
	var length = codePoints.length;
	var index = -1;
	var codePoint;
	var byteString = '';
	while (++index < length) {
		codePoint = codePoints[index];
		byteString += encodeCodePoint(codePoint, strict);
	}
	return byteString;
}

/*--------------------------------------------------------------------------*/

function readContinuationByte() {
	if (byteIndex >= byteCount) {
		throw Error('Invalid byte index');
	}

	var continuationByte = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	if ((continuationByte & 0xC0) == 0x80) {
		return continuationByte & 0x3F;
	}

	// If we end up here, it’s not a continuation byte
	throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
	var byte1;
	var byte2;
	var byte3;
	var byte4;
	var codePoint;

	if (byteIndex > byteCount) {
		throw Error('Invalid byte index');
	}

	if (byteIndex == byteCount) {
		return false;
	}

	// Read first byte
	byte1 = byteArray[byteIndex] & 0xFF;
	byteIndex++;

	// 1-byte sequence (no continuation bytes)
	if ((byte1 & 0x80) == 0) {
		return byte1;
	}

	// 2-byte sequence
	if ((byte1 & 0xE0) == 0xC0) {
		byte2 = readContinuationByte();
		codePoint = ((byte1 & 0x1F) << 6) | byte2;
		if (codePoint >= 0x80) {
			return codePoint;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 3-byte sequence (may include unpaired surrogates)
	if ((byte1 & 0xF0) == 0xE0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
		if (codePoint >= 0x0800) {
			return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
		} else {
			throw Error('Invalid continuation byte');
		}
	}

	// 4-byte sequence
	if ((byte1 & 0xF8) == 0xF0) {
		byte2 = readContinuationByte();
		byte3 = readContinuationByte();
		byte4 = readContinuationByte();
		codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
			(byte3 << 0x06) | byte4;
		if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
			return codePoint;
		}
	}

	throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;
function utf8decode(byteString, opts) {
	opts = opts || {};
	var strict = false !== opts.strict;

	byteArray = ucs2decode(byteString);
	byteCount = byteArray.length;
	byteIndex = 0;
	var codePoints = [];
	var tmp;
	while ((tmp = decodeSymbol(strict)) !== false) {
		codePoints.push(tmp);
	}
	return ucs2encode(codePoints);
}

module.exports = {
	version: '2.1.2',
	encode: utf8encode,
	decode: utf8decode
};


/***/ }),

/***/ "./node_modules/has-binary2/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-binary2/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* global Blob File */

/*
 * Module requirements.
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/has-binary2/node_modules/isarray/index.js");

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' ||
                        typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';
var withNativeFile = typeof File === 'function' ||
                        typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Supports Buffer, ArrayBuffer, Blob and File.
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary (obj) {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }

  if ((typeof Buffer === 'function' && Buffer.isBuffer && Buffer.isBuffer(obj)) ||
    (typeof ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||
    (withNativeBlob && obj instanceof Blob) ||
    (withNativeFile && obj instanceof File)
  ) {
    return true;
  }

  // see: https://github.com/Automattic/has-binary/pull/4
  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/has-binary2/node_modules/isarray/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/has-binary2/node_modules/isarray/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/has-cors/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-cors/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/paper/dist/paper-full.js":
/*!***********************************************!*\
  !*** ./node_modules/paper/dist/paper-full.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Paper.js v0.12.3 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2019, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Sat Jun 22 14:16:49 2019 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2019 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = function(self, undefined) {

self = self || __webpack_require__(/*! ./node/self.js */ 0);
var window = self.window,
	document = self.document;

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,
		array = [],
		slice = array.slice,
		create = Object.create,
		describe = Object.getOwnPropertyDescriptor,
		define = Object.defineProperty,

		forEach = array.forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++) {
				iter.call(bind, this[i], i, this);
			}
		},

		forIn = function(iter, bind) {
			for (var i in this) {
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
			}
		},

		set = Object.assign || function(dst) {
			for (var i = 1, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				for (var key in src) {
					if (src.hasOwnProperty(key))
						dst[key] = src[key];
				}
			}
			return dst;
		},

		each = function(obj, iter, bind) {
			if (obj) {
				var desc = describe(obj, 'length');
				(desc && typeof desc.value === 'number' ? forEach : forIn)
					.call(obj, iter, bind = bind || obj);
			}
			return bind;
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res)) {
					res = { value: res, writable: true };
				}
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable != null ? enumerable : !bean;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function Base() {
		for (var i = 0, l = arguments.length; i < l; i++) {
			var src = arguments[i];
			if (src)
				set(this, src);
		}
		return this;
	}

	return inject(Base, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, null, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, obj, l = arguments.length;
					i < l && !(ctor && proto); i++) {
				obj = arguments[i];
				ctor = ctor || obj.initialize;
				proto = proto || obj.prototype;
			}
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = proto || create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}).inject({
		enumerable: false,

		initialize: Base,

		set: Base,

		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src) {
					inject(this, src, src.enumerable, src.beans, src.preserve);
				}
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			set: set,
			each: each,
			create: create,
			define: define,
			describe: describe,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			},

			slice: function(list, begin, end) {
				return slice.call(list, begin, end);
			}
		}
	});
};

if (true)
	module.exports = Base;

Base.inject({
	enumerable: false,

	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	importJSON: function(json) {
		return Base.importJSON(json, this);
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	set: function(props, exclude) {
		if (props)
			Base.filter(this, props, exclude, this._prioritize);
		return this;
	}
}, {

beans: false,
statics: {
	exports: {},

	extend: function extend() {
		var res = extend.base.apply(this, arguments),
			name = res.prototype._class;
		if (name && !Base.exports[name])
			Base.exports[name] = res;
		return res;
	},

	equals: function(obj1, obj2) {
		if (obj1 === obj2)
			return true;
		if (obj1 && obj1.equals)
			return obj1.equals(obj2);
		if (obj2 && obj2.equals)
			return obj2.equals(obj1);
		if (obj1 && obj2
				&& typeof obj1 === 'object' && typeof obj2 === 'object') {
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				var length = obj1.length;
				if (length !== obj2.length)
					return false;
				while (length--) {
					if (!Base.equals(obj1[length], obj2[length]))
						return false;
				}
			} else {
				var keys = Object.keys(obj1),
					length = keys.length;
				if (length !== Object.keys(obj2).length)
					return false;
				while (length--) {
					var key = keys[length];
					if (!(obj2.hasOwnProperty(key)
							&& Base.equals(obj1[key], obj2[key])))
						return false;
				}
			}
			return true;
		}
		return false;
	},

	read: function(list, start, options, amount) {
		if (this === Base) {
			var value = this.peek(list, start);
			list.__index++;
			return value;
		}
		var proto = this.prototype,
			readIndex = proto._readIndex,
			begin = start || readIndex && list.__index || 0,
			length = list.length,
			obj = list[begin];
		amount = amount || length - begin;
		if (obj instanceof this
			|| options && options.readNull && obj == null && amount <= 1) {
			if (readIndex)
				list.__index = begin + 1;
			return obj && options && options.clone ? obj.clone() : obj;
		}
		obj = Base.create(proto);
		if (readIndex)
			obj.__read = true;
		obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length
				? Base.slice(list, begin, begin + amount)
				: list) || obj;
		if (readIndex) {
			list.__index = begin + obj.__read;
			var filtered = obj.__filtered;
			if (filtered) {
				list.__filtered = filtered;
				obj.__filtered = undefined;
			}
			obj.__read = undefined;
		}
		return obj;
	},

	peek: function(list, start) {
		return list[list.__index = start || list.__index || 0];
	},

	remain: function(list) {
		return list.length - (list.__index || 0);
	},

	readList: function(list, start, options, amount) {
		var res = [],
			entry,
			begin = start || 0,
			end = amount ? begin + amount : list.length;
		for (var i = begin; i < end; i++) {
			res.push(Array.isArray(entry = list[i])
					? this.read(entry, 0, options)
					: this.read(list, i, options, 1));
		}
		return res;
	},

	readNamed: function(list, name, start, options, amount) {
		var value = this.getNamed(list, name),
			hasObject = value !== undefined;
		if (hasObject) {
			var filtered = list.__filtered;
			if (!filtered) {
				filtered = list.__filtered = Base.create(list[0]);
				filtered.__unfiltered = list[0];
			}
			filtered[name] = undefined;
		}
		var l = hasObject ? [value] : list,
			res = this.read(l, start, options, amount);
		return res;
	},

	getNamed: function(list, name) {
		var arg = list[0];
		if (list._hasObject === undefined)
			list._hasObject = list.length === 1 && Base.isPlainObject(arg);
		if (list._hasObject)
			return name ? arg[name] : list.__filtered || arg;
	},

	hasNamed: function(list, name) {
		return !!this.getNamed(list, name);
	},

	filter: function(dest, source, exclude, prioritize) {
		var processed;

		function handleKey(key) {
			if (!(exclude && key in exclude) &&
				!(processed && key in processed)) {
				var value = source[key];
				if (value !== undefined)
					dest[key] = value;
			}
		}

		if (prioritize) {
			var keys = {};
			for (var i = 0, key, l = prioritize.length; i < l; i++) {
				if ((key = prioritize[i]) in source) {
					handleKey(key);
					keys[key] = true;
				}
			}
			processed = keys;
		}

		Object.keys(source.__unfiltered || source).forEach(handleKey);
		return dest;
	},

	isPlainValue: function(obj, asString) {
		return Base.isPlainObject(obj) || Array.isArray(obj)
				|| asString && typeof obj === 'string';
	},

	serialize: function(obj, options, compact, dictionary) {
		options = options || {};

		var isRoot = !dictionary,
			res;
		if (isRoot) {
			options.formatter = new Formatter(options.precision);
			dictionary = {
				length: 0,
				definitions: {},
				references: {},
				add: function(item, create) {
					var id = '#' + item._id,
						ref = this.references[id];
					if (!ref) {
						this.length++;
						var res = create.call(item),
							name = item._class;
						if (name && res[0] !== name)
							res.unshift(name);
						this.definitions[id] = res;
						ref = this.references[id] = [id];
					}
					return ref;
				}
			};
		}
		if (obj && obj._serialize) {
			res = obj._serialize(options, dictionary);
			var name = obj._class;
			if (name && !obj._compactSerialize && (isRoot || !compact)
					&& res[0] !== name) {
				res.unshift(name);
			}
		} else if (Array.isArray(obj)) {
			res = [];
			for (var i = 0, l = obj.length; i < l; i++)
				res[i] = Base.serialize(obj[i], options, compact, dictionary);
		} else if (Base.isPlainObject(obj)) {
			res = {};
			var keys = Object.keys(obj);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				res[key] = Base.serialize(obj[key], options, compact,
						dictionary);
			}
		} else if (typeof obj === 'number') {
			res = options.formatter.number(obj, options.precision);
		} else {
			res = obj;
		}
		return isRoot && dictionary.length > 0
				? [['dictionary', dictionary.definitions], res]
				: res;
	},

	deserialize: function(json, create, _data, _setDictionary, _isRoot) {
		var res = json,
			isFirst = !_data,
			hasDictionary = isFirst && json && json.length
				&& json[0][0] === 'dictionary';
		_data = _data || {};
		if (Array.isArray(json)) {
			var type = json[0],
				isDictionary = type === 'dictionary';
			if (json.length == 1 && /^#/.test(type)) {
				return _data.dictionary[type];
			}
			type = Base.exports[type];
			res = [];
			for (var i = type ? 1 : 0, l = json.length; i < l; i++) {
				res.push(Base.deserialize(json[i], create, _data,
						isDictionary, hasDictionary));
			}
			if (type) {
				var args = res;
				if (create) {
					res = create(type, args, isFirst || _isRoot);
				} else {
					res = new type(args);
				}
			}
		} else if (Base.isPlainObject(json)) {
			res = {};
			if (_setDictionary)
				_data.dictionary = res;
			for (var key in json)
				res[key] = Base.deserialize(json[key], create, _data);
		}
		return hasDictionary ? res[1] : res;
	},

	exportJSON: function(obj, options) {
		var json = Base.serialize(obj, options);
		return options && options.asString == false
				? json
				: JSON.stringify(json);
	},

	importJSON: function(json, target) {
		return Base.deserialize(
				typeof json === 'string' ? JSON.parse(json) : json,
				function(ctor, args, isRoot) {
					var useTarget = isRoot && target
							&& target.constructor === ctor,
						obj = useTarget ? target
							: Base.create(ctor.prototype);
					if (args.length === 1 && obj instanceof Item
							&& (useTarget || !(obj instanceof Layer))) {
						var arg = args[0];
						if (Base.isPlainObject(arg)) {
							arg.insert = false;
							if (useTarget) {
								args = args.concat([{ insert: true }]);
							}
						}
					}
					(useTarget ? obj.set : ctor).apply(obj, args);
					if (useTarget)
						target = null;
					return obj;
				});
	},

	push: function(list, items) {
		var itemsLength = items.length;
		if (itemsLength < 4096) {
			list.push.apply(list, items);
		} else {
			var startLength = list.length;
			list.length += itemsLength;
			for (var i = 0; i < itemsLength; i++) {
				list[startLength + i] = items[i];
			}
		}
		return list;
	},

	splice: function(list, items, index, remove) {
		var amount = items && items.length,
			append = index === undefined;
		index = append ? list.length : index;
		if (index > list.length)
			index = list.length;
		for (var i = 0; i < amount; i++)
			items[i]._index = index + i;
		if (append) {
			Base.push(list, items);
			return [];
		} else {
			var args = [index, remove];
			if (items)
				Base.push(args, items);
			var removed = list.splice.apply(list, args);
			for (var i = 0, l = removed.length; i < l; i++)
				removed[i]._index = undefined;
			for (var i = index + amount, l = list.length; i < l; i++)
				list[i]._index = i;
			return removed;
		}
	},

	capitalize: function(str) {
		return str.replace(/\b[a-z]/g, function(match) {
			return match.toUpperCase();
		});
	},

	camelize: function(str) {
		return str.replace(/-(.)/g, function(match, chr) {
			return chr.toUpperCase();
		});
	},

	hyphenate: function(str) {
		return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	}
}});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function handler() {
			func.apply(this, arguments);
			this.off(type, handler);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = Base.slice(arguments, 1),
			setTarget = event && event.target && !event.currentTarget;
		handlers = handlers.slice();
		if (setTarget)
			event.currentTarget = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) == false) {
				if (event && event.stop)
					event.stop();
				break;
		   }
		}
		if (setTarget)
			delete event.currentTarget;
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var types = this._eventTypes,
			handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		if (types) {
			for (var type in handlers) {
				if (handlers[type].length > 0) {
					var entry = types[type],
						func = entry && entry[key];
					if (func)
						func.call(this, type);
				}
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			insertItems: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1) || {};
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
		if (!this.agent) {
			var user = self.navigator.userAgent.toLowerCase(),
				os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],
				platform = os === 'darwin' ? 'mac' : os,
				agent = proto.agent = proto.browser = { platform: platform };
			if (platform)
				agent[platform] = true;
			user.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
				function(match, n, v1, v2, rv) {
					if (!agent.chrome) {
						var v = n === 'opera' ? v2 :
								/^(node|trident)$/.test(n) ? rv : v1;
						agent.version = v;
						agent.versionNumber = parseFloat(v);
						n = { trident: 'msie', jsdom: 'node' }[n] || n;
						agent.name = n;
						agent[n] = true;
					}
				}
			);
			if (agent.chrome)
				delete agent.webkit;
			if (agent.atom)
				delete agent.chrome;
		}
	},

	version: "0.12.3",

	getView: function() {
		var project = this.project;
		return project && project._view;
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, options) {
			var exports = paper.PaperScript.execute(code, this, options);
			View.updateFocus();
			return exports;
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	createCanvas: function(width, height) {
		return CanvasProvider.getCanvas(width, height);
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		var projects = this.projects,
			tools = this.tools;
		for (var i = projects.length - 1; i >= 0; i--)
			projects[i].remove();
		for (var i = tools.length - 1; i >= 0; i--)
			tools[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	},

	getView: function() {
		return this._scope.getView();
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = Base.pick(precision, 5);
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return this.precision < 16
				? Math.round(val * this.multiplier) / this.multiplier : val;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		log2 = Math.log2 || function(x) {
			return Math.log(x) * Math.LOG2E;
		},
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clamp(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	function getDiscriminant(a, b, c) {
		function split(v) {
			var x = v * 134217729,
				y = v - x,
				hi = y + x,
				lo = v - hi;
			return [hi, lo];
		}

		var D = b * b - a * c,
			E = b * b + a * c;
		if (abs(D) * 3 < E) {
			var ad = split(a),
				bd = split(b),
				cd = split(c),
				p = b * b,
				dp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],
				q = a * c,
				dq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])
						+ ad[1] * cd[1];
			D = (p - q) + (dp - dq);
		}
		return D;
	}

	function getNormalizationFactor() {
		var norm = Math.max.apply(Math, arguments);
		return norm && (norm < 1e-8 || norm > 1e8)
				? pow(2, -Math.round(log2(norm)))
				: 0;
	}

	return {
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 1e-8,
		GEOMETRIC_EPSILON: 1e-7,
		TRIGONOMETRIC_EPSILON: 1e-8,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		clamp: clamp,

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance) {
					x = nx;
					break;
				}
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return clamp(x, a, b);
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var x1, x2 = Infinity;
			if (abs(a) < EPSILON) {
				if (abs(b) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / b;
			} else {
				b *= -0.5;
				var D = getDiscriminant(a, b, c);
				if (D && abs(D) < MACHINE_EPSILON) {
					var f = getNormalizationFactor(abs(a), abs(b), abs(c));
					if (f) {
						a *= f;
						b *= f;
						c *= f;
						D = getDiscriminant(a, b, c);
					}
				}
				if (D >= -MACHINE_EPSILON) {
					var Q = D < 0 ? 0 : sqrt(D),
						R = b + (b < 0 ? -Q : Q);
					if (R === 0) {
						x1 = c / a;
						x2 = -x1;
					} else {
						x1 = R / a;
						x2 = c / R;
					}
				}
			}
			var count = 0,
				boundless = min == null,
				minB = min - EPSILON,
				maxB = max + EPSILON;
			if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))
				roots[count++] = boundless ? x1 : clamp(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))
				roots[count++] = boundless ? x2 : clamp(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),
				x, b1, c2, qd, q;
			if (f) {
				a *= f;
				b *= f;
				c *= f;
				d *= f;
			}

			function evaluate(x0) {
				x = x0;
				var tmp = a * x;
				b1 = tmp + b;
				c2 = b1 * x + c;
				qd = (tmp + b1) * x + c2;
				q = c2 * x + d;
			}

			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				evaluate(-(b / a) / 3);
				var t = q / a,
					r = pow(abs(t), 1/3),
					s = t < 0 ? -1 : 1,
					td = -qd / a,
					rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,
					x0 = x - s * rd;
				if (x0 !== x) {
					do {
						evaluate(x0);
						x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),
				boundless = min == null;
			if (isFinite(x) && (count === 0
					|| count > 0 && x !== roots[0] && x !== roots[1])
					&& (boundless || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = boundless ? x : clamp(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(name) {
		if (name) {
			var pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this._set(arg0, hasY ? arg1 : arg0);
			if (reading)
				read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('angle' in obj) {
				this._set(obj.length || 0, 0);
				this.setAngle(obj.angle || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this._set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this._set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var point = Point.read(arguments),
			tolerance = Base.read(arguments);
		return this.getDistance(point) <= tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.x) && isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	isInQuadrant: function(q) {
		return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0
			&& this.y * (q > 2 ? -1 : 1) >= 0;
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-8;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		return this._setter === 'setPosition' ? 4 : 0;
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0,
			reading = this.__read,
			read = 0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this._set(arg0, hasHeight ? arg1 : arg0);
			if (reading)
				read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0);
			if (reading)
				read = arg0 === null ? 1 : 0;
		} else {
			var obj = type === 'string' ? arg0.split(/[\s,]+/) || [] : arg0;
			read = 1;
			if (Array.isArray(obj)) {
				this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));
			} else if ('width' in obj) {
				this._set(obj.width || 0, obj.height || 0);
			} else if ('x' in obj) {
				this._set(obj.x || 0, obj.y || 0);
			} else {
				this._set(0, 0);
				read = 0;
			}
		}
		if (reading)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this.width) && isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {
	var op = Math[key];
	this[key] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read;
		if (type === 'number') {
			this._set(arg0, arg1, arg2, arg3);
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this._set(0, 0, 0, 0);
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this._set.apply(this, arg0);
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this._set(arg0.x || 0, arg0.y || 0,
						arg0.width || 0, arg0.height || 0);
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this._set(0, 0, 0, 0);
				Base.filter(this, arg0);
				read = 1;
			}
		}
		if (read === undefined) {
			var frm = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments),
				x = frm.x,
				y = frm.y,
				width,
				height;
			if (next && next.x !== undefined
					|| Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				width = to.x - x;
				height = to.y - y;
				if (width < 0) {
					x = to.x;
					width = -width;
				}
				if (height < 0) {
					y = to.y;
					height = -height;
				}
			} else {
				var size = Size.read(arguments);
				width = size.width;
				height = size.height;
			}
			this._set(x, y, width, height);
			read = arguments.__index;
			var filtered = arguments.__filtered;
			if (filtered)
				this.__filtered = filtered;
		}
		if (this.__read)
			this.__read = read;
		return this;
	},

	set: '#initialize',

	_set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	_fw: 1,
	_fh: 1,

	setSize: function() {
		var size = Size.read(arguments),
			sx = this._sx,
			sy = this._sy,
			w = size.width,
			h = size.height;
		if (sx) {
			this.x += (this.width - w) * sx;
		}
		if (sy) {
			this.y += (this.height - h) * sy;
		}
		this.width = w;
		this.height = h;
		this._fw = this._fh = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fw) {
			var amount = left - this.x;
			this.width -= this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = left;
		this._sx = this._fw = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fh) {
			var amount = top - this.y;
			this.height -= this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = top;
		this._sy = this._fh = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (!this._fw) {
			var amount = right - this.x;
			this.width = this._sx === 0.5 ? amount * 2 : amount;
		}
		this.x = right - this.width;
		this._sx = 1;
		this._fw = 0;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (!this._fh) {
			var amount = bottom - this.y;
			this.height = this._sy === 0.5 ? amount * 2 : amount;
		}
		this.y = bottom - this.height;
		this._sy = 1;
		this._fh = 0;
	},

	getCenterX: function() {
		return this.x + this.width / 2;
	},

	setCenterX: function(x) {
		if (this._fw || this._sx === 0.5) {
			this.x = x - this.width / 2;
		} else {
			if (this._sx) {
				this.x += (x - this.x) * 2 * this._sx;
			}
			this.width = (x - this.x) * 2;
		}
		this._sx = 0.5;
		this._fw = 0;
	},

	getCenterY: function() {
		return this.y + this.height / 2;
	},

	setCenterY: function(y) {
		if (this._fh || this._sy === 0.5) {
			this.y = y - this.height / 2;
		} else {
			if (this._sy) {
				this.y += (y - this.y) * 2 * this._sy;
			}
			this.height = (y - this.y) * 2;
		}
		this._sy = 0.5;
		this._fh = 0;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length === 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments),
			epsilon = Base.read(arguments) || 0;
		return rect.x + rect.width > this.x - epsilon
				&& rect.y + rect.height > this.y - epsilon
				&& rect.x < this.x + this.width + epsilon
				&& rect.y < this.y + this.height + epsilon;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join(''),
			xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this._set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	_set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key),
			internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return !!(this._owner._selection & 2);
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner._changeSelection) {
					owner._changeSelection(2, selected);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg, _dontNotify) {
		var count = arguments.length,
			ok = true;
		if (count >= 6) {
			this._set.apply(this, arguments);
		} else if (count === 1 || count === 2) {
			if (arg instanceof Matrix) {
				this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,
						_dontNotify);
			} else if (Array.isArray(arg)) {
				this._set.apply(this,
						_dontNotify ? arg.concat([_dontNotify]) : arg);
			} else {
				ok = false;
			}
		} else if (!count) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok) {
			throw new Error('Unsupported matrix parameters');
		}
		return this;
	},

	set: '#initialize',

	_set: function(a, b, c, d, tx, ty, _dontNotify) {
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.getValues(), options, true, dictionary);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(25);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._b, this._c, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._c),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._b), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._b = this._c = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true, Base.pick(recursively, true),
					_setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._c;
		this._ty += x * this._b + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._b *= scale.x;
		this._c *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * c;
		this._b = cos * b + sin * d;
		this._c = -sin * a + cos * c;
		this._d = -sin * b + cos * d;
		this._tx += tx * a + ty * c;
		this._ty += tx * b + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			b = this._b;
		this._a += shear.y * this._c;
		this._b += shear.y * this._d;
		this._c += shear.x * a;
		this._d += shear.x * b;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	append: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + c2 * c1;
			this._c = b2 * a1 + d2 * c1;
			this._b = a2 * b1 + c2 * d1;
			this._d = b2 * b1 + d2 * d1;
			this._tx += tx2 * a1 + ty2 * c1;
			this._ty += tx2 * b1 + ty2 * d1;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	prepend: function(mx, _dontNotify) {
		if (mx) {
			var a1 = this._a,
				b1 = this._b,
				c1 = this._c,
				d1 = this._d,
				tx1 = this._tx,
				ty1 = this._ty,
				a2 = mx._a,
				b2 = mx._c,
				c2 = mx._b,
				d2 = mx._d,
				tx2 = mx._tx,
				ty2 = mx._ty;
			this._a = a2 * a1 + b2 * b1;
			this._c = a2 * c1 + b2 * d1;
			this._b = c2 * a1 + d2 * b1;
			this._d = c2 * c1 + d2 * d1;
			this._tx = a2 * tx1 + b2 * ty1 + tx2;
			this._ty = c2 * tx1 + d2 * ty1 + ty2;
			if (!_dontNotify)
				this._changed();
		}
		return this;
	},

	appended: function(mx) {
		return this.clone().append(mx);
	},

	prepended: function(mx) {
		return this.clone().prepend(mx);
	},

	invert: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			this._a = d / det;
			this._b = -b / det;
			this._c = -c / det;
			this._d = a / det;
			this._tx = (c * ty - d * tx) / det;
			this._ty = (b * tx - a * ty) / det;
			res = this;
		}
		return res;
	},

	inverted: function() {
		return this.clone().invert();
	},

	concatenate: '#append',
	preConcatenate: '#prepend',
	chain: '#appended',

	_shiftless: function() {
		return new Matrix(this._a, this._b, this._c, this._d, 0, 0);
	},

	_orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isIdentity: function() {
		return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	isInvertible: function() {
		var det = this._a * this._d - this._c * this._b;
		return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);
	},

	isSingular: function() {
		return !this.isInvertible();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest._set(
				x * this._a + y * this._c + this._tx,
				x * this._b + y * this._d + this._ty,
				_dontNotify);
	},

	_transformCoordinates: function(src, dst, count) {
		for (var i = 0, max = 2 * count; i < max; i += 2) {
			var x = src[i],
				y = src[i + 1];
			dst[i] = x * this._a + y * this._c + this._tx;
			dst[i + 1] = x * this._b + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j]) {
				min[j] = val;
			} else if (val > max[j]) {
				max[j] = val;
			}
		}
		if (!dest)
			dest = new Rectangle();
		return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty,
			det = a * d - b * c,
			res = null;
		if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {
			var x = point.x - this._tx,
				y = point.y - this._ty;
			if (!dest)
				dest = new Point();
			res = dest._set(
					(x * d - y * c) / det,
					(y * a - x * b) / det,
					_dontNotify);
		}
		return res;
	},

	decompose: function() {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			det = a * d - b * c,
			sqrt = Math.sqrt,
			atan2 = Math.atan2,
			degrees = 180 / Math.PI,
			rotate,
			scale,
			skew;
		if (a !== 0 || b !== 0) {
			var r = sqrt(a * a + b * b);
			rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);
			scale = [r, det / r];
			skew = [atan2(a * c + b * d, r * r), 0];
		} else if (c !== 0 || d !== 0) {
			var s = sqrt(c * c + d * d);
			rotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);
			scale = [det / s, s];
			skew = [0, atan2(a * c + b * d, s * s)];
		} else {
			rotate = 0;
			skew = scale = [0, 0];
		}
		return {
			translation: this.getTranslation(),
			rotation: rotate * degrees,
			scaling: new Point(scale),
			skewing: new Point(skew[0] * degrees, skew[1] * degrees)
		};
	},

	getValues: function() {
		return [ this._a, this._b, this._c, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return this.decompose().scaling;
	},

	getRotation: function() {
		return this.decompose().rotation;
	},

	applyToContext: function(ctx) {
		if (!this.isIdentity()) {
			ctx.transform(this._a, this._b, this._c, this._d,
					this._tx, this._ty);
		}
	}
}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {
	var part = Base.capitalize(key),
		prop = '_' + key;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(this.getSignedDistance(point));
	},

	getSignedDistance: function(point) {
		return Line.getSignedDistance(this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (!isInfinite && Numerical.isZero(ccw)) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			return vx === 0 ? vy > 0 ? x - px : px - x
				 : vy === 0 ? vx < 0 ? y - py : py - y
				 : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);
		},

		getDistance: function(px, py, vx, vy, x, y, asVector) {
			return Math.abs(
					Line.getSignedDistance(px, py, vx, vy, x, y, asVector));
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',
	_compactSerialize: true,

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this._children = [];
		this._namedChildren = {};
		this._activeLayer = null;
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectionItems = {};
		this._selectionCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this._children, options, true, dictionary);
	},

	_changed: function(flags, item) {
		if (flags & 1) {
			var view = this._view;
			if (view) {
				view._needsUpdate = true;
				if (!view._requested && view._autoUpdate)
					view.requestUpdate();
			}
		}
		var changes = this._changes;
		if (changes && item) {
			var changesById = this._changesById,
				id = item._id,
				entry = changesById[id];
			if (entry) {
				entry.flags |= flags;
			} else {
				changes.push(changesById[id] = { item: item, flags: flags });
			}
		}
	},

	clear: function() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--)
			children[i].remove();
	},

	isEmpty: function() {
		return !this._children.length;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.set(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getLayers: function() {
		return this._children;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this, insert: true });
	},

	getSymbolDefinitions: function() {
		var definitions = [],
			ids = {};
		this.getItems({
			class: SymbolItem,
			match: function(item) {
				var definition = item._definition,
					id = definition._id;
				if (!ids[id]) {
					ids[id] = true;
					definitions.push(definition);
				}
				return false;
			}
		});
		return definitions;
	},

	getSymbols: 'getSymbolDefinitions',

	getSelectedItems: function() {
		var selectionItems = this._selectionItems,
			items = [];
		for (var id in selectionItems) {
			var item = selectionItems[id],
				selection = item._selection;
			if ((selection & 1) && item.isInserted()) {
				items.push(item);
			} else if (!selection) {
				this._updateSelection(item);
			}
		}
		return items;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectionItems = this._selectionItems;
		if (item._selection) {
			if (selectionItems[id] !== item) {
				this._selectionCount++;
				selectionItems[id] = item;
			}
		} else if (selectionItems[id] === item) {
			this._selectionCount--;
			delete selectionItems[id];
		}
	},

	selectAll: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectionItems = this._selectionItems;
		for (var i in selectionItems)
			selectionItems[i].setFullySelected(false);
	},

	addLayer: function(layer) {
		return this.insertLayer(undefined, layer);
	},

	insertLayer: function(index, layer) {
		if (layer instanceof Layer) {
			layer._remove(false, true);
			Base.splice(this._children, [layer], index, 0);
			layer._setProject(this, true);
			var name = layer._name;
			if (name)
				layer.setName(name);
			if (this._changes)
				layer._changed(5);
			if (!this._activeLayer)
				this._activeLayer = layer;
		} else {
			layer = null;
		}
		return layer;
	},

	_insertItem: function(index, item, _created) {
		item = this.insertLayer(index, item)
				|| (this._activeLayer || this._insertItem(undefined,
						new Layer(Item.NO_INSERT), true))
						.insertChild(index, item);
		if (_created && item.activate)
			item.activate();
		return item;
	},

	getItems: function(options) {
		return Item._getItems(this, options);
	},

	getItem: function(options) {
		return Item._getItems(this, options, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	removeOn: function(type) {
		var sets = this._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var children = this._children,
			param = new Base({
				offset: new Point(0, 0),
				pixelRatio: pixelRatio,
				viewMatrix: matrix.isIdentity() ? null : matrix,
				matrices: [new Matrix()],
				updateMatrix: true
			});
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].draw(ctx, param);
		}
		ctx.restore();

		if (this._selectionCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectionItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items) {
				items[id]._drawSelection(ctx, matrix, size, items, version);
			}
			ctx.restore();
		}
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = Base.set({},
					this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_name: null,
	_applyMatrix: true,
	_canApplyMatrix: true,
	_canScaleStroke: false,
	_pivot: null,
	_visible: true,
	_blendMode: 'normal',
	_opacity: 1,
	_locked: false,
	_guide: false,
	_clipMask: false,
	_selection: 0,
	_selectBounds: true,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		locked: false,
		guide: false,
		clipMask: false,
		selected: false,
		data: {}
	},
	_prioritize: ['applyMatrix']
},
new function() {
	var handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];
	return Base.each(handlers,
		function(name) {
			this._events[name] = {
				install: function(type) {
					this.getView()._countItemEvent(type, 1);
				},

				uninstall: function(type) {
					this.getView()._countItemEvent(type, -1);
				}
			};
		}, {
			_events: {
				onFrame: {
					install: function() {
						this.getView()._animateItem(this, true);
					},

					uninstall: function() {
						this.getView()._animateItem(this, false);
					}
				},

				onLoad: {},
				onError: {}
			},
			statics: {
				_itemHandlers: handlers
			}
		}
	);
}, {
	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project,
			settings = paper.settings;
		this._id = internal ? null : UID.get();
		this._parent = this._index = null;
		this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (internal || hasProps && props.insert == false
			|| !settings.insertItems && !(hasProps && props.insert === true)) {
			this._setProject(project);
		} else {
			(hasProps && props.parent || project)
					._insertItem(undefined, this, true);
		}
		if (hasProps && props !== Item.NO_INSERT) {
			this.set(props, {
				internal: true, insert: true, project: true, parent: true
			});
		}
		return hasProps;
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._symbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed = undefined;
		}
		if (flags & 16) {
			this._globalMatrix = undefined;
		}
		if (cacheParent
				&& (flags & 72)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project)
			project._changed(flags, this);
		if (symbol)
			symbol._changed(flags);
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var owner = this._getOwner();
		if (name && owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren;
			(namedChildren[name] = namedChildren[name] || []).push(this);
			if (!(name in children))
				children[name] = this;
		}
		this._name = name || undefined;
		this._changed(256);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			key = '_' + name,
			flags = {
				locked: 256,
				visible: 265
			};
		this['get' + part] = function() {
			return this[key];
		};
		this['set' + part] = function(value) {
			if (value != this[key]) {
				this[key] = value;
				this._changed(flags[name] || 257);
			}
		};
	},
{}), {
	beans: true,

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		if (selection !== this._selection) {
			this._selection = selection;
			var project = this._project;
			if (project) {
				project._updateSelection(this);
				this._changed(257);
			}
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return !!(this._selection & 1);
	},

	setSelected: function(selected) {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isFullySelected: function() {
		var children = this._children,
			selected = !!(this._selection & 1);
		if (children && selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this._changeSelection(1, selected);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(257);
			if (this._parent)
				this._parent._changed(2048);
		}
	},

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		var position = this._position ||
			(this._position = this._getPositionFromBounds());
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	_getPositionFromBounds: function(bounds) {
		return this._pivot
				? this._matrix._transformPoint(this._pivot)
				: (bounds || this.getBounds()).getCenter(true);
	},

	getPivot: function() {
		var pivot = this._pivot;
		return pivot
				? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')
				: null;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	}
}, Base.each({
		getStrokeBounds: { stroke: true },
		getHandleBounds: { handle: true },
		getInternalBounds: { internal: true }
	},
	function(options, key) {
		this[key] = function(matrix) {
			return this.getBounds(matrix, options);
		};
	},
{
	beans: true,

	getBounds: function(matrix, options) {
		var hasMatrix = options || matrix instanceof Matrix,
			opts = Base.set({}, hasMatrix ? options : matrix,
					this._boundsOptions);
		if (!opts.stroke || this.getStrokeScaling())
			opts.cacheItem = this;
		var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;
		return !arguments.length
				? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,
					this, 'setBounds')
				: rect;
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			_matrix = this._matrix,
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			if (!_matrix.isInvertible()) {
				_matrix.set(_matrix._backup
						|| new Matrix().translate(_matrix.getTranslation()));
				bounds = this.getBounds();
			}
			matrix.scale(
					bounds.width !== 0 ? rect.width / bounds.width : 0,
					bounds.height !== 0 ? rect.height / bounds.height : 0);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getBounds: function(matrix, options) {
		var children = this._children;
		if (!children || !children.length)
			return new Rectangle();
		Item._updateBoundsCache(this, options.cacheItem);
		return Item._getBounds(children, matrix, options);
	},

	_getBoundsCacheKey: function(options, internal) {
		return [
			options.stroke ? 1 : 0,
			options.handle ? 1 : 0,
			internal ? 1 : 0
		].join('');
	},

	_getCachedBounds: function(matrix, options, noInternal) {
		matrix = matrix && matrix._orNullIfIdentity();
		var internal = options.internal && !noInternal,
			cacheItem = options.cacheItem,
			_matrix = internal ? null : this._matrix._orNullIfIdentity(),
			cacheKey = cacheItem && (!matrix || matrix.equals(_matrix))
				&& this._getBoundsCacheKey(options, internal),
			bounds = this._bounds;
		Item._updateBoundsCache(this._parent || this._symbol, cacheItem);
		if (cacheKey && bounds && cacheKey in bounds) {
			var cached = bounds[cacheKey];
			return {
				rect: cached.rect.clone(),
				nonscaling: cached.nonscaling
			};
		}
		var res = this._getBounds(matrix || _matrix, options),
			rect = res.rect || res,
			style = this._style,
			nonscaling = res.nonscaling || style.hasStroke()
				&& !style.getStrokeScaling();
		if (cacheKey) {
			if (!bounds) {
				this._bounds = bounds = {};
			}
			var cached = bounds[cacheKey] = {
				rect: rect.clone(),
				nonscaling: nonscaling,
				internal: internal
			};
		}
		return {
			rect: rect,
			nonscaling: nonscaling
		};
	},

	_getStrokeMatrix: function(matrix, options) {
		var parent = this.getStrokeScaling() ? null
				: options && options.internal ? this
					: this._parent || this._symbol && this._symbol._item,
			mx = parent ? parent.getViewMatrix().invert() : matrix;
		return mx && mx._shiftless();
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent && item) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		},

		_getBounds: function(items, matrix, options) {
			var x1 = Infinity,
				x2 = -x1,
				y1 = x1,
				y2 = x2,
				nonscaling = false;
			options = options || {};
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				if (item._visible && !item.isEmpty(true)) {
					var bounds = item._getCachedBounds(
						matrix && matrix.appended(item._matrix), options, true),
						rect = bounds.rect;
					x1 = Math.min(rect.x, x1);
					y1 = Math.min(rect.y, y1);
					x2 = Math.max(rect.x + rect.width, x2);
					y2 = Math.max(rect.y + rect.height, y2);
					if (bounds.nonscaling)
						nonscaling = true;
				}
			}
			return {
				rect: isFinite(x1)
					? new Rectangle(x1, y1, x2 - x1, y2 - y1)
					: new Rectangle(),
				nonscaling: nonscaling
			};
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._applyMatrix
			? null
			: this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	getRotation: function() {
		var decomposed = this._decompose();
		return decomposed ? decomposed.rotation : 0;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			if (decomposed) {
				decomposed.rotation = rotation;
				this._decomposed = decomposed;
			}
		}
	},

	getScaling: function() {
		var decomposed = this._decompose(),
			s = decomposed && decomposed.scaling;
		return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling && !current.equals(scaling)) {
			var rotation = this.getRotation(),
				decomposed = this._decomposed,
				matrix = new Matrix(),
				center = this.getPosition(true);
			matrix.translate(center);
			if (rotation)
				matrix.rotate(rotation);
			matrix.scale(scaling.x / current.x, scaling.y / current.y);
			if (rotation)
				matrix.rotate(-rotation);
			matrix.translate(center.negate());
			this.transform(matrix);
			if (decomposed) {
				decomposed.scaling = scaling;
				this._decomposed = decomposed;
			}
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix;
		if (matrix) {
			var parent = this._parent;
			var parents = [];
			while (parent) {
				if (!parent._globalMatrix) {
					matrix = null;
					for (var i = 0, l = parents.length; i < l; i++) {
						parents[i]._globalMatrix = null;
					}
					break;
				}
				parents.push(parent);
				parent = parent._parent;
			}
		}
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.prepend(parent.getGlobalMatrix(true));
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getViewMatrix: function() {
		return this.getGlobalMatrix().prepend(this.getView()._matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project._view;
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	_getOwner: '#getParent',

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		var owner = this._getOwner();
		return owner && owner._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(options) {
		var copy = new this.constructor(Item.NO_INSERT),
			children = this._children,
			insert = Base.pick(options ? options.insert : undefined,
					options === undefined || options === true),
			deep = Base.pick(options ? options.deep : undefined, true);
		if (children)
			copy.copyAttributes(this);
		if (!children || deep)
			copy.copyContent(this);
		if (!children)
			copy.copyAttributes(this);
		if (insert)
			copy.insertAbove(this);
		var name = this._name,
			parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				orig = name,
				i = 1;
			while (children[name])
				name = orig + ' ' + (i++);
			if (name !== orig)
				copy.setName(name);
		}
		return copy;
	},

	copyContent: function(source) {
		var children = source._children;
		for (var i = 0, l = children && children.length; i < l; i++) {
			this.addChild(children[i].clone(false), true);
		}
	},

	copyAttributes: function(source, excludeMatrix) {
		this.setStyle(source._style);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (source.hasOwnProperty(key))
				this[key] = source[key];
		}
		if (!excludeMatrix)
			this._matrix.set(source._matrix, true);
		this.setApplyMatrix(source._applyMatrix);
		this.setPivot(source._pivot);
		this.setSelection(source._selection);
		var data = source._data,
			name = source._name;
		this._data = data ? Base.clone(data) : null;
		if (name)
			this.setName(name);
	},

	rasterize: function(resolution, insert) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			raster = new Raster(Item.NO_INSERT);
		if (!size.isZero()) {
			var canvas = CanvasProvider.getCanvas(size.multiply(scale)),
				ctx = canvas.getContext('2d'),
				matrix = new Matrix().scale(scale).translate(topLeft.negate());
			ctx.save();
			matrix.applyToContext(ctx);
			this.draw(ctx, new Base({ matrices: [matrix] }));
			ctx.restore();
			raster.setCanvas(canvas);
		}
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		if (insert === undefined || insert)
			raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		var matrix = this._matrix;
		return (
			matrix.isInvertible() &&
			!!this._contains(matrix._inverseTransform(Point.read(arguments)))
		);
	},

	_contains: function(point) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				if (children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix, true).length > 0;
	}
},
new function() {
	function hitTest() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(arguments));
	}

	function hitTestAll() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(arguments),
			all = [];
		this._hitTest(point, Base.set({ all: all }, options));
		return all;
	}

	function hitTestChildren(point, options, viewMatrix, _exclude) {
		var children = this._children;
		if (children) {
			for (var i = children.length - 1; i >= 0; i--) {
				var child = children[i];
				var res = child !== _exclude && child._hitTest(point, options,
						viewMatrix);
				if (res && !options.all)
					return res;
			}
		}
		return null;
	}

	Project.inject({
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTest: hitTestChildren
	});

	return {
		hitTest: hitTest,
		hitTestAll: hitTestAll,
		_hitTestChildren: hitTestChildren,
	};
}, {

	_hitTest: function(point, options, parentViewMatrix) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty()) {
			return null;
		}

		var matrix = this._matrix,
			viewMatrix = parentViewMatrix
					? parentViewMatrix.appended(matrix)
					: this.getGlobalMatrix().prepend(this.getView()._matrix),
			tolerance = Math.max(options.tolerance, 1e-12),
			tolerancePadding = options._tolerancePadding = new Size(
					Path._getStrokePadding(tolerance,
						matrix._shiftless().invert()));
		point = matrix._inverseTransform(point);
		if (!point || !this._children &&
			!this.getBounds({ internal: true, stroke: true, handle: true })
				.expand(tolerancePadding.multiply(2))._containsPoint(point)) {
			return null;
		}

		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this.isSelected()
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			match = options.match,
			that = this,
			bounds,
			res;

		function filter(hit) {
			if (hit && match && !match(hit))
				hit = null;
			if (hit && options.all)
				options.all.push(hit);
			return hit;
		}

		function checkPoint(type, part) {
			var pt = part ? bounds['get' + part]() : that.getPosition();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1) {
				return new HitResult(type, that, {
					name: part ? Base.hyphenate(part) : type,
					point: pt
				});
			}
		}

		var checkPosition = options.position,
			checkCenter = options.center,
			checkBounds = options.bounds;
		if (checkSelf && this._parent
				&& (checkPosition || checkCenter || checkBounds)) {
			if (checkCenter || checkBounds) {
				bounds = this.getInternalBounds();
			}
			res = checkPosition && checkPoint('position') ||
					checkCenter && checkPoint('center', 'Center');
			if (!res && checkBounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++) {
					res = checkPoint('bounds', points[i]);
				}
			}
			res = filter(res);
		}

		if (!res) {
			res = this._hitTestChildren(point, options, viewMatrix)
				|| checkSelf
					&& filter(this._hitTestSelf(point, options, viewMatrix,
						this.getStrokeScaling() ? null
							: viewMatrix._shiftless().invert()))
				|| null;
		}
		if (res && res.point) {
			res.point = matrix.transform(res.point);
		}
		return res;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
			return true;
		} else if (type === 'function') {
			return name(this);
		} else if (name === 'match') {
			return compare(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (name === 'class') {
				if (typeof compare === 'function')
					return this instanceof compare;
				value = this._class;
			}
			if (typeof compare === 'function') {
				return !!compare(value);
			} else if (compare) {
				if (compare.test) {
					return compare.test(value);
				} else if (Base.isPlainObject(compare)) {
					return matchObject(compare, value);
				}
			}
			return Base.equals(value, compare);
		}
	},

	getItems: function(options) {
		return Item._getItems(this, options, this._matrix);
	},

	getItem: function(options) {
		return Item._getItems(this, options, this._matrix, null, true)[0]
				|| null;
	},

	statics: {
		_getItems: function _getItems(item, options, matrix, param, firstOnly) {
			if (!param) {
				var obj = typeof options === 'object' && options,
					overlapping = obj && obj.overlapping,
					inside = obj && obj.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					recursive: obj && obj.recursive !== false,
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (obj) {
					options = Base.filter({}, options, {
						recursive: true, inside: true, overlapping: true
					});
				}
			}
			var children = item._children,
				items = param.items,
				rect = param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.appended(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(rect.contains(bounds)
							|| param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(options)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				if (param.recursive !== false) {
					_getItems(child, options, childMatrix, param, firstOnly);
				}
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this ? this.addChild(res) : res;
	},

	addChild: function(item) {
		return this.insertChild(undefined, item);
	},

	insertChild: function(index, item) {
		var res = item ? this.insertChildren(index, [item]) : null;
		return res && res[0];
	},

	addChildren: function(items) {
		return this.insertChildren(this._children.length, items);
	},

	insertChildren: function(index, items) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Base.slice(items);
			var inserted = {};
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i],
					id = item && item._id;
				if (!item || inserted[id]) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
					inserted[id] = true;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i],
					name = item._name;
				item._parent = this;
				item._setProject(project, true);
				if (name)
					item.setName(name);
				if (notifySelf)
					item._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertItem: '#insertChild',

	_insertAt: function(item, offset) {
		var owner = item && item._getOwner(),
			res = item !== this && owner ? this : null;
		if (res) {
			res._remove(false, true);
			owner._insertItem(item._index + offset, res);
		}
		return res;
	},

	insertAbove: function(item) {
		return this._insertAt(item, 1);
	},

	insertBelow: function(item) {
		return this._insertAt(item, 0);
	},

	sendToBack: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(0, this) : null;
	},

	bringToFront: function() {
		var owner = this._getOwner();
		return owner ? owner._insertItem(undefined, this) : null;
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	addTo: function(owner) {
		return owner._insertItem(undefined, this);
	},

	copyTo: function(owner) {
		return this.clone(false).addTo(owner);
	},

	reduce: function(options) {
		var children = this._children;
		if (children && children.length === 1) {
			var child = children[0].reduce(options);
			if (this._parent) {
				child.insertAbove(this);
				this.remove();
			} else {
				child.remove();
			}
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var owner = this._getOwner();
		if (owner) {
			var children = owner._children,
				namedChildren = owner._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[0];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var owner = this._getOwner(),
			project = this._project,
			index = this._index;
		if (this._style)
			this._style._dispose();
		if (owner) {
			if (this._name)
				this._removeNamed();
			if (index != null) {
				if (project._activeLayer === this)
					project._activeLayer = this.getNextSibling()
							|| this.getPreviousSibling();
				Base.splice(owner._children, null, index, 1);
			}
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent)
				owner._changed(11, this);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(start, end) {
		if (!this._children)
			return null;
		start = start || 0;
		end = Base.pick(end, this._children.length);
		var removed = Base.splice(this._children, null, start, end - start);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function(recursively) {
		var children = this._children;
		var numChildren = children ? children.length : 0;
		if (recursively) {
			for (var i = 0; i < numChildren; i++) {
				if (!children[i].isEmpty(recursively)) {
					return false;
				}
			}
			return true;
		}
		return !numChildren;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent === item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var value = (rotate ? Base : Point).read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getPosition(true)));
	};
}, {
	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	transform: function(matrix, _applyMatrix, _applyRecursively,
			_setApplyMatrix) {
		var _matrix = this._matrix,
			transformMatrix = matrix && !matrix.isIdentity(),
			applyMatrix = (_applyMatrix || this._applyMatrix)
					&& ((!_matrix.isIdentity() || transformMatrix)
						|| _applyMatrix && _applyRecursively && this._children);
		if (!transformMatrix && !applyMatrix)
			return this;
		if (transformMatrix) {
			if (!matrix.isInvertible() && _matrix.isInvertible())
				_matrix._backup = _matrix.getValues();
			_matrix.prepend(matrix, true);
			var style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (fillColor)
				fillColor.transform(matrix);
			if (strokeColor)
				strokeColor.transform(matrix);
		}
		if (applyMatrix && (applyMatrix = this._transformContent(_matrix,
				_applyRecursively, _setApplyMatrix))) {
			var pivot = this._pivot;
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		if (transformMatrix || applyMatrix) {
			this._changed(25);
		}
		var decomp = transformMatrix && bounds && matrix.decompose();
		if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var cache = bounds[key];
				if (cache.nonscaling) {
					delete bounds[key];
				} else if (applyMatrix || !cache.internal) {
					var rect = cache.rect;
					matrix._transformBounds(rect, rect);
				}
			}
			this._bounds = bounds;
			var cached = bounds[this._getBoundsCacheKey(
				this._boundsOptions || {})];
			if (cached) {
				this._position = this._getPositionFromBounds(cached.rect);
			}
		} else if (transformMatrix && position && this._pivot) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true, applyRecursively,
						setApplyMatrix);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	}
}), {

	_setStyles: function(ctx, param, viewMatrix) {
		var style = this._style,
			matrix = this._matrix;
		if (style.hasFill()) {
			ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);
		}
		if (style.hasStroke()) {
			ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);
			ctx.lineWidth = style.getStrokeWidth();
			var strokeJoin = style.getStrokeJoin(),
				strokeCap = style.getStrokeCap(),
				miterLimit = style.getMiterLimit();
			if (strokeJoin)
				ctx.lineJoin = strokeJoin;
			if (strokeCap)
				ctx.lineCap = strokeCap;
			if (miterLimit)
				ctx.miterLimit = miterLimit;
			if (paper.support.nativeDash) {
				var dashArray = style.getDashArray(),
					dashOffset = style.getDashOffset();
				if (dashArray && dashArray.length) {
					if ('setLineDash' in ctx) {
						ctx.setLineDash(dashArray);
						ctx.lineDashOffset = dashOffset;
					} else {
						ctx.mozDash = dashArray;
						ctx.mozDashOffset = dashOffset;
					}
				}
			}
		}
		if (style.hasShadow()) {
			var pixelRatio = param.pixelRatio || 1,
				mx = viewMatrix._shiftless().prepend(
					new Matrix().scale(pixelRatio, pixelRatio)),
				blur = mx.transform(new Point(style.getShadowBlur(), 0)),
				offset = mx.transform(this.getShadowOffset());
			ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);
			ctx.shadowBlur = blur.getLength();
			ctx.shadowOffsetX = offset.x;
			ctx.shadowOffsetY = offset.y;
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].appended(matrix);
		if (!globalMatrix.isInvertible())
			return;

		viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)
				: globalMatrix;

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(viewMatrix);
			if (!bounds.width || !bounds.height) {
				matrices.pop();
				return;
			}
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.appended(matrix)
				: this._canScaleStroke && !this.getStrokeScaling(true)
					&& viewMatrix,
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform) {
			(direct ? matrix : viewMatrix).applyToContext(ctx);
		}
		if (clip) {
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, viewMatrix, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish) {
			ctx.clip(this.getFillRule());
		}
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {
		var selection = this._selection,
			itemSelected = selection & 1,
			boundsSelected = selection & 2
					|| itemSelected && this._selectBounds,
			positionSelected = selection & 4;
		if (!this._drawSelected)
			itemSelected = false;
		if ((itemSelected || boundsSelected || positionSelected)
				&& this._isUpdated(updateVersion)) {
			var layer,
				color = this.getSelectedColor(true) || (layer = this.getLayer())
					&& layer.getSelectedColor(true),
				mx = matrix.appended(this.getGlobalMatrix(true)),
				half = size / 2;
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (itemSelected)
				this._drawSelected(ctx, mx, selectionItems);
			if (positionSelected) {
				var pos = this.getPosition(true),
					parent = this._parent,
					point = parent ? parent.localToGlobal(pos) : pos,
					x = point.x,
					y = point.y;
				ctx.beginPath();
				ctx.arc(x, y, half, 0, Math.PI * 2, true);
				ctx.stroke();
				var deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],
					start = half,
					end = size + 1;
				for (var i = 0; i < 4; i++) {
					var delta = deltas[i],
						dx = delta[0],
						dy = delta[1];
					ctx.moveTo(x + dx * start, y + dy * start);
					ctx.lineTo(x + dx * end, y + dy * end);
					ctx.stroke();
				}
			}
			if (boundsSelected) {
				var coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++) {
					ctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				}
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++) {
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
				}
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(key) {
	this['removeOn' + Base.capitalize(key)] = function() {
		var hash = {};
		hash[key] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}), {
	tween: function(from, to, options) {
		if (!options) {
			options = to;
			to = from;
			from = null;
			if (!options) {
				options = to;
				to = null;
			}
		}
		var easing = options && options.easing,
			start = options && options.start,
			duration = options != null && (
				typeof options === 'number' ? options : options.duration
			),
			tween = new Tween(this, from, to, duration, easing, start);
		function onFrame(event) {
			tween._handleFrame(event.time * 1000);
			if (!tween.running) {
				this.off('frame', onFrame);
			}
		}
		if (duration) {
			this.on('frame', onFrame);
		}
		return tween;
	},

	tweenTo: function(to, options) {
		return this.tween(null, to, options);
	},

	tweenFrom: function(from, options) {
		return this.tween(from, null, options);
	}
});

var Group = Item.extend({
	_class: 'Group',
	_selectBounds: false,
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 2050) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++) {
				if (children[i]._clipMask) {
					clipItem = children[i];
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_getBounds: function _getBounds(matrix, options) {
		var clipItem = this._getClipItem();
		return clipItem
			? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),
				Base.set({}, options, { stroke: false }))
			: _getBounds.base.call(this, matrix, options);
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		var clipItem = this._getClipItem();
		return (!clipItem || clipItem.contains(point))
				&& _hitTestChildren.base.call(this, point, options, viewMatrix,
					clipItem);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem();
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			ctx.beginPath();
			param.dontStart = param.dontFinish = true;
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var item = children[i];
			if (item !== clipItem)
				item.draw(ctx, param);
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer() {
		Group.apply(this, arguments);
	},

	_getOwner: function() {
		return this._parent || this._index != null && this._project;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_hitTestSelf: function() {
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_canScaleStroke: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props, point) {
		this._initialize(props, point);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	copyContent: function(source) {
		this.setType(source._type);
		this.setSize(source._size);
		this.setRadius(source._radius);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				this._radius.set(Size.min(this._radius, size.divide(2)));
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius._set(width / 2, height / 2);
			}
			this._size._set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size._set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size);
				} else if (type === 'ellipse') {
					this._size._set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.copyAttributes(this);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		if (insert === undefined || insert)
			path.insertAbove(this);
		return path;
	},

	toShape: '#clone',

	_asPathItem: function() {
		return this.toPath(false);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx, param, viewMatrix);
			if (hasFill) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0),
			style = this._style,
			strokeWidth = options.stroke && style.hasStroke()
					&& style.getStrokeWidth();
		if (matrix)
			rect = matrix._transformBounds(rect);
		return strokeWidth
				? rect.expand(Path._getStrokePadding(strokeWidth,
					this._getStrokeMatrix(matrix, options)))
				: rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var q = 1; q <= 4; q++) {
				var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(
							expand ? corner.add(dir.multiply(expand)) : corner,
							center);
				if (rect.contains(point))
					return { point: center, quadrant: q };
			}
		}
	}

	function isOnEllipseStroke(point, radius, padding, quadrant) {
		var vector = point.divide(radius);
		return (!quadrant || vector.isInQuadrant(quadrant)) &&
				vector.subtract(vector.normalize()).multiply(radius)
					.divide(padding).length <= 1;
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center.point).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,
				strokeMatrix) {
			var hit = false,
				style = this._style,
				hitStroke = options.stroke && style.hasStroke(),
				hitFill = options.fill && style.hasFill();
			if (hitStroke || hitFill) {
				var type = this._type,
					radius = this._radius,
					strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,
					strokePadding = options._tolerancePadding.add(
						Path._getStrokePadding(strokeRadius,
							!style.getStrokeScaling() && strokeMatrix));
				if (type === 'rectangle') {
					var padding = strokePadding.multiply(2),
						center = getCornerCenter(this, point, padding);
					if (center) {
						hit = isOnEllipseStroke(point.subtract(center.point),
								radius, strokePadding, center.quadrant);
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(padding),
							inner = rect.expand(padding.negate());
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					hit = isOnEllipseStroke(point, radius, strokePadding);
				}
			}
			return hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args), point);
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item;
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
}, {
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: false, handle: false },
	_serializeFields: {
		crossOrigin: null,
		source: null
	},
	_prioritize: ['crossOrigin'],
	_smoothing: true,
	beans: true,

	initialize: function Raster(source, position) {
		if (!this._initialize(source,
				position !== undefined && Point.read(arguments))) {
			var image,
				type = typeof source,
				object = type === 'string'
					? document.getElementById(source)
					: type  === 'object'
						? source
						: null;
			if (object && object !== Item.NO_INSERT) {
				if (object.getContent || object.naturalHeight != null) {
					image = object;
				} else if (object) {
					var size = Size.read(arguments);
					if (!size.isZero()) {
						image = CanvasProvider.getCanvas(size);
					}
				}
			}
			if (image) {
				this.setImage(image);
			} else {
				this.setSource(source);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	copyContent: function(source) {
		var image = source._image,
			canvas = source._canvas;
		if (image) {
			this._setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(source._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			this._setImage(copyCanvas);
		}
		this._crossOrigin = source._crossOrigin;
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this._setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	getLoaded: function() {
		return this._loaded;
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		var that = this;

		function emit(event) {
			var view = that.getView(),
				type = event && event.type || 'load';
			if (view && that.responds(type)) {
				paper = view._scope;
				that.emit(type, new Event(event));
			}
		}

		this._setImage(image);
		if (this._loaded) {
			setTimeout(emit, 0);
		} else if (image) {
			DomEvent.add(image, {
				load: function(event) {
					that._setImage(image);
					emit(event);
				},
				error: emit
			});
		}
	},

	_setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = !!(image && image.src && image.complete);
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(1033);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(_change) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (_change) {
			this._image = null;
			this._changed(1025);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		var image = this._image;
		return image && image.src || this.toDataURL();
	},

	setSource: function(src) {
		var image = new self.Image(),
			crossOrigin = this._crossOrigin;
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (src)
			image.src = src;
		this.setImage(image);
	},

	getCrossOrigin: function() {
		var image = this._image;
		return image && image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		var image = this._image;
		if (image)
			image.crossOrigin = crossOrigin;
	},

	getSmoothing: function() {
		return this._smoothing;
	},

	setSmoothing: function(smoothing) {
		this._smoothing = smoothing;
		this._changed(257);
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster._setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.prepend(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var image = this._image,
			src = image && image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (typeof object === 'object') {
			if ('width' in object) {
				bounds = new Rectangle(object);
			} else if ('x' in object) {
				bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
			}
		}
		if (!bounds)
			return null;
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	clear: function() {
		var size = this._size;
		this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(matrix, options) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx, param, viewMatrix) {
		var element = this.getElement();
		if (element && element.width > 0 && element.height > 0) {
			ctx.globalAlpha = this._opacity;

			this._setStyles(ctx, param, viewMatrix);

			DomElement.setPrefixed(
				ctx, 'imageSmoothingEnabled', this._smoothing
			);

			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var SymbolItem = Item.extend({
	_class: 'SymbolItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsOptions: { stroke: true },
	_serializeFields: {
		symbol: null
	},

	initialize: function SymbolItem(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setDefinition(arg0 instanceof SymbolDefinition ?
					arg0 : new SymbolDefinition(arg0));
	},

	_equals: function(item) {
		return this._definition === item._definition;
	},

	copyContent: function(source) {
		this.setDefinition(source._definition);
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(definition) {
		this._definition = definition;
		this._changed(9);
	},

	getSymbol: '#getDefinition',
	setSymbol: '#setDefinition',

	isEmpty: function() {
		return this._definition._item.isEmpty();
	},

	_getBounds: function(matrix, options) {
		var item = this._definition._item;
		return item._getCachedBounds(item._matrix.prepended(matrix), options);
	},

	_hitTestSelf: function(point, options, viewMatrix) {
		var res = this._definition._item._hitTest(point, options, viewMatrix);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this._definition._item.draw(ctx, param);
	}

});

var SymbolDefinition = Base.extend({
	_class: 'SymbolDefinition',

	initialize: function SymbolDefinition(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		if (item)
			this.setItem(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._item],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8)
			Item._clearBoundsCache(this);
		if (flags & 1)
			this.project._changed(flags);
	},

	getItem: function() {
		return this._item;
	},

	setItem: function(item, _dontCenter) {
		if (item._symbol)
			item = item.clone();
		if (this._item)
			this._item._symbol = null;
		this._item = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._symbol = this;
		this._changed(9);
	},

	getDefinition: '#getItem',
	setDefinition: '#setItem',

	place: function(position) {
		return new SymbolItem(this, position);
	},

	clone: function() {
		return new SymbolDefinition(this._item.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this._item.equals(symbol._item)
				|| false;
	}
});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values)
			this.inject(values);
	},

	statics: {
		getOptions: function(args) {
			var options = args && Base.read(args);
			return Base.set({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				position: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,
	_selection: 0,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut, selection;
		if (count > 0) {
			if (arg0 == null || typeof arg0 === 'object') {
				if (count === 1 && arg0 && 'point' in arg0) {
					point = arg0.point;
					handleIn = arg0.handleIn;
					handleOut = arg0.handleOut;
					selection = arg0.selection;
				} else {
					point = arg0;
					handleIn = arg1;
					handleOut = arg2;
					selection = arg3;
				}
			} else {
				point = [ arg0, arg1 ];
				handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
				handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
			}
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
		if (selection)
			this.setSelection(selection);
	},

	_serialize: function(options, dictionary) {
		var point = this._point,
			selection = this._selection,
			obj = selection || this.hasHandles()
					? [point, this._handleIn, this._handleOut]
					: point;
		if (selection)
			obj.push(selection);
		return Base.serialize(obj, options, true, dictionary);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(41);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		this._point.set(Point.read(arguments));
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		this._handleIn.set(Point.read(arguments));
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		this._handleOut.set(Point.read(arguments));
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	isSmooth: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut;
		return !handleIn.isZero() && !handleOut.isZero()
				&& handleIn.isCollinear(handleOut);
	},

	clearHandles: function() {
		this._handleIn._set(0, 0);
		this._handleOut._set(0, 0);
	},

	getSelection: function() {
		return this._selection;
	},

	setSelection: function(selection) {
		var oldSelection = this._selection,
			path = this._path;
		this._selection = selection = selection || 0;
		if (path && selection !== oldSelection) {
			path._updateSelection(this, oldSelection, selection);
			path._changed(257);
		}
	},

	_changeSelection: function(flag, selected) {
		var selection = this._selection;
		this.setSelection(selected ? selection | flag : selection & ~flag);
	},

	isSelected: function() {
		return !!(this._selection & 7);
	},

	setSelected: function(selected) {
		this._changeSelection(7, selected);
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	smooth: function(options, _first, _last) {
		var opts = options || {},
			type = opts.type,
			factor = opts.factor,
			prev = this.getPrevious(),
			next = this.getNext(),
			p0 = (prev || this)._point,
			p1 = this._point,
			p2 = (next || this)._point,
			d1 = p0.getDistance(p1),
			d2 = p1.getDistance(p2);
		if (!type || type === 'catmull-rom') {
			var a = factor === undefined ? 0.5 : factor,
				d1_a = Math.pow(d1, a),
				d1_2a = d1_a * d1_a,
				d2_a = Math.pow(d2, a),
				d2_2a = d2_a * d2_a;
			if (!_first && prev) {
				var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,
					N = 3 * d2_a * (d2_a + d1_a);
				this.setHandleIn(N !== 0
					? new Point(
						(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,
						(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)
					: new Point());
			}
			if (!_last && next) {
				var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,
					N = 3 * d1_a * (d1_a + d2_a);
				this.setHandleOut(N !== 0
					? new Point(
						(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,
						(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)
					: new Point());
			}
		} else if (type === 'geometric') {
			if (prev && next) {
				var vector = p0.subtract(p2),
					t = factor === undefined ? 0.4 : factor,
					k = t * d1 / (d1 + d2);
				if (!_first)
					this.setHandleIn(vector.multiply(k));
				if (!_last)
					this.setHandleOut(vector.multiply(k - t));
			}
		} else {
			throw new Error('Smoothing method \'' + type + '\' not supported.');
		}
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return !this._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			tmp = handleIn.clone();
		handleIn.set(handleOut);
		handleOut.set(tmp);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(from, to, factor) {
		var u = 1 - factor,
			v = factor,
			point1 = from._point,
			point2 = to._point,
			handleIn1 = from._handleIn,
			handleIn2 = to._handleIn,
			handleOut2 = to._handleOut,
			handleOut1 = from._handleOut;
		this._point._set(
				u * point1._x + v * point2._x,
				u * point1._y + v * point2._y, true);
		this._handleIn._set(
				u * handleIn1._x + v * handleIn2._x,
				u * handleIn1._y + v * handleIn2._y, true);
		this._handleOut._set(
				u * handleOut1._x + v * handleOut2._x,
				u * handleOut1._y + v * handleOut2._y, true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y,
			selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	_set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		var isZero = Numerical.isZero;
		return isZero(this._x) && isZero(this._y);
	},

	isSelected: function() {
		return !!(this._owner._selection & this._getSelection());
	},

	setSelected: function(selected) {
		this._owner._changeSelection(this._getSelection(), selected);
	},

	_getSelection: function() {
		var owner = this._owner;
		return this === owner._point ? 1
			: this === owner._handleIn ? 2
			: this === owner._handleOut ? 4
			: 0;
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	beans: true,

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (!count) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true, dictionary);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	classify: function() {
		return Curve.classify(this.getValues());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		this._segment1._point.set(Point.read(arguments));
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		this._segment2._point.set(Point.read(arguments));
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		this._segment1._handleOut.set(Point.read(arguments));
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		this._segment2._handleIn.set(Point.read(arguments));
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return !this._segment1._index;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	}
}, {
	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	divideAt: function(location) {
		return this.divideAtTime(location && location.curve === this
				? location.time : this.getTimeAt(location));
	},

	divideAtTime: function(time, _setHandles) {
		var tMin = 1e-8,
			tMax = 1 - tMin,
			res = null;
		if (time >= tMin && time <= tMax) {
			var parts = Curve.subdivide(this.getValues(), time),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				seg1 = this._segment1,
				seg2 = this._segment2,
				path = this._path;
			if (setHandles) {
				seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);
				seg2._handleIn._set(right[4] - right[6],right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(seg1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				this._changed();
				res = new Curve(segment, seg2);
			}
		}
		return res;
	},

	splitAt: function(location) {
		var path = this._path;
		return path ? path.splitAt(location) : null;
	},

	splitAtTime: function(time) {
		return this.splitAt(this.getLocationAtTime(time));
	},

	divide: function(offset, isTime) {
		return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	split: function(offset, isTime) {
		return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset
				: this.getTimeAt(offset));
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut._set(0, 0);
		this._segment2._handleIn._set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix, straight) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			x1 = p1.x, y1 = p1.y,
			x2 = p2.x, y2 = p2.y,
			values = straight
				? [ x1, y1, x1, y1, x2, y2, x2, y2 ]
				: [
					x1, y1,
					x1 + h1._x, y1 + h1._y,
					x2 + h2._x, y2 + h2._y,
					x2, y2
				];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			x4 = u * x0 + t * x1, y4 = u * y0 + t * y1,
			x5 = u * x1 + t * x2, y5 = u * y1 + t * y2,
			x6 = u * x2 + t * x3, y6 = u * y2 + t * y3,
			x7 = u * x4 + t * x5, y7 = u * y4 + t * y5,
			x8 = u * x5 + t * x6, y8 = u * y5 + t * y6,
			x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;
		return [
			[x0, y0, x4, y4, x7, y7, x9, y9],
			[x9, y9, x8, y8, x6, y6, x3, y3]
		];
	},

	getMonoCurves: function(v, dir) {
		var curves = [],
			io = dir ? 0 : 1,
			o0 = v[io + 0],
			o1 = v[io + 2],
			o2 = v[io + 4],
			o3 = v[io + 6];
		if ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)
				|| Curve.isStraight(v)) {
			curves.push(v);
		} else {
			var a = 3 * (o1 - o2) - o0 + o3,
				b = 2 * (o0 + o2) - 4 * o1,
				c = o1 - o0,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [],
				n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
			if (!n) {
				curves.push(v);
			} else {
				roots.sort();
				var t = roots[0],
					parts = Curve.subdivide(v, t);
				curves.push(parts[0]);
				if (n > 1) {
					t = (roots[1] - t) / (1 - t);
					parts = Curve.subdivide(parts[1], t);
					curves.push(parts[0]);
				}
				curves.push(parts[1]);
			}
		}
		return curves;
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var v0 = v[coord],
			v1 = v[coord + 2],
			v2 = v[coord + 4],
			v3 = v[coord + 6],
			res = 0;
		if (  !(v0 < val && v3 < val && v1 < val && v2 < val ||
				v0 > val && v3 > val && v1 > val && v2 > val)) {
			var c = 3 * (v1 - v0),
				b = 3 * (v2 - v1) - c,
				a = v3 - v0 - c - b;
			res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);
		}
		return res;
	},

	getTimeOf: function(v, point) {
		var p0 = new Point(v[0], v[1]),
			p3 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			geomEpsilon = 1e-7,
			t = point.isClose(p0, epsilon) ? 0
			  : point.isClose(p3, epsilon) ? 1
			  : null;
		if (t === null) {
			var coords = [point.x, point.y],
				roots = [];
			for (var c = 0; c < 2; c++) {
				var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
				for (var i = 0; i < count; i++) {
					var u = roots[i];
					if (point.isClose(Curve.getPoint(v, u), geomEpsilon))
						return u;
				}
			}
		}
		return point.isClose(p0, geomEpsilon) ? 0
			 : point.isClose(p3, geomEpsilon) ? 1
			 : null;
	},

	getNearestTime: function(v, point) {
		if (Curve.isStraight(v)) {
			var x0 = v[0], y0 = v[1],
				x3 = v[6], y3 = v[7],
				vx = x3 - x0, vy = y3 - y0,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getTimeOf(v,
					new Point(x0 + u * vx, y0 + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 1e-8) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	isFlatEnough: function(v, flatness) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			ux = 3 * x1 - 2 * x0 - x3,
			uy = 3 * y1 - 2 * y0 - y3,
			vx = 3 * x2 - 2 * x3 - x0,
			vy = 3 * y2 - 2 * y3 - y0;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				<= 16 * flatness * flatness;
	},

	getArea: function(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7];
		return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)
				+ y1 * (x0 - x2) - x1 * (y0 - y2)
				+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}

		padding /= 2;
		var minPad = min[coord] - padding,
			maxPad = max[coord] + padding;
		if (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||
				v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {
			if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {
				add(v0, padding);
				add(v3, padding);
			} else {
				var a = 3 * (v1 - v2) - v0 + v3,
					b = 2 * (v0 + v2) - 4 * v1,
					c = v1 - v0,
					count = Numerical.solveQuadratic(a, b, c, roots),
					tMin = 1e-8,
					tMax = 1 - tMin;
				add(v3, 0);
				for (var i = 0; i < count; i++) {
					var t = roots[i],
						u = 1 - t;
					if (tMin <= t && t <= tMax)
						add(u * u * u * v0
							+ 3 * u * u * t * v1
							+ 3 * u * t * t * v2
							+ t * t * t * v3,
							padding);
				}
			}
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false, this._path);
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(p1, h1, h2, p2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else {
			var v = p2.subtract(p1);
			if (v.isZero()) {
				return false;
			} else if (v.isCollinear(h1) && v.isCollinear(h2)) {
				var l = new Line(p1, p2),
					epsilon = 1e-7;
				if (l.getDistance(p1.add(h1)) < epsilon &&
					l.getDistance(p2.add(h2)) < epsilon) {
					var div = v.dot(v),
						s1 = v.dot(h1) / div,
						s2 = v.dot(h2) / div;
					return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;
				}
			}
		}
		return false;
	},

	isLinear: function(p1, h1, h2, p2) {
		var third = p2.subtract(p1).divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function(epsilon) {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,
				epsilon);
	};

	this.statics[name] = function(v, epsilon) {
		var x0 = v[0], y0 = v[1],
			x3 = v[6], y3 = v[7];
		return test(
				new Point(x0, y0),
				new Point(v[2] - x0, v[3] - y0),
				new Point(v[4] - x3, v[5] - y3),
				new Point(x3, y3), epsilon);
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	hasLength: function(epsilon) {
		return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())
				&& this.getLength() > (epsilon || 0);
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)
				< 1e-8;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)
				< 1e-8;
	}
}), {
	beans: false,

	getLocationAt: function(offset, _isTime) {
		return this.getLocationAtTime(
				_isTime ? offset : this.getTimeAt(offset));
	},

	getLocationAtTime: function(t) {
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getTimeAt: function(offset, start) {
		return Curve.getTimeAt(this.getValues(), offset, start);
	},

	getParameterAt: '#getTimeAt',

	getTimesWithTangent: function () {
		var tangent = Point.read(arguments);
		return tangent.isZero()
				? []
				: Curve.getTimesWithTangent(this.getValues(), tangent);
	},

	getOffsetAtTime: function(t) {
		return this.getPartLength(0, t);
	},

	getLocationOf: function() {
		return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getTimeOf: function() {
		return Curve.getTimeOf(this.getValues(), Point.read(arguments));
	},

	getParameterOf: '#getTimeOf',

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestTime(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
		function(name) {
			this[name + 'At'] = function(location, _isTime) {
				var values = this.getValues();
				return Curve[name](values, _isTime ? location
						: Curve.getTimeAt(values, location));
			};

			this[name + 'AtTime'] = function(time) {
				return Curve[name](this.getValues(), time);
			};
		}, {
			statics: {
				_evaluateMethods: methods
			}
		}
	);
},
new function() {

	function getLengthIntegrand(v) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],

			ax = 9 * (x1 - x2) + 3 * (x3 - x0),
			bx = 6 * (x0 + x2) - 12 * x1,
			cx = 3 * (x1 - x0),

			ay = 9 * (y1 - y2) + 3 * (y3 - y0),
			by = 6 * (y0 + y2) - 12 * y1,
			cy = 3 * (y1 - y0);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			isZero = Numerical.isZero;
		if (isZero(x1 - x0) && isZero(y1 - y0)) {
			x1 = x0;
			y1 = y0;
		}
		if (isZero(x2 - x3) && isZero(y2 - y3)) {
			x2 = x3;
			y2 = y3;
		}
		var cx = 3 * (x1 - x0),
			bx = 3 * (x2 - x1) - cx,
			ax = x3 - x0 - cx - bx,
			cy = 3 * (y1 - y0),
			by = 3 * (y2 - y1) - cy,
			ay = y3 - y0 - cy - by,
			x, y;
		if (type === 0) {
			x = t === 0 ? x0 : t === 1 ? x3
					: ((ax * t + bx) * t + cx) * t + x0;
			y = t === 0 ? y0 : t === 1 ? y3
					: ((ay * t + by) * t + cy) * t + y0;
		} else {
			var tMin = 1e-8,
				tMax = 1 - tMin;
			if (t < tMin) {
				x = cx;
				y = cy;
			} else if (t > tMax) {
				x = 3 * (x3 - x2);
				y = 3 * (y3 - y2);
			} else {
				x = (3 * ax * t + 2 * bx) * t + cx;
				y = (3 * ay * t + 2 * by) * t + cy;
			}
			if (normalized) {
				if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
					x = x2 - x1;
					y = y2 - y1;
				}
				var len = Math.sqrt(x * x + y * y);
				if (len) {
					x /= len;
					y /= len;
				}
			}
			if (type === 3) {
				var x2 = 6 * ax * t + 2 * bx,
					y2 = 6 * ay * t + 2 * by,
					d = Math.pow(x * x + y * y, 3 / 2);
				x = d !== 0 ? (x * y2 - y * x2) / d : 0;
				y = 0;
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		classify: function(v) {

			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,
				a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,
				a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,
				d3 = 3 * a3,
				d2 = d3 - a2,
				d1 = d2 - a2 + a1,
				l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),
				s = l !== 0 ? 1 / l : 0,
				isZero = Numerical.isZero,
				serpentine = 'serpentine';
			d1 *= s;
			d2 *= s;
			d3 *= s;

			function type(type, t1, t2) {
				var hasRoots = t1 !== undefined,
					t1Ok = hasRoots && t1 > 0 && t1 < 1,
					t2Ok = hasRoots && t2 > 0 && t2 < 1;
				if (hasRoots && (!(t1Ok || t2Ok)
						|| type === 'loop' && !(t1Ok && t2Ok))) {
					type = 'arch';
					t1Ok = t2Ok = false;
				}
				return {
					type: type,
					roots: t1Ok || t2Ok
							? t1Ok && t2Ok
								? t1 < t2 ? [t1, t2] : [t2, t1]
								: [t1Ok ? t1 : t2]
							: null
				};
			}

			if (isZero(d1)) {
				return isZero(d2)
						? type(isZero(d3) ? 'line' : 'quadratic')
						: type(serpentine, d3 / (3 * d2));
			}
			var d = 3 * d2 * d2 - 4 * d1 * d3;
			if (isZero(d)) {
				return type('cusp', d2 / (2 * d1));
			}
			var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),
				f2 = 2 * d1;
			return type(d > 0 ? serpentine : 'loop',
					(d2 + f1) / f2,
					(d2 - f1) / f2);
		},

		getLength: function(v, a, b, ds) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (Curve.isStraight(v)) {
				var c = v;
				if (b < 1) {
					c = Curve.subdivide(c, b)[0];
					a /= b;
				}
				if (a > 0) {
					c = Curve.subdivide(c, a)[1];
				}
				var dx = c[6] - c[0],
					dy = c[7] - c[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			return Numerical.integrate(ds || getLengthIntegrand(v), a, b,
					getIterations(a, b));
		},

		getTimeAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0;
			if (offset === 0)
				return start;
			var abs = Math.abs,
				epsilon = 1e-12,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Curve.getLength(v, a, b, ds),
				diff = abs(offset) - rangeLength;
			if (abs(diff) < epsilon) {
				return forward ? b : a;
			} else if (diff > epsilon) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		},

		getPeaks: function(v) {
			var x0 = v[0], y0 = v[1],
				x1 = v[2], y1 = v[3],
				x2 = v[4], y2 = v[5],
				x3 = v[6], y3 = v[7],
				ax =     -x0 + 3 * x1 - 3 * x2 + x3,
				bx =  3 * x0 - 6 * x1 + 3 * x2,
				cx = -3 * x0 + 3 * x1,
				ay =     -y0 + 3 * y1 - 3 * y2 + y3,
				by =  3 * y0 - 6 * y1 + 3 * y2,
				cy = -3 * y0 + 3 * y1,
				tMin = 1e-8,
				tMax = 1 - tMin,
				roots = [];
			Numerical.solveCubic(
					9 * (ax * ax + ay * ay),
					9 * (ax * bx + by * ay),
					2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),
					(cx * bx + by * cy),
					roots, tMin, tMax);
			return roots.sort();
		}
	}};
},
new function() {

	function addLocation(locations, include, c1, t1, c2, t2, overlap) {
		var excludeStart = !overlap && c1.getPrevious() === c2,
			excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&
			t1 <= (excludeEnd ? tMax : 1)) {
			if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&
				t2 <= (excludeStart ? tMax : 1)) {
				var loc1 = new CurveLocation(c1, t1, null, overlap),
					loc2 = new CurveLocation(c2, t2, null, overlap);
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc1)) {
					CurveLocation.insert(locations, loc1, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, include, flip,
			recursion, calls, tMin, tMax, uMin, uMax) {
		if (++calls >= 4096 || ++recursion >= 40)
			return calls;
		var fatLineEpsilon = 1e-9,
			q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if (d1 === 0 && d2 === 0
				&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0
			|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null
			|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return calls;
		var tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {
			var t = (tMinNew + tMaxNew) / 2,
				u = (uMin + uMax) / 2;
			addLocation(locations, include,
					flip ? c2 : c1, flip ? u : t,
					flip ? c1 : c2, flip ? t : u);
		} else {
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			if (tMaxClip - tMinClip > 0.8) {
				if (tMaxNew - tMinNew > uMax - uMin) {
					var parts = Curve.subdivide(v1, 0.5),
						t = (tMinNew + tMaxNew) / 2;
					calls = addCurveIntersections(
							v2, parts[0], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, t);
					calls = addCurveIntersections(
							v2, parts[1], c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, t, tMaxNew);
				} else {
					var parts = Curve.subdivide(v2, 0.5),
						u = (uMin + uMax) / 2;
					calls = addCurveIntersections(
							parts[0], v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, u, tMinNew, tMaxNew);
					calls = addCurveIntersections(
							parts[1], v1, c2, c1, locations, include, !flip,
							recursion, calls, u, uMax, tMinNew, tMaxNew);
				}
			} else {
				if (uMax - uMin >= fatLineEpsilon) {
					calls = addCurveIntersections(
							v2, v1, c2, c1, locations, include, !flip,
							recursion, calls, uMin, uMax, tMinNew, tMaxNew);
				} else {
					calls = addCurveIntersections(
							v1, v2, c1, c2, locations, include, flip,
							recursion, calls, tMinNew, tMaxNew, uMin, uMax);
				}
			}
		}
		return calls;
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= 0.5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function getCurveLineIntersections(v, px, py, vx, vy) {
		var isZero = Numerical.isZero;
		if (isZero(vx) && isZero(vy)) {
			var t = Curve.getTimeOf(v, new Point(px, py));
			return t === null ? [] : [t];
		}
		var angle = Math.atan2(-vy, vx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rv = [],
			roots = [];
		for (var i = 0; i < 8; i += 2) {
			var x = v[i] - px,
				y = v[i + 1] - py;
			rv.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		Curve.solveCubic(rv, 1, 0, roots, 0, 1);
		return roots;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, include,
			flip) {
		var x1 = v2[0], y1 = v2[1],
			x2 = v2[6], y2 = v2[7],
			roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);
		for (var i = 0, l = roots.length; i < l; i++) {
			var t1 = roots[i],
				p1 = Curve.getPoint(v1, t1),
				t2 = Curve.getTimeOf(v2, p1);
			if (t2 !== null) {
				addLocation(locations, include,
						flip ? c2 : c1, flip ? t2 : t1,
						flip ? c1 : c2, flip ? t1 : t2);
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, include) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, include,
					c1, Curve.getTimeOf(v1, pt),
					c2, Curve.getTimeOf(v2, pt));
		}
	}

	function getCurveIntersections(v1, v2, c1, c2, locations, include) {
		var epsilon = 1e-12,
			min = Math.min,
			max = Math.max;

		if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >
			min(v2[0], v2[2], v2[4], v2[6]) &&
			min(v1[0], v1[2], v1[4], v1[6]) - epsilon <
			max(v2[0], v2[2], v2[4], v2[6]) &&
			max(v1[1], v1[3], v1[5], v1[7]) + epsilon >
			min(v2[1], v2[3], v2[5], v2[7]) &&
			min(v1[1], v1[3], v1[5], v1[7]) - epsilon <
			max(v2[1], v2[3], v2[5], v2[7])) {
			var overlaps = getOverlaps(v1, v2);
			if (overlaps) {
				for (var i = 0; i < 2; i++) {
					var overlap = overlaps[i];
					addLocation(locations, include,
							c1, overlap[0],
							c2, overlap[1], true);
				}
			} else {
				var straight1 = Curve.isStraight(v1),
					straight2 = Curve.isStraight(v2),
					straight = straight1 && straight2,
					flip = straight1 && !straight2,
					before = locations.length;
				(straight
					? addLineIntersection
					: straight1 || straight2
						? addCurveLineIntersections
						: addCurveIntersections)(
							flip ? v2 : v1, flip ? v1 : v2,
							flip ? c2 : c1, flip ? c1 : c2,
							locations, include, flip,
							0, 0, 0, 1, 0, 1);
				if (!straight || locations.length === before) {
					for (var i = 0; i < 4; i++) {
						var t1 = i >> 1,
							t2 = i & 1,
							i1 = t1 * 6,
							i2 = t2 * 6,
							p1 = new Point(v1[i1], v1[i1 + 1]),
							p2 = new Point(v2[i2], v2[i2 + 1]);
						if (p1.isClose(p2, epsilon)) {
							addLocation(locations, include,
									c1, t1,
									c2, t2);
						}
					}
				}
			}
		}
		return locations;
	}

	function getLoopIntersection(v1, c1, locations, include) {
		var info = Curve.classify(v1);
		if (info.type === 'loop') {
			var roots = info.roots;
			addLocation(locations, include,
					c1, roots[0],
					c1, roots[1]);
		}
	  return locations;
	}

	function getIntersections(curves1, curves2, include, matrix1, matrix2,
			_returnFirst) {
		var self = !curves2;
		if (self)
			curves2 = curves1;
		var length1 = curves1.length,
			length2 = curves2.length,
			values2 = [],
			arrays = [],
			locations,
			current;
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = self ? values2[i] : curve1.getValues(matrix1),
				path1 = curve1.getPath();
			if (path1 !== current) {
				current = path1;
				locations = [];
				arrays.push(locations);
			}
			if (self) {
				getLoopIntersection(values1, curve1, locations, include);
			}
			for (var j = self ? i + 1 : 0; j < length2; j++) {
				if (_returnFirst && locations.length)
					return locations;
				getCurveIntersections(values1, values2[j], curve1, curves2[j],
						locations, include);
			}
		}
		locations = [];
		for (var i = 0, l = arrays.length; i < l; i++) {
			Base.push(locations, arrays[i]);
		}
		return locations;
	}

	function getOverlaps(v1, v2) {

		function getSquaredLineLength(v) {
			var x = v[6] - v[0],
				y = v[7] - v[1];
			return x * x + y * y;
		}

		var abs = Math.abs,
			getDistance = Line.getDistance,
			timeEpsilon = 1e-8,
			geomEpsilon = 1e-7,
			straight1 = Curve.isStraight(v1),
			straight2 = Curve.isStraight(v2),
			straightBoth = straight1 && straight2,
			flip = getSquaredLineLength(v1) < getSquaredLineLength(v2),
			l1 = flip ? v2 : v1,
			l2 = flip ? v1 : v2,
			px = l1[0], py = l1[1],
			vx = l1[6] - px, vy = l1[7] - py;
		if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&
			getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {
			if (!straightBoth &&
				getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&
				getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {
				straight1 = straight2 = straightBoth = true;
			}
		} else if (straightBoth) {
			return null;
		}
		if (straight1 ^ straight2) {
			return null;
		}

		var v = [v1, v2],
			pairs = [];
		for (var i = 0; i < 4 && pairs.length < 2; i++) {
			var i1 = i & 1,
				i2 = i1 ^ 1,
				t1 = i >> 1,
				t2 = Curve.getTimeOf(v[i1], new Point(
					v[i2][t1 ? 6 : 0],
					v[i2][t1 ? 7 : 1]));
			if (t2 != null) {
				var pair = i1 ? [t1, t2] : [t2, t1];
				if (!pairs.length ||
					abs(pair[0] - pairs[0][0]) > timeEpsilon &&
					abs(pair[1] - pairs[0][1]) > timeEpsilon) {
					pairs.push(pair);
				}
			}
			if (i > 2 && !pairs.length)
				break;
		}
		if (pairs.length !== 2) {
			pairs = null;
		} else if (!straightBoth) {
			var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
				o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
			if (abs(o2[2] - o1[2]) > geomEpsilon ||
				abs(o2[3] - o1[3]) > geomEpsilon ||
				abs(o2[4] - o1[4]) > geomEpsilon ||
				abs(o2[5] - o1[5]) > geomEpsilon)
				pairs = null;
		}
		return pairs;
	}

	function getTimesWithTangent(v, tangent) {
		var x0 = v[0], y0 = v[1],
			x1 = v[2], y1 = v[3],
			x2 = v[4], y2 = v[5],
			x3 = v[6], y3 = v[7],
			normalized = tangent.normalize(),
			tx = normalized.x,
			ty = normalized.y,
			ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,
			ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,
			bx = 6 * x2 - 12 * x1 + 6 * x0,
			by = 6 * y2 - 12 * y1 + 6 * y0,
			cx = 3 * x1 - 3 * x0,
			cy = 3 * y1 - 3 * y0,
			den = 2 * ax * ty - 2 * ay * tx,
			times = [];
		if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {
			var num = ax * cy - ay * cx,
				den = ax * by - ay * bx;
			if (den != 0) {
				var t = -num / den;
				if (t >= 0 && t <= 1) times.push(t);
			}
		} else {
			var delta = (bx * bx - 4 * ax * cx) * ty * ty +
				(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +
				(by * by - 4 * ay * cy) * tx * tx,
				k = bx * ty - by * tx;
			if (delta >= 0 && den != 0) {
				var d = Math.sqrt(delta),
					t0 = -(k + d) / den,
					t1 = (-k + d) / den;
				if (t0 >= 0 && t0 <= 1) times.push(t0);
				if (t1 >= 0 && t1 <= 1) times.push(t1);
			}
		}
		return times;
	}

	return {
		getIntersections: function(curve) {
			var v1 = this.getValues(),
				v2 = curve && curve !== this && curve.getValues();
			return v2 ? getCurveIntersections(v1, v2, this, curve, [])
					  : getLoopIntersection(v1, this, []);
		},

		statics: {
			getOverlaps: getOverlaps,
			getIntersections: getIntersections,
			getCurveLineIntersections: getCurveLineIntersections,
			getTimesWithTangent: getTimesWithTangent
		}
	};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',

	initialize: function CurveLocation(curve, time, point, _overlap, _distance) {
		if (time >= 0.99999999) {
			var next = curve.getNext();
			if (next) {
				time = 0;
				curve = next;
			}
		}
		this._setCurve(curve);
		this._time = time;
		this._point = point || curve.getPointAtTime(time);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._previous = null;
	},

	_setCurve: function(curve) {
		var path = curve._path;
		this._path = path;
		this._version = path ? path._version : 0;
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		this._setCurve(segment.getCurve());
		this._segment = segment;
		this._time = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var segment = this._segment;
		if (!segment) {
			var curve = this.getCurve(),
				time = this.getTime();
			if (time === 0) {
				segment = curve._segment1;
			} else if (time === 1) {
				segment = curve._segment2;
			} else if (time != null) {
				segment = curve.getPartLength(0, time)
					< curve.getPartLength(time, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var path = this._path,
			that = this;
		if (path && path._version !== this._version) {
			this._time = this._offset = this._curveOffset = this._curve = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._time = curve.getTimeOf(that._point)) != null) {
				that._setCurve(curve);
				return curve;
			}
		}

		return this._curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getTime: function() {
		var curve = this.getCurve(),
			time = this._time;
		return curve && time == null
			? this._time = curve.getTimeOf(this._point)
			: time;
	},

	getParameter: '#getTime',

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var offset = this._curveOffset;
		if (offset == null) {
			var curve = this.getCurve(),
				time = this.getTime();
			this._curveOffset = offset = time != null && curve
					&& curve.getPartLength(0, time);
		}
		return offset;
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = curve && curve.divideAtTime(this.getTime());
		if (res) {
			this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve(),
			path = curve._path,
			res = curve && curve.splitAtTime(this.getTime());
		if (res) {
			this._setSegment(path.getLastSegment());
		}
		return  res;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc;
		if (!res && loc instanceof CurveLocation) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				p1 = c1._path,
				p2 = c2._path;
			if (p1 === p2) {
				var abs = Math.abs,
					epsilon = 1e-7,
					diff = abs(this.getOffset() - loc.getOffset()),
					i1 = !_ignoreOther && this._intersection,
					i2 = !_ignoreOther && loc._intersection;
				res = (diff < epsilon
						|| p1 && abs(p1.getLength() - diff) < epsilon)
					&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));
			}
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var time = this.getTime();
		if (time != null)
			parts.push('time: ' + f.number(time));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getTime(),
			t2 = inter.getTime(),
			tMin = 1e-8,
			tMax = 1 - tMin,
			t1Inside = t1 >= tMin && t1 <= tMax,
			t2Inside = t2 >= tMin && t2 <= tMax;
		if (t1Inside && t2Inside)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = t1 < tMin ? c2.getPrevious() : c2,
			c4 = inter.getCurve(),
			c3 = t2 < tMin ? c4.getPrevious() : c4;
		if (t1 > tMax)
			c2 = c2.getNext();
		if (t2 > tMax)
			c4 = c4.getNext();
		if (!c1 || !c2 || !c3 || !c4)
			return false;

		var offsets = [];

		function addOffsets(curve, end) {
			var v = curve.getValues(),
				roots = Curve.classify(v).roots || Curve.getPeaks(v),
				count = roots.length,
				t = end && count > 1 ? roots[count - 1]
						: count > 0 ? roots[0]
						: 0.5;
			offsets.push(Curve.getLength(v, end ? t : 0, end ? 1 : t) / 2);
		}

		function isInRange(angle, min, max) {
			return min < max
					? angle > min && angle < max
					: angle > min || angle < max;
		}

		if (!t1Inside) {
			addOffsets(c1, true);
			addOffsets(c2, false);
		}
		if (!t2Inside) {
			addOffsets(c3, true);
			addOffsets(c4, false);
		}
		var pt = this.getPoint(),
			offset = Math.min.apply(Math, offsets),
			v2 = t1Inside ? c2.getTangentAtTime(t1)
					: c2.getPointAt(offset).subtract(pt),
			v1 = t1Inside ? v2.negate()
					: c1.getPointAt(-offset).subtract(pt),
			v4 = t2Inside ? c4.getTangentAtTime(t2)
					: c4.getPointAt(offset).subtract(pt),
			v3 = t2Inside ? v4.negate()
					: c3.getPointAt(-offset).subtract(pt),
			a1 = v1.getAngle(),
			a2 = v2.getAngle(),
			a3 = v3.getAngle(),
			a4 = v4.getAngle();
		return !!(t1Inside
				? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&
				  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))
				: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&
				  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));
	},

	hasOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve._evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var curve = this.getCurve(),
			time = this.getTime();
		return time != null && curve && curve[get](time, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						1e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 !== path2
				? path1._id - path2._id
				: (loc.getIndex() + loc.getTime())
				- (loc2.getIndex() + loc2.getTime());
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = locations.length - 1; i >= 0; i--) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',
	_selectBounds: false,
	_canScaleStroke: true,
	beans: true,

	initialize: function PathItem() {
	},

	statics: {
		create: function(arg) {
			var data,
				segments,
				compound;
			if (Base.isPlainObject(arg)) {
				segments = arg.segments;
				data = arg.pathData;
			} else if (Array.isArray(arg)) {
				segments = arg;
			} else if (typeof arg === 'string') {
				data = arg;
			}
			if (segments) {
				var first = segments[0];
				compound = first && Array.isArray(first[0]);
			} else if (data) {
				compound = (data.match(/m/gi) || []).length > 1
						|| /z\s*\S+/i.test(data);
			}
			var ctor = compound ? CompoundPath : Path;
			return new ctor(arg);
		}
	},

	_asPathItem: function() {
		return this;
	},

	isClockwise: function() {
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
	},

	setPathData: function(data) {

		var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2) {
					this[move ? 'moveTo' : 'lineTo'](current = getPoint(j));
					if (move) {
						start = current;
						move = false;
					}
				}
				control = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				current = current.clone();
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(1e-12);
				current = start;
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = point.isInside(
				this.getBounds({ internal: true, handle: true }))
					? this._getWinding(point)
					: {};
		return winding.onPath || !!(this.getFillRule() === 'evenodd'
				? winding.windingL & 1 || winding.windingR & 1
				: winding.winding);
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix._orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix)._orNullIfIdentity();
		return self || this.getBounds(matrix1).intersects(
				path.getBounds(matrix2), 1e-12)
				? Curve.getIntersections(
						this.getCurves(), !self && path.getCurves(), include,
						matrix1, matrix2, _returnFirst)
				: [];
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.hasOverlap() || inter.isCrossing();
		});
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		var loc = this.getNearestLocation.apply(this, arguments);
		return loc ? loc.getPoint() : loc;
	},

	interpolate: function(from, to, factor) {
		var isPath = !this._children,
			name = isPath ? '_segments' : '_children',
			itemsFrom = from[name],
			itemsTo = to[name],
			items = this[name];
		if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {
			throw new Error('Invalid operands in interpolate() call: ' +
					from + ', ' + to);
		}
		var current = items.length,
			length = itemsTo.length;
		if (current < length) {
			var ctor = isPath ? Segment : Path;
			for (var i = current; i < length; i++) {
				this.add(new ctor());
			}
		} else if (current > length) {
			this[isPath ? 'removeSegments' : 'removeChildren'](length, current);
		}
		for (var i = 0; i < length; i++) {
			items[i].interpolate(itemsFrom[i], itemsTo[i], factor);
		}
		if (isPath) {
			this.setClosed(from._closed);
			this._changed(9);
		}
	},

	compare: function(path) {
		var ok = false;
		if (path) {
			var paths1 = this._children || [this],
				paths2 = path._children ? path._children.slice() : [path],
				length1 = paths1.length,
				length2 = paths2.length,
				matched = [],
				count = 0;
			ok = true;
			for (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {
				var path1 = paths1[i1];
				ok = false;
				for (var i2 = length2 - 1; i2 >= 0 && !ok; i2--) {
					if (path1.compare(paths2[i2])) {
						if (!matched[i2]) {
							matched[i2] = true;
							count++;
						}
						ok = true;
					}
				}
			}
			ok = ok && count === length2;
		}
		return ok;
	},

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._segmentSelection = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	copyContent: function(source) {
		this.setSegments(source._segments);
		this._closed = source._closed;
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			this._length = this._area = undefined;
			if (flags & 32) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 64) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected(),
			length = segments && segments.length;
		this._segments.length = 0;
		this._segmentSelection = 0;
		this._curves = undefined;
		if (length) {
			var last = segments[length - 1];
			if (typeof last === 'boolean') {
				this.setClosed(last);
				length--;
			}
			this._add(Segment.readList(segments, 0, {}, length));
		}
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(41);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine) {
						var dx = curX - prevX,
							dy = curY - prevY;
						parts.push(
							  dx === 0 ? 'v' + f.number(dy)
							: dy === 0 ? 'h' + f.number(dx)
							: 'l' + f.pair(dx, dy));
					}
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							 + ' ' + f.pair( inX - prevX,  inY - prevY)
							 + ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (!length)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	},

	isEmpty: function() {
		return !this._segments.length;
	},

	_transformContent: function(matrix) {
		var segments = this._segments,
			coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selection)
				this._updateSelection(segment, 0, segment._selection);
		}
		if (append) {
			Base.push(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				start = index > 0 && index + amount - 1 === total ? index - 1
					: index,
				insert = start,
				end = Math.min(start + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [start, 0].concat(segs._curves));
				insert += segs._curves.length;
			}
			for (var i = insert; i < end; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(start, end);
		}
		this._changed(41);
		return segs;
	},

	_adjustCurves: function(start, end) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = start; i < end; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && !start ? segments.length - 1
				: start - 1]) {
			curve._segment2 = segments[start] || segments[0];
			curve._changed();
		}
		if (curve = curves[end]) {
			curve._segment1 = segments[end];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readList(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readList(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readList(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readList(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(start, end, _includeCurves) {
		start = start || 0;
		end = Base.pick(end, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(start, end - start),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selection)
				this._updateSelection(segment, segment._selection, 0);
			segment._index = segment._path = null;
		}
		for (var i = start, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = start > 0 && end === count + (this._closed ? 1 : 0)
					? start - 1
					: start,
				curves = curves.splice(index, amount);
			for (var i = curves.length - 1; i >= 0; i--)
				curves[i]._path = null;
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(41);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		var area = this._area;
		if (area == null) {
			var segments = this._segments,
				closed = this._closed;
			area = 0;
			for (var i = 0, l = segments.length; i < l; i++) {
				var last = i + 1 === l;
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[last ? 0 : i + 1],
						null, last && !closed));
			}
			this._area = area;
		}
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this.isSelected() && length > 0 && this._segmentSelection
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelection: function setSelection(selection) {
		if (!(selection & 1))
			this._selectSegments(false);
		setSelection.base.call(this, selection);
	},

	_selectSegments: function(selected) {
		var segments = this._segments,
			length = segments.length,
			selection = selected ? 7 : 0;
		this._segmentSelection = selection * length;
		for (var i = 0; i < length; i++)
			segments[i]._selection = selection;
	},

	_updateSelection: function(segment, oldSelection, newSelection) {
		segment._selection = newSelection;
		var selection = this._segmentSelection += newSelection - oldSelection;
		if (selection > 0)
			this.setSelected(true);
	},

	divideAt: function(location) {
		var loc = this.getLocationAt(location),
			curve;
		return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))
				? curve._segment1
				: null;
	},

	splitAt: function(location) {
		var loc = this.getLocationAt(location),
			index = loc && loc.index,
			time = loc && loc.time,
			tMin = 1e-8,
			tMax = 1 - tMin;
		if (time > tMax) {
			index++;
			time = 0;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (time >= tMin) {
				curves[index++].divideAtTime(time);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this);
				path.copyAttributes(this);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	split: function(index, time) {
		var curve,
			location = time === undefined ? index
				: (curve = this.getCurves()[index])
					&& curve.getLocationAtTime(time);
		return location != null ? this.splitAt(location) : null;
	},

	join: function(path, tolerance) {
		var epsilon = tolerance || 0;
		if (path && path !== this) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.isClose(last2._point, epsilon))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.isClose(first2._point, epsilon)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.isClose(first2._point, epsilon))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.isClose(last2._point, epsilon)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.isClose(last._point, epsilon)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	reduce: function(options) {
		var curves = this.getCurves(),
			simplify = options && options.simplify,
			tolerance = simplify ? 1e-7 : 0;
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (!curve.hasLength(tolerance)
					|| simplify && curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		this._changed(9);
	},

	flatten: function(flatness) {
		var flattener = new PathFlattener(this, flatness || 0.25, 256, true),
			parts = flattener.parts,
			length = parts.length,
			segments = [];
		for (var i = 0; i < length; i++) {
			segments.push(new Segment(parts[i].curve.slice(0, 2)));
		}
		if (!this._closed && length > 0) {
			segments.push(new Segment(parts[length - 1].curve.slice(6)));
		}
		this.setSegments(segments);
	},

	simplify: function(tolerance) {
		var segments = new PathFitter(this).fit(tolerance || 2.5);
		if (segments)
			this.setSegments(segments);
		return !!segments;
	},

	smooth: function(options) {
		var that = this,
			opts = options || {},
			type = opts.type || 'asymmetric',
			segments = this._segments,
			length = segments.length,
			closed = this._closed;

		function getIndex(value, _default) {
			var index = value && value.index;
			if (index != null) {
				var path = value.path;
				if (path && path !== that)
					throw new Error(value._class + ' ' + index + ' of ' + path
							+ ' is not part of ' + that);
				if (_default && value instanceof Curve)
					index++;
			} else {
				index = typeof value === 'number' ? value : _default;
			}
			return Math.min(index < 0 && closed
					? index % length
					: index < 0 ? index + length : index, length - 1);
		}

		var loop = closed && opts.from === undefined && opts.to === undefined,
			from = getIndex(opts.from, 0),
			to = getIndex(opts.to, length - 1);

		if (from > to) {
			if (closed) {
				from -= length;
			} else {
				var tmp = from;
				from = to;
				to = tmp;
			}
		}
		if (/^(?:asymmetric|continuous)$/.test(type)) {
			var asymmetric = type === 'asymmetric',
				min = Math.min,
				amount = to - from + 1,
				n = amount - 1,
				padding = loop ? min(amount, 4) : 1,
				paddingLeft = padding,
				paddingRight = padding,
				knots = [];
			if (!closed) {
				paddingLeft = min(1, from);
				paddingRight = min(1, length - to - 1);
			}
			n += paddingLeft + paddingRight;
			if (n <= 1)
				return;
			for (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {
				knots[i] = segments[(j < 0 ? j + length : j) % length]._point;
			}

			var x = knots[0]._x + 2 * knots[1]._x,
				y = knots[0]._y + 2 * knots[1]._y,
				f = 2,
				n_1 = n - 1,
				rx = [x],
				ry = [y],
				rf = [f],
				px = [],
				py = [];
			for (var i = 1; i < n; i++) {
				var internal = i < n_1,
					a = internal ? 1 : asymmetric ? 1 : 2,
					b = internal ? 4 : asymmetric ? 2 : 7,
					u = internal ? 4 : asymmetric ? 3 : 8,
					v = internal ? 2 : asymmetric ? 0 : 1,
					m = a / f;
				f = rf[i] = b - m;
				x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;
				y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;
			}

			px[n_1] = rx[n_1] / rf[n_1];
			py[n_1] = ry[n_1] / rf[n_1];
			for (var i = n - 2; i >= 0; i--) {
				px[i] = (rx[i] - px[i + 1]) / rf[i];
				py[i] = (ry[i] - py[i + 1]) / rf[i];
			}
			px[n] = (3 * knots[n]._x - px[n_1]) / 2;
			py[n] = (3 * knots[n]._y - py[n_1]) / 2;

			for (var i = paddingLeft, max = n - paddingRight, j = from;
					i <= max; i++, j++) {
				var segment = segments[j < 0 ? j + length : j],
					pt = segment._point,
					hx = px[i] - pt._x,
					hy = py[i] - pt._y;
				if (loop || i < max)
					segment.setHandleOut(hx, hy);
				if (loop || i > paddingLeft)
					segment.setHandleIn(-hx, -hy);
			}
		} else {
			for (var i = from; i <= to; i++) {
				segments[i < 0 ? i + length : i].smooth(opts,
						!loop && i === from, !loop && i === to);
			}
		}
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.copyAttributes(this, true);
			shape._matrix.prepend(this._matrix);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			if (insert === undefined || insert)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	toPath: '#clone',

	compare: function compare(path) {
		if (!path || path instanceof CompoundPath)
			return compare.base.call(this, path);
		var curves1 = this.getCurves(),
			curves2 = path.getCurves(),
			length1 = curves1.length,
			length2 = curves2.length;
		if (!length1 || !length2) {
			return length1 == length2;
		}
		var v1 = curves1[0].getValues(),
			values2 = [],
			pos1 = 0, pos2,
			end1 = 0, end2;
		for (var i = 0; i < length2; i++) {
			var v2 = curves2[i].getValues();
			values2.push(v2);
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;
				end2 = overlaps[0][1];
				break;
			}
		}
		var abs = Math.abs,
			epsilon = 1e-8,
			v2 = values2[pos2],
			start2;
		while (v1 && v2) {
			var overlaps = Curve.getOverlaps(v1, v2);
			if (overlaps) {
				var t1 = overlaps[0][0];
				if (abs(t1 - end1) < epsilon) {
					end1 = overlaps[1][0];
					if (end1 === 1) {
						v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;
						end1 = 0;
					}
					var t2 = overlaps[0][1];
					if (abs(t2 - end2) < epsilon) {
						if (!start2)
							start2 = [pos2, t2];
						end2 = overlaps[1][1];
						if (end2 === 1) {
							if (++pos2 >= length2)
								pos2 = 0;
							v2 = values2[pos2] || curves2[pos2].getValues();
							end2 = 0;
						}
						if (!v1) {
							return start2[0] === pos2 && start2[1] === end2;
						}
						continue;
					}
				}
			}
			break;
		}
		return false;
	},

	_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			strokeRadius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (strokeRadius !== null) {
			if (strokeRadius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = style.getMiterLimit();
				strokePadding = strokePadding.add(
					Path._getStrokePadding(strokeRadius, strokeMatrix));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			var isJoin = closed || segment._index > 0
					&& segment._index < numSegments - 1;
			if ((isJoin ? join : cap) === 'round') {
				return isCloseEnough(segment._point, strokePadding);
			} else {
				area = new Path({ internal: true, closed: true });
				if (isJoin) {
					if (!segment.isSmooth()) {
						Path._addBevelJoin(segment, join, strokeRadius,
							   miterLimit, null, strokeMatrix, addToArea, true);
					}
				} else if (cap === 'square') {
					Path._addSquareCap(segment, cap, strokeRadius, null,
							strokeMatrix, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (strokeRadius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var time = loc.getTime();
				if (time === 0 || time === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point)
							<= miterLimit * strokeRadius
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var loc = this.getLocationAt(offset);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset) {
		if (typeof offset === 'number') {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++) {
				var start = length,
					curve = curves[i];
				length += curve.getLength();
				if (length > offset) {
					return curve.getLocationAt(offset - start);
				}
			}
			if (curves.length > 0 && offset <= this.getLength()) {
				return new CurveLocation(curves[curves.length - 1], 1);
			}
		} else if (offset && offset.getPath && offset.getPath() === this) {
			return offset;
		}
		return null;
	},

	getOffsetsWithTangent: function() {
		var tangent = Point.read(arguments);
		if (tangent.isZero()) {
			return [];
		}

		var offsets = [];
		var curveStart = 0;
		var curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i];
			var curveTimes = curve.getTimesWithTangent(tangent);
			for (var j = 0, m = curveTimes.length; j < m; j++) {
				var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);
				if (offsets.indexOf(offset) < 0) {
					offsets.push(offset);
				}
			}
			curveStart += curve.length;
		}
		return offsets;
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		if (size <= 0) return;

		var half = size / 2,
			miniSize = size - 2,
			miniHalf = half - 1,
			coords = new Array(6),
			pX, pY;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i],
				selection = segment._selection;
			segment._transformCoordinates(matrix, coords);
			pX = coords[0];
			pY = coords[1];
			if (selection & 2)
				drawHandle(2);
			if (selection & 4)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (miniSize > 0 && !(selection & 1)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, viewMatrix, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx, param, viewMatrix);
				if (hasFill) {
					ctx.fill(style.getFillRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this, 0.25, 32, false,
								strokeMatrix),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (!segments.length)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var abs = Math.abs,
				sqrt = Math.sqrt,
				current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else if (!from.equals(to)) {
				var radius = Size.read(arguments),
					isZero = Numerical.isZero;
				if (isZero(radius.width) || isZero(radius.height))
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq = x * x,
					ySq = y * y;
				var factor = sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1) * sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center, true);
				if (centerSide === 0) {
					extent = throughSide * abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			if (extent) {
				var epsilon = 1e-7,
					ext = abs(extent),
					count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90),
					inc = extent / count,
					half = inc * Math.PI / 360,
					z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
					segments = [];
				for (var i = 0; i <= count; i++) {
					var pt = to,
						out = null;
					if (i < count) {
						out = vector.rotate(90).multiply(z);
						if (matrix) {
							pt = matrix._transformPoint(vector);
							out = matrix._transformPoint(vector.add(out))
									.subtract(pt);
						} else {
							pt = center.add(vector);
						}
					}
					if (!i) {
						current.setHandleOut(out);
					} else {
						var _in = vector.rotate(-90).multiply(z);
						if (matrix) {
							_in = matrix._transformPoint(vector.add(_in))
									.subtract(pt);
						}
						segments.push(new Segment(pt, _in, out));
					}
					vector = vector.rotate(inc);
				}
				this._add(segments);
			}
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(tolerance) {
			this.setClosed(true);
			this.join(this, tolerance);
		}
	};
}, {

	_getBounds: function(matrix, options) {
		var method = options.handle
				? 'getHandleBounds'
				: options.stroke
				? 'getStrokeBounds'
				: 'getBounds';
		return Path[method](this._segments, this._closed, this, matrix, options);
	},

statics: {
	getBounds: function(segments, closed, path, matrix, options, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6)),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = style.hasStroke(),
			strokeWidth = style.getStrokeWidth(),
			strokeMatrix = stroke && path._getStrokeMatrix(matrix, options),
			strokePadding = stroke && Path._getStrokePadding(strokeWidth,
				strokeMatrix),
			bounds = Path.getBounds(segments, closed, path, matrix, options,
				strokePadding);
		if (!stroke)
			return bounds;
		var strokeRadius = strokeWidth / 2,
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = style.getMiterLimit(),
			joinBounds = new Rectangle(new Size(strokePadding));

		function addPoint(point) {
			bounds = bounds.include(point);
		}

		function addRound(segment) {
			bounds = bounds.unite(
					joinBounds.setCenter(segment._point.transform(matrix)));
		}

		function addJoin(segment, join) {
			if (join === 'round' || segment.isSmooth()) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, strokeRadius, miterLimit,
						matrix, strokeMatrix, addPoint);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, strokeRadius, matrix,
						strokeMatrix, addPoint);
			}
		}

		var length = segments.length - (closed ? 0 : 1);
		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getStrokePadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var hor = new Point(radius, 0).transform(matrix),
			ver = new Point(0, radius).transform(matrix),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = Math.atan2(b * tan, a),
			ty = Math.atan2(b, tan * a);
		return [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, matrix,
			strokeMatrix, addPoint, isArea) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPoint1().transform(matrix),
			normal1 = curve1.getNormalAtTime(1).multiply(radius)
				.transform(strokeMatrix),
			normal2 = curve2.getNormalAtTime(0).multiply(radius)
				.transform(strokeMatrix),
				angle = normal1.getDirectedAngle(normal2);
		if (angle < 0 || angle >= 180) {
			normal1 = normal1.negate();
			normal2 = normal2.negate();
		}
		if (isArea)
			addPoint(point);
		addPoint(point.add(normal1));
		if (join === 'miter') {
			var corner = new Line(point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit * radius) {
				addPoint(corner);
			}
		}
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,
			addPoint, isArea) {
		var point = segment._point.transform(matrix),
			loc = segment.getLocation(),
			normal = loc.getNormal()
					.multiply(loc.getTime() === 0 ? radius : -radius)
					.transform(strokeMatrix);
		if (cap === 'square') {
			if (isArea) {
				addPoint(point.subtract(normal));
				addPoint(point.add(normal));
			}
			point = point.add(normal.rotate(-90));
		}
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, path, matrix, options) {
		var style = path.getStyle(),
			stroke = options.stroke && style.hasStroke(),
			strokePadding,
			joinPadding;
		if (stroke) {
			var strokeMatrix = path._getStrokeMatrix(matrix, options),
				strokeRadius = style.getStrokeWidth() / 2,
				joinRadius = strokeRadius;
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);
			strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);
			joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);
		}
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords);
			for (var j = 0; j < 6; j += 2) {
				var padding = !j ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert == false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props, { insert: true });
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert == false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = sides % 3 === 0,
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},
	beans: true,

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items) {
		var list = items,
			first = list[0];
		if (first && typeof first[0] === 'number')
			list = [list];
		for (var i = items.length - 1; i >= 0; i--) {
			var item = list[i];
			if (list === items && !(item instanceof Path))
				list = Base.slice(list);
			if (Array.isArray(item)) {
				list[i] = new Path({ segments: item, insert: false });
			} else if (item instanceof CompoundPath) {
				list.splice.apply(list, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		return insertChildren.base.call(this, index, list);
	},

	reduce: function reduce(options) {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce(options);
			if (path.isEmpty())
				path.remove();
		}
		if (!children.length) {
			var path = new Path(Item.NO_INSERT);
			path.copyAttributes(this);
			path.insertAbove(this);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClosed: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			if (!children[i]._closed)
				return false;
		}
		return true;
	},

	setClosed: function(closed) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			children[i].setClosed(closed);
		}
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++) {
			Base.push(curves, children[i].getCurves());
		}
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getLastCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	},

	getLength: function() {
		var children = this._children,
			length = 0;
		for (var i = 0, l = children.length; i < l; i++)
			length += children[i].getLength();
		return length;
	},

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.appended(mx) : _matrix, _precision));
		}
		return paths.join('');
	},

	_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {
		return _hitTestChildren.base.call(this, point,
				options.class === Path || options.type === 'path' ? options
					: Base.set({}, options, { fill: false }),
				viewMatrix);
	},

	_draw: function(ctx, param, viewMatrix, strokeMatrix) {
		var children = this._children;
		if (!children.length)
			return;

		param = param.extend({ dontStart: true, dontFinish: true });
		ctx.beginPath();
		for (var i = 0, l = children.length; i < l; i++)
			children[i].draw(ctx, param, strokeMatrix);

		if (!param.clip) {
			this._setStyles(ctx, param, viewMatrix);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getFillRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectionItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectionItems[child._id]) {
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.appended(mx));
			}
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && !children.length)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	return Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',
			'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',
			'arcBy'],
		function(key) {
			this[key] = function() {
				var path = getCurrentPath(this, true);
				path[key].apply(path, arguments);
			};
		}, {
			moveTo: function() {
				var current = getCurrentPath(this),
					path = current && current.isEmpty() ? current
							: new Path(Item.NO_INSERT);
				if (path !== current)
					this.addChild(path);
				path.moveTo.apply(path, arguments);
			},

			moveBy: function() {
				var current = getCurrentPath(this, true),
					last = current && current.getLastSegment(),
					point = Point.read(arguments);
				this.moveTo(last ? point.add(last._point) : point);
			},

			closePath: function(tolerance) {
				getCurrentPath(this, true).closePath(tolerance);
			}
		}
	);
}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {
	this[key] = function(param) {
		var children = this._children,
			res;
		for (var i = 0, l = children.length; i < l; i++) {
			res = children[i][key](param) || res;
		}
		return res;
	};
}, {}));

PathItem.inject(new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		operators = {
			unite:     { '1': true, '2': true },
			intersect: { '2': true },
			subtract:  { '1': true },
			exclude:   { '1': true, '-1': true }
		};

	function preparePath(path, resolve) {
		var res = path.clone(false).reduce({ simplify: true })
				.transform(null, true, true);
		return resolve
				? res.resolveCrossings().reorient(
					res.getFillRule() === 'nonzero', true)
				: res;
	}

	function createResult(paths, simplify, path1, path2, options) {
		var result = new CompoundPath(Item.NO_INSERT);
		result.addChildren(paths, true);
		result = result.reduce({ simplify: simplify });
		if (!(options && options.insert == false)) {
			result.insertAbove(path2 && path1.isSibling(path2)
					&& path1.getIndex() < path2.getIndex() ? path2 : path1);
		}
		result.copyAttributes(path1, true);
		return result;
	}

	function traceBoolean(path1, path2, operation, options) {
		if (options && (options.trace == false || options.stroke) &&
				/^(subtract|intersect)$/.test(operation))
			return splitBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true),
			operator = operators[operation];
		operator[operation] = true;
		if (_path2 && (operator.subtract || operator.exclude)
				^ (_path2.isClockwise() ^ _path1.isClockwise()))
			_path2.reverse();
		var crossings = divideLocations(
				CurveLocation.expand(_path1.getCrossings(_path2))),
			paths1 = _path1._children || [_path1],
			paths2 = _path2 && (_path2._children || [_path2]),
			segments = [],
			curves = [],
			paths;

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				Base.push(segments, path._segments);
				Base.push(curves, path.getCurves());
				path._overlapsOnly = true;
			}
		}

		if (crossings.length) {
			collect(paths1);
			if (paths2)
				collect(paths2);
			for (var i = 0, l = crossings.length; i < l; i++) {
				propagateWinding(crossings[i]._segment, _path1, _path2, curves,
						operator);
			}
			for (var i = 0, l = segments.length; i < l; i++) {
				var segment = segments[i],
					inter = segment._intersection;
				if (!segment._winding) {
					propagateWinding(segment, _path1, _path2, curves, operator);
				}
				if (!(inter && inter._overlap))
					segment._path._overlapsOnly = false;
			}
			paths = tracePaths(segments, operator);
		} else {
			paths = reorientPaths(
					paths2 ? paths1.concat(paths2) : paths1.slice(),
					function(w) {
						return !!operator[w];
					});
		}

		return createResult(paths, true, path1, path2, options);
	}

	function splitBoolean(path1, path2, operation) {
		var _path1 = preparePath(path1),
			_path2 = preparePath(path2),
			crossings = _path1.getCrossings(_path2),
			subtract = operation === 'subtract',
			divide = operation === 'divide',
			added = {},
			paths = [];

		function addPath(path) {
			if (!added[path._id] && (divide ||
					_path2.contains(path.getPointAt(path.getLength() / 2))
						^ subtract)) {
				paths.unshift(path);
				return added[path._id] = true;
			}
		}

		for (var i = crossings.length - 1; i >= 0; i--) {
			var path = crossings[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return createResult(paths, false, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._previous;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._previous)
				to = to._previous;
			from._next = to;
			to._previous = from;
		}
	}

	function clearCurveHandles(curves) {
		for (var i = curves.length - 1; i >= 0; i--)
			curves[i].clearHandles();
	}

	function reorientPaths(paths, isInside, clockwise) {
		var length = paths && paths.length;
		if (length) {
			var lookup = Base.each(paths, function (path, i) {
					this[path._id] = {
						container: null,
						winding: path.isClockwise() ? 1 : -1,
						index: i
					};
				}, {}),
				sorted = paths.slice().sort(function (a, b) {
					return abs(b.getArea()) - abs(a.getArea());
				}),
				first = sorted[0];
			if (clockwise == null)
				clockwise = first.isClockwise();
			for (var i = 0; i < length; i++) {
				var path1 = sorted[i],
					entry1 = lookup[path1._id],
					point = path1.getInteriorPoint(),
					containerWinding = 0;
				for (var j = i - 1; j >= 0; j--) {
					var path2 = sorted[j];
					if (path2.contains(point)) {
						var entry2 = lookup[path2._id];
						containerWinding = entry2.winding;
						entry1.winding += containerWinding;
						entry1.container = entry2.exclude ? entry2.container
								: path2;
						break;
					}
				}
				if (isInside(entry1.winding) === isInside(containerWinding)) {
					entry1.exclude = true;
					paths[entry1.index] = null;
				} else {
					var container = entry1.container;
					path1.setClockwise(container ? !container.isClockwise()
							: clockwise);
				}
			}
		}
		return paths;
	}

	function divideLocations(locations, include, clearLater) {
		var results = include && [],
			tMin = 1e-8,
			tMax = 1 - tMin,
			clearHandles = false,
			clearCurves = clearLater || [],
			clearLookup = clearLater && {},
			renormalizeLocs,
			prevCurve,
			prevTime;

		function getId(curve) {
			return curve._path._id + '.' + curve._segment1._index;
		}

		for (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {
			var curve = clearLater[i];
			if (curve._path)
				clearLookup[getId(curve)] = true;
		}

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				time = loc._time,
				origTime = time,
				exclude = include && !include(loc),
				curve = loc._curve,
				segment;
			if (curve) {
				if (curve !== prevCurve) {
					clearHandles = !curve.hasHandles()
							|| clearLookup && clearLookup[getId(curve)];
					renormalizeLocs = [];
					prevTime = null;
					prevCurve = curve;
				} else if (prevTime >= tMin) {
					time /= prevTime;
				}
			}
			if (exclude) {
				if (renormalizeLocs)
					renormalizeLocs.push(loc);
				continue;
			} else if (include) {
				results.unshift(loc);
			}
			prevTime = origTime;
			if (time < tMin) {
				segment = curve._segment1;
			} else if (time > tMax) {
				segment = curve._segment2;
			} else {
				var newCurve = curve.divideAtTime(time, true);
				if (clearHandles)
					clearCurves.push(curve, newCurve);
				segment = newCurve._segment1;
				for (var j = renormalizeLocs.length - 1; j >= 0; j--) {
					var l = renormalizeLocs[j];
					l._time = (l._time - time) / (1 - time);
				}
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
		}
		if (!clearLater)
			clearCurveHandles(clearCurves);
		return results || locations;
	}

	function getWinding(point, curves, dir, closed, dontFlip) {
		var ia = dir ? 1 : 0,
			io = ia ^ 1,
			pv = [point.x, point.y],
			pa = pv[ia],
			po = pv[io],
			windingEpsilon = 1e-9,
			qualityEpsilon = 1e-6,
			paL = pa - windingEpsilon,
			paR = pa + windingEpsilon,
			windingL = 0,
			windingR = 0,
			pathWindingL = 0,
			pathWindingR = 0,
			onPath = false,
			onAnyPath = false,
			quality = 1,
			roots = [],
			vPrev,
			vClose;

		function addWinding(v) {
			var o0 = v[io + 0],
				o3 = v[io + 6];
			if (po < min(o0, o3) || po > max(o0, o3)) {
				return;
			}
			var a0 = v[ia + 0],
				a1 = v[ia + 2],
				a2 = v[ia + 4],
				a3 = v[ia + 6];
			if (o0 === o3) {
				if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {
					onPath = true;
				}
				return;
			}
			var t =   po === o0 ? 0
					: po === o3 ? 1
					: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)
					? 1
					: Curve.solveCubic(v, io, po, roots, 0, 1) > 0
						? roots[0]
						: 1,
				a =   t === 0 ? a0
					: t === 1 ? a3
					: Curve.getPoint(v, t)[dir ? 'y' : 'x'],
				winding = o0 > o3 ? 1 : -1,
				windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,
				a3Prev = vPrev[ia + 6];
			if (po !== o0) {
				if (a < paL) {
					pathWindingL += winding;
				} else if (a > paR) {
					pathWindingR += winding;
				} else {
					onPath = true;
				}
				if (a > pa - qualityEpsilon && a < pa + qualityEpsilon)
					quality /= 2;
			} else {
				if (winding !== windingPrev) {
					if (a0 < paL) {
						pathWindingL += winding;
					} else if (a0 > paR) {
						pathWindingR += winding;
					}
				} else if (a0 != a3Prev) {
					if (a3Prev < paR && a > paR) {
						pathWindingR += winding;
						onPath = true;
					} else if (a3Prev > paL && a < paL) {
						pathWindingL += winding;
						onPath = true;
					}
				}
				quality = 0;
			}
			vPrev = v;
			return !dontFlip && a > paL && a < paR
					&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0
					&& getWinding(point, curves, !dir, closed, true);
		}

		function handleCurve(v) {
			var o0 = v[io + 0],
				o1 = v[io + 2],
				o2 = v[io + 4],
				o3 = v[io + 6];
			if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {
				var a0 = v[ia + 0],
					a1 = v[ia + 2],
					a2 = v[ia + 4],
					a3 = v[ia + 6],
					monoCurves = paL > max(a0, a1, a2, a3) ||
								 paR < min(a0, a1, a2, a3)
							? [v] : Curve.getMonoCurves(v, dir),
					res;
				for (var i = 0, l = monoCurves.length; i < l; i++) {
					if (res = addWinding(monoCurves[i]))
						return res;
				}
			}
		}

		for (var i = 0, l = curves.length; i < l; i++) {
			var curve = curves[i],
				path = curve._path,
				v = curve.getValues(),
				res;
			if (!i || curves[i - 1]._path !== path) {
				vPrev = null;
				if (!path._closed) {
					vClose = Curve.getValues(
							path.getLastCurve().getSegment2(),
							curve.getSegment1(),
							null, !closed);
					if (vClose[io] !== vClose[io + 6]) {
						vPrev = vClose;
					}
				}

				if (!vPrev) {
					vPrev = v;
					var prev = path.getLastCurve();
					while (prev && prev !== curve) {
						var v2 = prev.getValues();
						if (v2[io] !== v2[io + 6]) {
							vPrev = v2;
							break;
						}
						prev = prev.getPrevious();
					}
				}
			}

			if (res = handleCurve(v))
				return res;

			if (i + 1 === l || curves[i + 1]._path !== path) {
				if (vClose && (res = handleCurve(vClose)))
					return res;
				if (onPath && !pathWindingL && !pathWindingR) {
					pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir
							? 1 : -1;
				}
				windingL += pathWindingL;
				windingR += pathWindingR;
				pathWindingL = pathWindingR = 0;
				if (onPath) {
					onAnyPath = true;
					onPath = false;
				}
				vClose = null;
			}
		}
		windingL = abs(windingL);
		windingR = abs(windingR);
		return {
			winding: max(windingL, windingR),
			windingL: windingL,
			windingR: windingR,
			quality: quality,
			onPath: onAnyPath
		};
	}

	function propagateWinding(segment, path1, path2, curves, operator) {
		var chain = [],
			start = segment,
			totalLength = 0,
			winding;
		do {
			var curve = segment.getCurve(),
				length = curve.getLength();
			chain.push({ segment: segment, curve: curve, length: length });
			totalLength += length;
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		var offsets = [0.5, 0.25, 0.75],
			winding = { winding: 0, quality: -1 },
			tMin = 1e-8,
			tMax = 1 - tMin;
		for (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {
			var length = totalLength * offsets[i];
			for (var j = 0, l = chain.length; j < l; j++) {
				var entry = chain[j],
					curveLength = entry.length;
				if (length <= curveLength) {
					var curve = entry.curve,
						path = curve._path,
						parent = path._parent,
						operand = parent instanceof CompoundPath ? parent : path,
						t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),
						pt = curve.getPointAtTime(t),
						dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;
					var wind = null;
					if (operator.subtract && path2) {
						var pathWinding = operand === path1
										  ? path2._getWinding(pt, dir, true)
										  : path1._getWinding(pt, dir, true);
						if (operand === path1 && pathWinding.winding ||
							operand === path2 && !pathWinding.winding) {
							if (pathWinding.quality < 1) {
								continue;
							} else {
								wind = { winding: 0, quality: 1 };
							}
						}
					}
					wind = wind || getWinding(pt, curves, dir, true);
					if (wind.quality > winding.quality)
						winding = wind;
					break;
				}
				length -= curveLength;
			}
		}
		for (var j = chain.length - 1; j >= 0; j--) {
			chain[j].segment._winding = winding;
		}
	}

	function tracePaths(segments, operator) {
		var paths = [],
			starts;

		function isValid(seg) {
			var winding;
			return !!(seg && !seg._visited && (!operator
					|| operator[(winding = seg._winding || {}).winding]
						&& !(operator.unite && winding.winding === 2
							&& winding.windingL && winding.windingR)));
		}

		function isStart(seg) {
			if (seg) {
				for (var i = 0, l = starts.length; i < l; i++) {
					if (seg === starts[i])
						return true;
				}
			}
			return false;
		}

		function visitPath(path) {
			var segments = path._segments;
			for (var i = 0, l = segments.length; i < l; i++) {
				segments[i]._visited = true;
			}
		}

		function getCrossingSegments(segment, collectStarts) {
			var inter = segment._intersection,
				start = inter,
				crossings = [];
			if (collectStarts)
				starts = [segment];

			function collect(inter, end) {
				while (inter && inter !== end) {
					var other = inter._segment,
						path = other && other._path;
					if (path) {
						var next = other.getNext() || path.getFirstSegment(),
							nextInter = next._intersection;
						if (other !== segment && (isStart(other)
							|| isStart(next)
							|| next && (isValid(other) && (isValid(next)
								|| nextInter && isValid(nextInter._segment))))
						) {
							crossings.push(other);
						}
						if (collectStarts)
							starts.push(other);
					}
					inter = inter._next;
				}
			}

			if (inter) {
				collect(inter);
				while (inter && inter._prev)
					inter = inter._prev;
				collect(inter, start);
			}
			return crossings;
		}

		segments.sort(function(seg1, seg2) {
			var inter1 = seg1._intersection,
				inter2 = seg2._intersection,
				over1 = !!(inter1 && inter1._overlap),
				over2 = !!(inter2 && inter2._overlap),
				path1 = seg1._path,
				path2 = seg2._path;
			return over1 ^ over2
					? over1 ? 1 : -1
					: !inter1 ^ !inter2
						? inter1 ? 1 : -1
						: path1 !== path2
							? path1._id - path2._id
							: seg1._index - seg2._index;
		});

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				valid = isValid(seg),
				path = null,
				finished = false,
				closed = true,
				branches = [],
				branch,
				visited,
				handleIn;
			if (valid && seg._path._overlapsOnly) {
				var path1 = seg._path,
					path2 = seg._intersection._segment._path;
				if (path1.compare(path2)) {
					if (path1.getArea())
						paths.push(path1.clone(false));
					visitPath(path1);
					visitPath(path2);
					valid = false;
				}
			}
			while (valid) {
				var first = !path,
					crossings = getCrossingSegments(seg, first),
					other = crossings.shift(),
					finished = !first && (isStart(seg) || isStart(other)),
					cross = !finished && other;
				if (first) {
					path = new Path(Item.NO_INSERT);
					branch = null;
				}
				if (finished) {
					if (seg.isFirst() || seg.isLast())
						closed = seg._path._closed;
					seg._visited = true;
					break;
				}
				if (cross && branch) {
					branches.push(branch);
					branch = null;
				}
				if (!branch) {
					if (cross)
						crossings.push(seg);
					branch = {
						start: path._segments.length,
						crossings: crossings,
						visited: visited = [],
						handleIn: handleIn
					};
				}
				if (cross)
					seg = other;
				if (!isValid(seg)) {
					path.removeSegments(branch.start);
					for (var j = 0, k = visited.length; j < k; j++) {
						visited[j]._visited = false;
					}
					visited.length = 0;
					do {
						seg = branch && branch.crossings.shift();
						if (!seg || !seg._path) {
							seg = null;
							branch = branches.pop();
							if (branch) {
								visited = branch.visited;
								handleIn = branch.handleIn;
							}
						}
					} while (branch && !isValid(seg));
					if (!seg)
						break;
				}
				var next = seg.getNext();
				path.add(new Segment(seg._point, handleIn,
						next && seg._handleOut));
				seg._visited = true;
				visited.push(seg);
				seg = next || seg._path.getFirstSegment();
				handleIn = next && next._handleIn;
			}
			if (finished) {
				if (closed) {
					path.getFirstSegment().setHandleIn(handleIn);
					path.setClosed(closed);
				}
				if (path.getArea() !== 0) {
					paths.push(path);
				}
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, dir, closed) {
			return getWinding(point, this.getCurves(), dir, closed);
		},

		unite: function(path, options) {
			return traceBoolean(this, path, 'unite', options);
		},

		intersect: function(path, options) {
			return traceBoolean(this, path, 'intersect', options);
		},

		subtract: function(path, options) {
			return traceBoolean(this, path, 'subtract', options);
		},

		exclude: function(path, options) {
			return traceBoolean(this, path, 'exclude', options);
		},

		divide: function(path, options) {
			return options && (options.trace == false || options.stroke)
					? splitBoolean(this, path, 'divide')
					: createResult([
						this.subtract(path, options),
						this.intersect(path, options)
					], true, this, path, options);
		},

		resolveCrossings: function() {
			var children = this._children,
				paths = children || [this];

			function hasOverlap(seg, path) {
				var inter = seg && seg._intersection;
				return inter && inter._overlap && inter._path === path;
			}

			var hasOverlaps = false,
				hasCrossings = false,
				intersections = this.getIntersections(null, function(inter) {
					return inter.hasOverlap() && (hasOverlaps = true) ||
							inter.isCrossing() && (hasCrossings = true);
				}),
				clearCurves = hasOverlaps && hasCrossings && [];
			intersections = CurveLocation.expand(intersections);
			if (hasOverlaps) {
				var overlaps = divideLocations(intersections, function(inter) {
					return inter.hasOverlap();
				}, clearCurves);
				for (var i = overlaps.length - 1; i >= 0; i--) {
					var overlap = overlaps[i],
						path = overlap._path,
						seg = overlap._segment,
						prev = seg.getPrevious(),
						next = seg.getNext();
					if (hasOverlap(prev, path) && hasOverlap(next, path)) {
						seg.remove();
						prev._handleOut._set(0, 0);
						next._handleIn._set(0, 0);
						if (prev !== seg && !prev.getCurve().hasLength()) {
							next._handleIn.set(prev._handleIn);
							prev.remove();
						}
					}
				}
			}
			if (hasCrossings) {
				divideLocations(intersections, hasOverlaps && function(inter) {
					var curve1 = inter.getCurve(),
						seg1 = inter.getSegment(),
						other = inter._intersection,
						curve2 = other._curve,
						seg2 = other._segment;
					if (curve1 && curve2 && curve1._path && curve2._path)
						return true;
					if (seg1)
						seg1._intersection = null;
					if (seg2)
						seg2._intersection = null;
				}, clearCurves);
				if (clearCurves)
					clearCurveHandles(clearCurves);
				paths = tracePaths(Base.each(paths, function(path) {
					Base.push(this, path._segments);
				}, []));
			}
			var length = paths.length,
				item;
			if (length > 1 && children) {
				if (paths !== children)
					this.setChildren(paths);
				item = this;
			} else if (length === 1 && !children) {
				if (paths[0] !== this)
					this.setSegments(paths[0].removeSegments());
				item = this;
			}
			if (!item) {
				item = new CompoundPath(Item.NO_INSERT);
				item.addChildren(paths);
				item = item.reduce();
				item.copyAttributes(this);
				this.replaceWith(item);
			}
			return item;
		},

		reorient: function(nonZero, clockwise) {
			var children = this._children;
			if (children && children.length) {
				this.setChildren(reorientPaths(this.removeChildren(),
						function(w) {
							return !!(nonZero ? w : w & 1);
						},
						clockwise));
			} else if (clockwise !== undefined) {
				this.setClockwise(clockwise);
			}
			return this;
		},

		getInteriorPoint: function() {
			var bounds = this.getBounds(),
				point = bounds.getCenter(true);
			if (!this.contains(point)) {
				var curves = this.getCurves(),
					y = point.y,
					intercepts = [],
					roots = [];
				for (var i = 0, l = curves.length; i < l; i++) {
					var v = curves[i].getValues(),
						o0 = v[1],
						o1 = v[3],
						o2 = v[5],
						o3 = v[7];
					if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {
						var monoCurves = Curve.getMonoCurves(v);
						for (var j = 0, m = monoCurves.length; j < m; j++) {
							var mv = monoCurves[j],
								mo0 = mv[1],
								mo3 = mv[7];
							if ((mo0 !== mo3) &&
								(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){
								var x = y === mo0 ? mv[0]
									: y === mo3 ? mv[6]
									: Curve.solveCubic(mv, 1, y, roots, 0, 1)
										=== 1
										? Curve.getPoint(mv, roots[0]).x
										: (mv[0] + mv[6]) / 2;
								intercepts.push(x);
							}
						}
					}
				}
				if (intercepts.length > 1) {
					intercepts.sort(function(a, b) { return a - b; });
					point.x = (intercepts[0] + intercepts[1]) / 2;
				}
			}
			return point;
		}
	};
});

var PathFlattener = Base.extend({
	_class: 'PathFlattener',

	initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minSpan = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, t1, t2) {
			if ((t2 - t1) > minSpan
					&& !(ignoreStraight && Curve.isStraight(curve))
					&& !Curve.isFlatEnough(curve, flatness || 0.25)) {
				var halves = Curve.subdivide(curve, 0.5),
					tMid = (t1 + t2) / 2;
				computeParts(halves[0], index, t1, tMid);
				computeParts(halves[1], index, tMid, t2);
			} else {
				var dx = curve[6] - curve[0],
					dy = curve[7] - curve[1],
					dist = Math.sqrt(dx * dx + dy * dy);
				if (dist > 0) {
					length += dist;
					parts.push({
						offset: length,
						curve: curve,
						index: index,
						time: t2,
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2 || segment1, segments[0]);
		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	_get: function(offset) {
		var parts = this.parts,
			length = parts.length,
			start,
			i, j = this.index;
		for (;;) {
			i = j;
			if (!j || parts[--j].offset < offset)
				break;
		}
		for (; i < length; i++) {
			var part = parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = parts[i - 1],
					prevTime = prev && prev.index === part.index ? prev.time : 0,
					prevOffset = prev ? prev.offset : 0;
				return {
					index: part.index,
					time: prevTime + (part.time - prevTime)
						* (offset - prevOffset) / (part.offset - prevOffset)
				};
			}
		}
		return {
			index: parts[length - 1].index,
			time: 1
		};
	},

	drawPart: function(ctx, from, to) {
		var start = this._get(from),
			end = this._get(to);
		for (var i = start.index, l = end.index; i <= l; i++) {
			var curve = Curve.getPart(this.curves[i],
					i === start.index ? start.time : 0,
					i === end.index ? end.time : 1);
			if (i === start.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve._evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset) {
			var param = this._get(offset);
			return Curve[name](this.curves[param.index], param.time);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path) {
		var points = this.points = [],
			segments = path._segments,
			closed = path._closed;
		for (var i = 0, prev, l = segments.length; i < l; i++) {
			var point = segments[i].point;
			if (!prev || !prev.equals(point)) {
				points.push(prev = point.clone());
			}
		}
		if (closed) {
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}
		this.closed = closed;
	},

	fit: function(error) {
		var points = this.points,
			length = points.length,
			segments = null;
		if (length > 0) {
			segments = [new Segment(points[0])];
			if (length > 1) {
				this.fitCubic(segments, error, 0, length - 1,
						points[1].subtract(points[0]),
						points[length - 2].subtract(points[length - 1]));
				if (this.closed) {
					segments.shift();
					segments.pop();
				}
			}
		}
		return segments;
	},

	fitCubic: function(segments, error, first, last, tan1, tan2) {
		var points = this.points;
		if (last - first === 1) {
			var pt1 = points[first],
				pt2 = points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(error, error * error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < error && parametersInOrder) {
				this.addCurve(segments, curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var tanCenter = points[split - 1].subtract(points[split + 1]);
		this.fitCubic(segments, error, first, split, tan1, tanCenter);
		this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(segments, curve) {
		var prev = segments[segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			abs = Math.abs,
			points = this.points,
			pt1 = points[first],
			pt2 = points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1,
			alpha2;
		if (abs(detC0C1) > epsilon) {
			var detC0X = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0
							: abs(c1) > epsilon ? X[1] / c1
							: 0;
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1,
				pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)),
				pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		return Numerical.isZero(df) ? u : u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsOptions: { stroke: false, handle: false },

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	copyContent: function(source) {
		this.setContent(source._content);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(521);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx, param, viewMatrix) {
		if (!this._content)
			return;
		this._setStyles(ctx, param, viewMatrix);
		var lines = this._lines,
			style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (hasFill) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(matrix, options) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var rect = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(rect, rect) : rect;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		namedColors = {
			transparent: [0, 0, 0, 0]
		},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(
				/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
			) || string.match(
				/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
			),
			type = 'rgb',
			components;
		if (match) {
			var amount = match[4] ? 4 : 3;
			components = new Array(amount);
			for (var i = 0; i < amount; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^(rgb|hsl)a?\((.*)\)$/)) {
			type = match[1];
			components = match[2].trim().split(/[,\s]+/g);
			var isHSL = type === 'hsl';
			for (var i = 0, l = Math.min(components.length, 4); i < l; i++) {
				var component = components[i];
				var value = parseFloat(component);
				if (isHSL) {
					if (i === 0) {
						var unit = component.match(/([a-z]*)$/)[1];
						value *= ({
							turn: 360,
							rad: 180 / Math.PI,
							grad: 0.9
						}[unit] || 1);
					} else if (i < 3) {
						value /= 100;
					}
				} else if (i < 3) {
					value /= 255;
				}
				components[i] = value;
			}
		} else {
			var color = namedColors[string];
			if (!color) {
				if (window) {
					if (!colorCtx) {
						colorCtx = CanvasProvider.getContext(1, 1);
						colorCtx.globalCompositeOperation = 'copy';
					}
					colorCtx.fillStyle = 'rgba(0,0,0,0)';
					colorCtx.fillStyle = string;
					colorCtx.fillRect(0, 0, 1, 1);
					var data = colorCtx.getImageData(0, 0, 1, 1).data;
					color = namedColors[string] = [
						data[0] / 255,
						data[1] / 255,
						data[2] / 255
					];
				} else {
					color = [0, 0, 0];
				}
			}
			components = color.slice();
		}
		return [type, components];
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = type === 'gradient'
					? name === 'gradient'
						? function(value) {
							var current = this._components[0];
							value = Gradient.read(
								Array.isArray(value)
									? value
									: arguments, 0, { readNull: true }
							);
							if (current !== value) {
								if (current)
									current._removeOwner(this);
								if (value)
									value._addOwner(this);
							}
							return value;
						}
						: function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
					: function(value) {
						return value == null || isNaN(value) ? 0 : +value;
					};
			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var args = arguments,
				reading = this.__read,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (reading)
						read = 1;
					args = Base.slice(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (reading) {
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					}
					if (values.length > length)
						values = Base.slice(values, 0, length);
				} else if (argType === 'string') {
					var converted = fromCSS(arg);
					type = converted[0];
					components = converted[1];
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && !i && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (reading && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (reading)
				this.__read = read;
			return this;
		},

		set: '#initialize',

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner) {
				if (this._setter) {
					this._owner[this._setter](this);
				} else {
					this._owner._changed(129);
				}
			}
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this.getAlpha() === col.getAlpha()
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx, matrix) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				highlight = components[3],
				inverse = matrix && matrix.inverted(),
				canvasGradient;
			if (inverse) {
				origin = inverse._transformPoint(origin);
				destination = inverse._transformPoint(destination);
				if (highlight)
					highlight = inverse._transformPoint(highlight);
			}
			if (gradient._radial) {
				var radius = destination.getDistance(origin);
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					offset = stop._offset;
				canvasGradient.addColorStop(
						offset == null ? i / (l - 1) : offset,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			},

			_setOwner: function(color, owner, setter) {
				if (color) {
					if (color._owner && owner && color._owner !== owner) {
						color = color.clone();
					}
					if (!color._owner ^ !owner) {
						color._owner = owner || null;
						color._setter = setter || null;
					}
				}
				return color;
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && Base.isPlainObject(stops)) {
			this.set(stops);
			stops = radial = null;
		}
		if (this._stops == null) {
			this.setStops(stops || ['white', 'black']);
		}
		if (this._radial == null) {
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
		}
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++) {
			this._owners[i]._changed();
		}
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (!this._owners.length)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++) {
			stops[i] = this._stops[i].clone();
		}
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (stops.length < 2) {
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		}
		var _stops = this._stops;
		if (_stops) {
			for (var i = 0, l = _stops.length; i < l; i++)
				_stops[i]._owner = undefined;
		}
		_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });
		for (var i = 0, l = _stops.length; i < l; i++)
			_stops[i]._owner = this;
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class) {
			var stops1 = this._stops,
				stops2 = gradient._stops,
				length = stops1.length;
			if (length === stops2.length) {
				for (var i = 0; i < length; i++) {
					if (!stops1[i].equals(stops2[i]))
						return false;
				}
				return true;
			}
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		var color = arg0,
			offset = arg1;
		if (typeof arg0 === 'object' && arg1 === undefined) {
			if (Array.isArray(arg0) && typeof arg0[0] !== 'number') {
				color = arg0[0];
				offset = arg0[1];
			} else if ('color' in arg0 || 'offset' in arg0
					|| 'rampPoint' in arg0) {
				color = arg0.color;
				offset = arg0.offset || arg0.rampPoint || 0;
			}
		}
		this.setColor(color);
		this.setOffset(offset);
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._offset);
	},

	_serialize: function(options, dictionary) {
		var color = this._color,
			offset = this._offset;
		return Base.serialize(offset == null ? [color] : [color, offset],
				options, true, dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(129);
	},

	getOffset: function() {
		return this._offset;
	},

	setOffset: function(offset) {
		this._offset = offset;
		this._changed();
	},

	getRampPoint: '#getOffset',
	setRampPoint: '#setOffset',

	getColor: function() {
		return this._color;
	},

	setColor: function() {
		Color._setOwner(this._color, null);
		this._color = Color._setOwner(Color.read(arguments, 0), this,
				'setColor');
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._offset == stop._offset
				|| false;
	}
});

var Style = Base.extend(new function() {
	var itemDefaults = {
		fillColor: null,
		fillRule: 'nonzero',
		strokeColor: null,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		shadowColor: null,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: null
	},
	groupDefaults = Base.set({}, itemDefaults, {
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		leading: null,
		justification: 'left'
	}),
	textDefaults = Base.set({}, groupDefaults, {
		fillColor: new Color()
	}),
	flags = {
		strokeWidth: 193,
		strokeCap: 193,
		strokeJoin: 193,
		strokeScaling: 201,
		miterLimit: 193,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	},
	item = {
		beans: true
	},
	fields = {
		_class: 'Style',
		beans: true,

		initialize: function Style(style, _owner, _project) {
			this._values = {};
			this._owner = _owner;
			this._project = _owner && _owner._project || _project
					|| paper.project;
			this._defaults = !_owner || _owner instanceof Group ? groupDefaults
					: _owner instanceof TextItem ? textDefaults
					: itemDefaults;
			if (style)
				this.set(style);
		}
	};

	Base.each(groupDefaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath);
			if (applyToChildren) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			}
			if ((key === 'selectedColor' || !applyToChildren)
					&& key in this._defaults) {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old) {
							Color._setOwner(old, null);
							old._canvasStyle = null;
						}
						if (value && value.constructor === Color) {
							value = Color._setOwner(value, owner,
									applyToChildren && set);
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 129);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				applyToChildren = children && children.length > 0
					&& !(owner instanceof CompoundPath),
				value;
			if (applyToChildren && !_dontMerge) {
				for (var i = 0, l = children.length; i < l; i++) {
					var childValue = children[i]._style[get]();
					if (!i) {
						value = childValue;
					} else if (!Base.equals(value, childValue)) {
						return undefined;
					}
				}
			} else if (key in this._defaults) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone) {
						value = value.clone();
					}
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
					}
				}
			}
			if (value && isColor) {
				value = Color._setOwner(value, owner, applyToChildren && set);
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Base.each({
		Font: 'FontFamily',
		WindingRule: 'FillRule'
	}, function(value, key) {
		var get = 'get' + key,
			set = 'set' + key;
		fields[get] = item[get] = '#get' + value;
		fields[set] = item[set] = '#set' + value;
	});

	Item.inject(item);
	return fields;
}, {
	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		function compare(style1, style2, secondary) {
			var values1 = style1._values,
				values2 = style2._values,
				defaults2 = style2._defaults;
			for (var key in values1) {
				var value1 = values1[key],
					value2 = values2[key];
				if (!(secondary && key in values2) && !Base.equals(value1,
						value2 === undefined ? defaults2[key] : value2))
					return false;
			}
			return true;
		}

		return style === this || style && this._class === style._class
				&& compare(this, style)
				&& compare(style, this, true)
				|| false;
	},

	_dispose: function() {
		var color;
		color = this.getFillColor();
		if (color) color._canvasStyle = null;
		color = this.getStrokeColor();
		if (color) color._canvasStyle = null;
		color = this.getShadowColor();
		if (color) color._canvasStyle = null;
	},

	hasFill: function() {
		var color = this.getFillColor();
		return !!color && color.alpha > 0;
	},

	hasStroke: function() {
		var color = this.getStrokeColor();
		return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		var color = this.getShadowColor();
		return !!color && color.alpha > 0 && (this.getShadowBlur() > 0
				|| !this.getShadowOffset().isZero());
	},

	getView: function() {
		return this._project._view;
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		isInserted: function(el) {
			return document.body.contains(el);
		},

		getPrefixed: function(el, name) {
			return el && handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++) {
					var name = parts[i];
					var options = (
						el === document
						&& (name === 'touchstart' || name === 'touchmove')
					) ? { passive: false } : false;
					el.addEventListener(name, func, options);
				}
			}
		}
	},

	remove: function(el, events) {
		if (el) {
			for (var type in events) {
				var func = events[type],
					parts = type.split(/[\s,]+/g);
				for (var i = 0, l = parts.length; i < l; i++)
					el.removeEventListener(parts[i], func, false);
			}
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		timer;

	function handleCallbacks() {
		var functions = callbacks;
		callbacks = [];
		for (var i = 0, l = functions.length; i < l; i++)
			functions[i]();
		requested = nativeRequest && callbacks.length;
		if (requested)
			nativeRequest(handleCallbacks);
	}

	return function(callback) {
		callbacks.push(callback);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		}

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		}

		var size;
		if (window && element) {
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userDrag: none,
				userSelect: none,
				touchCallout: none,
				contentZooming: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}

			size = getCanvasSize();

			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}
		} else {
			size = new Size(element);
			element = null;
		}
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		if (!this._pixelRatio)
			this._pixelRatio = window && window.devicePixelRatio || 1;
		this._setElementSize(size.width, size.height);
		this._viewSize = size;
		View._views.push(this);
		View._viewsById[this._id] = this;
		(this._matrix = new Matrix())._owner = this;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
		this._itemEvents = { native: {}, virtual: {} };
		this._autoUpdate = !paper.agent.node;
		this._needsUpdate = false;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		var project = this._project;
		if (project._view === this)
			project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(
		Item._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),
		function(name) {
			this[name] = {};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	getAutoUpdate: function() {
		return this._autoUpdate;
	},

	setAutoUpdate: function(autoUpdate) {
		this._autoUpdate = autoUpdate;
		if (autoUpdate)
			this.requestUpdate();
	},

	update: function() {
	},

	draw: function() {
		this.update();
	},

	requestUpdate: function() {
		if (!this._requested) {
			var that = this;
			DomEvent.requestAnimationFrame(function() {
				that._requested = false;
				if (that._animate) {
					that.requestUpdate();
					var element = that._element;
					if ((!DomElement.getPrefixed(document, 'hidden')
							|| PaperScope.getAttribute(element, 'keepalive')
								=== 'true') && DomElement.isInView(element)) {
						that._handleFrame();
					}
				}
				if (that._autoUpdate)
					that.update();
			});
			this._requested = true;
		}
	},

	play: function() {
		this._animate = true;
		this.requestUpdate();
	},

	pause: function() {
		this._animate = false;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._last ? now - this._last : 0;
		this._last = now;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_changed: function() {
		this._project._changed(4097);
		this._bounds = this._decomposed = undefined;
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._setElementSize(size.width, size.height);
		this._viewSize.set(size);
		this._changed();
		this.emit('resize', { size: size, delta: delta });
		if (this._autoUpdate) {
			this.update();
		}
	},

	_setElementSize: function(width, height) {
		var element = this._element;
		if (element) {
			if (element.width !== width)
				element.width = width;
			if (element.height !== height)
				element.height = height;
		}
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	isInserted: function() {
		return DomElement.isInserted(this._element);
	},

	getPixelSize: function(size) {
		var element = this._element,
			pixels;
		if (element) {
			var parent = element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			pixels = parseFloat(pixels);
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		return 0;
	}
}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {
	var rotate = key === 'rotate';
	this[key] = function() {
		var value = (rotate ? Base : Point).read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[key](value,
				center || this.getCenter(true)));
	};
}, {
	_decompose: function() {
		return this._decomposed || (this._decomposed = this._matrix.decompose());
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.translate(this.getCenter().subtract(center));
	},

	getZoom: function() {
		var scaling = this._decompose().scaling;
		return (scaling.x + scaling.y) / 2;
	},

	setZoom: function(zoom) {
		this.transform(new Matrix().scale(zoom / this.getZoom(),
			this.getCenter()));
	},

	getRotation: function() {
		return this._decompose().rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			this.rotate(rotation - current);
		}
	},

	getScaling: function() {
		var scaling = this._decompose().scaling;
		return new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling(),
			scaling = Point.read(arguments, 0, { clone: true, readNull: true });
		if (current && scaling) {
			this.scale(scaling.x / current.x, scaling.y / current.y);
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
	},

	transform: function(matrix) {
		this._matrix.append(matrix);
	},

	scrollBy: function() {
		this.translate(Point.read(arguments).negate());
	}
}), {

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	getEventPoint: function(event) {
		return this.viewToProject(DomEvent.getOffset(event, this._element));
	},

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (document && typeof element === 'string')
				element = document.getElementById(element);
			var ctor = window ? CanvasView : View;
			return new ctor(project, element);
		}
	}
},
new function() {
	if (!window)
		return;
	var prevFocus,
		tempFocus,
		dragging = false,
		mouseDown = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[
				target.getAttribute('id')];
	}

	function updateFocus() {
		var view = View._focused;
		if (!view || !view.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				if ((view = View._views[i]).isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, event, point) {
		view._handleMouseEvent('mousemove', event, point);
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {},
		docEvents = {
			mouseout: function(event) {
				var view = View._focused,
					target = DomEvent.getRelatedTarget(event);
				if (view && (!target || target.nodeName === 'HTML')) {
					var offset = DomEvent.getOffset(event, view._element),
						x = offset.x,
						abs = Math.abs,
						ax = abs(x),
						max = 1 << 25,
						diff = ax - max;
					offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;
					handleMouseMove(view, event, view.viewToProject(offset));
				}
			},

			scroll: updateFocus
		};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event);
		if (!dragging) {
			dragging = true;
			view._handleMouseEvent('mousedown', event);
		}
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!mouseDown) {
			var target = getView(event);
			if (target) {
				if (view !== target) {
					if (view)
						handleMouseMove(view, event);
					if (!prevFocus)
						prevFocus = view;
					view = View._focused = tempFocus = target;
				}
			} else if (tempFocus && tempFocus === view) {
				if (prevFocus && !prevFocus.isInserted())
					prevFocus = null;
				view = View._focused = prevFocus;
				prevFocus = null;
				updateFocus();
			}
		}
		if (view)
			handleMouseMove(view, event);
	};

	docEvents[mousedown] = function() {
		mouseDown = true;
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (view && dragging)
			view._handleMouseEvent('mouseup', event);
		mouseDown = dragging = false;
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var called = false,
		prevented = false,
		fallbacks = {
			doubleclick: 'click',
			mousedrag: 'mousemove'
		},
		wasInView = false,
		overView,
		downPoint,
		lastPoint,
		downItem,
		overItem,
		dragItem,
		clickItem,
		clickTime,
		dblClick;

	function emitMouseEvent(obj, target, type, event, point, prevPoint,
			stopItem) {
		var stopped = false,
			mouseEvent;

		function emit(obj, type) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point,
							target || obj,
							prevPoint ? point.subtract(prevPoint) : null);
				}
				if (obj.emit(type, mouseEvent)) {
					called = true;
					if (mouseEvent.prevented)
						prevented = true;
					if (mouseEvent.stopped)
						return stopped = true;
				}
			} else {
				var fallback = fallbacks[type];
				if (fallback)
					return emit(obj, fallback);
			}
		}

		while (obj && obj !== stopItem) {
			if (emit(obj, type))
				break;
			obj = obj._parent;
		}
		return stopped;
	}

	function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {
		view._project.removeOn(type);
		prevented = called = false;
		return (dragItem && emitMouseEvent(dragItem, null, type, event,
					point, prevPoint)
			|| hitItem && hitItem !== dragItem
				&& !hitItem.isDescendant(dragItem)
				&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?
					'mousemove' : type, event, point, prevPoint, dragItem)
			|| emitMouseEvent(view, dragItem || hitItem || view, type, event,
					point, prevPoint));
	}

	var itemEventsMap = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleMouseEvent: function(type, event, point) {
			var itemEvents = this._itemEvents,
				hitItems = itemEvents.native[type],
				nativeMove = type === 'mousemove',
				tool = this._scope.tool,
				view = this;

			function responds(type) {
				return itemEvents.virtual[type] || view.responds(type)
						|| tool && tool.responds(type);
			}

			if (nativeMove && dragging && responds('mousedrag'))
				type = 'mousedrag';
			if (!point)
				point = this.getEventPoint(event);

			var inView = this.getBounds().contains(point),
				hit = hitItems && inView && view._project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				hitItem = hit && hit.item || null,
				handle = false,
				mouse = {};
			mouse[type.substr(5)] = true;

			if (hitItems && hitItem !== overItem) {
				if (overItem) {
					emitMouseEvent(overItem, null, 'mouseleave', event, point);
				}
				if (hitItem) {
					emitMouseEvent(hitItem, null, 'mouseenter', event, point);
				}
				overItem = hitItem;
			}
			if (wasInView ^ inView) {
				emitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',
						event, point);
				overView = inView ? this : null;
				handle = true;
			}
			if ((inView || mouse.drag) && !point.equals(lastPoint)) {
				emitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',
						event, point, lastPoint);
				handle = true;
			}
			wasInView = inView;
			if (mouse.down && inView || mouse.up && downPoint) {
				emitMouseEvents(this, hitItem, type, event, point, downPoint);
				if (mouse.down) {
					dblClick = hitItem === clickItem
						&& (Date.now() - clickTime < 300);
					downItem = clickItem = hitItem;
					if (!prevented && hitItem) {
						var item = hitItem;
						while (item && !item.responds('mousedrag'))
							item = item._parent;
						if (item)
							dragItem = hitItem;
					}
					downPoint = point;
				} else if (mouse.up) {
					if (!prevented && hitItem === downItem) {
						clickTime = Date.now();
						emitMouseEvents(this, hitItem, dblClick ? 'doubleclick'
								: 'click', event, point, downPoint);
						dblClick = false;
					}
					downItem = dragItem = null;
				}
				wasInView = false;
				handle = true;
			}
			lastPoint = point;
			if (handle && tool) {
				called = tool._handleMouseEvent(type, event, point, mouse)
					|| called;
			}

			if (
				event.cancelable !== false
				&& (called && !mouse.move || mouse.down && responds('mouseup'))
			) {
				event.preventDefault();
			}
		},

		_handleKeyEvent: function(type, event, key, character) {
			var scope = this._scope,
				tool = scope.tool,
				keyEvent;

			function emit(obj) {
				if (obj.responds(type)) {
					paper = scope;
					obj.emit(type, keyEvent = keyEvent
							|| new KeyEvent(type, event, key, character));
				}
			}

			if (this.isVisible()) {
				emit(this);
				if (tool && tool.responds(type))
					emit(tool);
			}
		},

		_countItemEvent: function(type, sign) {
			var itemEvents = this._itemEvents,
				native = itemEvents.native,
				virtual = itemEvents.virtual;
			for (var key in itemEventsMap) {
				native[key] = (native[key] || 0)
						+ (itemEventsMap[key][type] || 0) * sign;
			}
			virtual[type] = (virtual[type] || 0) + sign;
		},

		statics: {
			updateFocus: updateFocus,

			_resetState: function() {
				dragging = mouseDown = called = wasInView = false;
				prevFocus = tempFocus = overView = downPoint = lastPoint =
					downItem = overItem = dragItem = clickItem = clickTime =
					dblClick = null;
			}
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof window.HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ Base.slice(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		var ctx = this._context = canvas.getContext('2d');
		ctx.save();
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(ctx,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
		this._needsUpdate = true;
	},

	remove: function remove() {
		this._context.restore();
		return remove.base.call(this);
	},

	_setElementSize: function _setElementSize(width, height) {
		var pixelRatio = this._pixelRatio;
		_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);
		if (pixelRatio !== 1) {
			var element = this._element,
				ctx = this._context;
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			ctx.restore();
			ctx.save();
			ctx.scale(pixelRatio, pixelRatio);
		}
	},

	getContext: function() {
		return this._context;
	},

	getPixelSize: function getPixelSize(size) {
		var agent = paper.agent,
			pixels;
		if (agent && agent.firefox) {
			pixels = getPixelSize.base.call(this, size);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		if (!this._needsUpdate)
			return false;
		var project = this._project,
			ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		if (project)
			project.draw(ctx, this._matrix, this._pixelRatio);
		this._needsUpdate = false;
		return true;
	}
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
		this.type = event && event.type;
	},

	prevented: false,
	stopped: false,

	preventDefault: function() {
		this.prevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.stopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getTimeStamp: function() {
		return this.event.timeStamp;
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(type, event, key, character) {
		this.type = type;
		this.event = event;
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	var keyLookup = {
			'\t': 'tab',
			' ': 'space',
			'\b': 'backspace',
			'\x7f': 'delete',
			'Spacebar': 'space',
			'Del': 'delete',
			'Win': 'meta',
			'Esc': 'escape'
		},

		charLookup = {
			'tab': '\t',
			'space': ' ',
			'enter': '\r'
		},

		keyMap = {},
		charMap = {},
		metaFixMap,
		downKey,

		modifiers = new Base({
			shift: false,
			control: false,
			alt: false,
			meta: false,
			capsLock: false,
			space: false
		}).inject({
			option: {
				get: function() {
					return this.alt;
				}
			},

			command: {
				get: function() {
					var agent = paper && paper.agent;
					return agent && agent.mac ? this.meta : this.control;
				}
			}
		});

	function getKey(event) {
		var key = event.key || event.keyIdentifier;
		key = /^U\+/.test(key)
				? String.fromCharCode(parseInt(key.substr(2), 16))
				: /^Arrow[A-Z]/.test(key) ? key.substr(5)
				: key === 'Unidentified'  || key === undefined
					? String.fromCharCode(event.keyCode)
					: key;
		return keyLookup[key] ||
				(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());
	}

	function handleKey(down, key, character, event) {
		var type = down ? 'keydown' : 'keyup',
			view = View._focused,
			name;
		keyMap[key] = down;
		if (down) {
			charMap[key] = character;
		} else {
			delete charMap[key];
		}
		if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {
			modifiers[name] = down;
			var agent = paper && paper.agent;
			if (name === 'meta' && agent && agent.mac) {
				if (down) {
					metaFixMap = {};
				} else {
					for (var k in metaFixMap) {
						if (k in charMap)
							handleKey(false, k, metaFixMap[k], event);
					}
					metaFixMap = null;
				}
			}
		} else if (down && metaFixMap) {
			metaFixMap[key] = character;
		}
		if (view) {
			view._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,
					character);
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var key = getKey(event),
				agent = paper && paper.agent;
			if (key.length > 1 || agent && (agent.chrome && (event.altKey
						|| agent.mac && event.metaKey
						|| !agent.mac && event.ctrlKey))) {
				handleKey(true, key,
						charLookup[key] || (key.length > 1 ? '' : key), event);
			} else {
				downKey = key;
			}
		},

		keypress: function(event) {
			if (downKey) {
				var key = getKey(event),
					code = event.charCode,
					character = code >= 32 ? String.fromCharCode(code)
						: key.length > 1 ? '' : key;
				if (key !== downKey) {
					key = character.toLowerCase();
				}
				handleKey(true, key, character, event);
				downKey = null;
			}
		},

		keyup: function(event) {
			var key = getKey(event);
			if (key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var key in charMap)
				handleKey(false, key, charMap[key], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		this.type = type;
		this.event = event;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return this.tool[/^mouse(down|up)$/.test(this.type)
				? '_downCount' : '_moveCount'];
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',
			'onKeyUp'],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._moveCount = -1;
		this._downCount = -1;
		this.set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_handleMouseEvent: function(type, event, point, mouse) {
		paper = this._scope;
		if (mouse.drag && !this.responds(type))
			type = 'mousemove';
		var move = mouse.move || mouse.drag,
			responds = this.responds(type),
			minDistance = this.minDistance,
			maxDistance = this.maxDistance,
			called = false,
			tool = this;
		function update(minDistance, maxDistance) {
			var pt = point,
				toolPoint = move ? tool._point : (tool._downPoint || pt);
			if (move) {
				if (tool._moveCount >= 0 && pt.equals(toolPoint)) {
					return false;
				}
				if (toolPoint && (minDistance != null || maxDistance != null)) {
					var vector = pt.subtract(toolPoint),
						distance = vector.getLength();
					if (distance < (minDistance || 0))
						return false;
					if (maxDistance) {
						pt = toolPoint.add(vector.normalize(
								Math.min(distance, maxDistance)));
					}
				}
				tool._moveCount++;
			}
			tool._point = pt;
			tool._lastPoint = toolPoint || pt;
			if (mouse.down) {
				tool._moveCount = -1;
				tool._downPoint = pt;
				tool._downCount++;
			}
			return true;
		}

		function emit() {
			if (responds) {
				called = tool.emit(type, new ToolEvent(tool, type, event))
						|| called;
			}
		}

		if (mouse.down) {
			update();
			emit();
		} else if (mouse.up) {
			update(null, maxDistance);
			emit();
		} else if (responds) {
			while (update(minDistance, maxDistance))
				emit();
		}
		return called;
	}

});

var Tween = Base.extend(Emitter, {
	_class: 'Tween',

	statics: {
		easings: {
			linear: function(t) {
				return t;
			},

			easeInQuad: function(t) {
				return t * t;
			},

			easeOutQuad: function(t) {
				return t * (2 - t);
			},

			easeInOutQuad: function(t) {
				return t < 0.5
					? 2 * t * t
					: -1 + 2 * (2 - t) * t;
			},

			easeInCubic: function(t) {
				return t * t * t;
			},

			easeOutCubic: function(t) {
				return --t * t * t + 1;
			},

			easeInOutCubic: function(t) {
				return t < 0.5
					? 4 * t * t * t
					: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
			},

			easeInQuart: function(t) {
				return t * t * t * t;
			},

			easeOutQuart: function(t) {
				return 1 - (--t) * t * t * t;
			},

			easeInOutQuart: function(t) {
				return t < 0.5
					? 8 * t * t * t * t
					: 1 - 8 * (--t) * t * t * t;
			},

			easeInQuint: function(t) {
				return t * t * t * t * t;
			},

			easeOutQuint: function(t) {
				return 1 + --t * t * t * t * t;
			},

			easeInOutQuint: function(t) {
				return t < 0.5
					? 16 * t * t * t * t * t
					: 1 + 16 * (--t) * t * t * t * t;
			}
		}
	},

	initialize: function Tween(object, from, to, duration, easing, start) {
		this.object = object;
		var type = typeof easing;
		var isFunction = type === 'function';
		this.type = isFunction
			? type
			: type === 'string'
				? easing
				: 'linear';
		this.easing = isFunction ? easing : Tween.easings[this.type];
		this.duration = duration;
		this.running = false;

		this._then = null;
		this._startTime = null;
		var state = from || to;
		this._keys = state ? Object.keys(state) : [];
		this._parsedKeys = this._parseKeys(this._keys);
		this._from = state && this._getState(from);
		this._to = state && this._getState(to);
		if (start !== false) {
			this.start();
		}
	},

	then: function(then) {
		this._then = then;
		return this;
	},

	start: function() {
		this._startTime = null;
		this.running = true;
		return this;
	},

	stop: function() {
		this.running = false;
		return this;
	},

	update: function(progress) {
		if (this.running) {
			if (progress > 1) {
				progress = 1;
				this.running = false;
			}

			var factor = this.easing(progress),
				keys = this._keys,
				getValue = function(value) {
					return typeof value === 'function'
						? value(factor, progress)
						: value;
				};
			for (var i = 0, l = keys && keys.length; i < l; i++) {
				var key = keys[i],
					from = getValue(this._from[key]),
					to = getValue(this._to[key]),
					value = (from && to && from.__add && to.__add)
						? to.__subtract(from).__multiply(factor).__add(from)
						: ((to - from) * factor) + from;
				this._setProperty(this._parsedKeys[key], value);
			}

			if (!this.running && this._then) {
				this._then(this.object);
			}
			if (this.responds('update')) {
				this.emit('update', new Base({
					progress: progress,
					factor: factor
				}));
			}
		}
		return this;
	},

	_events: {
		onUpdate: {}
	},

	_handleFrame: function(time) {
		var startTime = this._startTime,
			progress = startTime
				? (time - startTime) / this.duration
				: 0;
		if (!startTime) {
			this._startTime = time;
		}
		this.update(progress);
	},

	_getState: function(state) {
		var keys = this._keys,
			result = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = this._parsedKeys[key],
				current = this._getProperty(path),
				value;
			if (state) {
				var resolved = this._resolveValue(current, state[key]);
				this._setProperty(path, resolved);
				value = this._getProperty(path);
				value = value && value.clone ? value.clone() : value;
				this._setProperty(path, current);
			} else {
				value = current && current.clone ? current.clone() : current;
			}
			result[key] = value;
		}
		return result;
	},

	_resolveValue: function(current, value) {
		if (value) {
			if (Array.isArray(value) && value.length === 2) {
				var operator = value[0];
				return (
					operator &&
					operator.match &&
					operator.match(/^[+\-\*\/]=/)
				)
					? this._calculate(current, operator[0], value[1])
					: value;
			} else if (typeof value === 'string') {
				var match = value.match(/^[+\-*/]=(.*)/);
				if (match) {
					var parsed = JSON.parse(match[1].replace(
						/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
						'"$2": '
					));
					return this._calculate(current, value[0], parsed);
				}
			}
		}
		return value;
	},

	_calculate: function(left, operator, right) {
		return paper.PaperScript.calculateBinary(left, operator, right);
	},

	_parseKeys: function(keys) {
		var parsed = {};
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i],
				path = key
					.replace(/\.([^.]*)/g, '/$1')
					.replace(/\[['"]?([^'"\]]*)['"]?\]/g, '/$1');
			parsed[key] = path.split('/');
		}
		return parsed;
	},

	_getProperty: function(path, offset) {
		var obj = this.object;
		for (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {
			obj = obj[path[i]];
		}
		return obj;
	},

	_setProperty: function(path, value) {
		var dest = this._getProperty(path, 1);
		if (dest) {
			dest[path[path.length - 1]] = value;
		}
	}
});

var Http = {
	request: function(options) {
		var xhr = new self.XMLHttpRequest();
		xhr.open((options.method || 'get').toUpperCase(), options.url,
				Base.pick(options.async, true));
		if (options.mimeType)
			xhr.overrideMimeType(options.mimeType);
		xhr.onload = function() {
			var status = xhr.status;
			if (status === 0 || status === 200) {
				if (options.onLoad) {
					options.onLoad.call(xhr, xhr.responseText);
				}
			} else {
				xhr.onerror();
			}
		};
		xhr.onerror = function() {
			var status = xhr.status,
				message = 'Could not load "' + options.url + '" (Status: '
						+ status + ')';
			if (options.onError) {
				options.onError(message, status);
			} else {
				throw new Error(message);
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		if (!window)
			return null;
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
			clear = false;
		}
		var ctx = canvas.getContext('2d');
		if (!ctx) {
			throw new Error('Canvas ' + canvas +
					' is unable to provide a 2D context.');
		}
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		var canvas = this.getCanvas(width, height);
		return canvas ? canvas.getContext('2d') : null;
	},

	release: function(obj) {
		var canvas = obj && obj.canvas ? obj.canvas : obj;
		if (canvas && canvas.getContext) {
			canvas.getContext('2d').restore();
			this.canvases.push(canvas);
		}
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	if (ctx) {
		Base.each(modes, function(func, mode) {
			var darken = mode === 'darken',
				ok = false;
			ctx.save();
			try {
				ctx.fillStyle = darken ? '#300' : '#a00';
				ctx.fillRect(0, 0, 1, 1);
				ctx.globalCompositeOperation = mode;
				if (ctx.globalCompositeOperation === mode) {
					ctx.fillStyle = darken ? '#a00' : '#300';
					ctx.fillRect(0, 0, 1, 1);
					ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken
							? 170 : 51;
				}
			} catch (e) {}
			ctx.restore();
			nativeModes[mode] = ok;
		});
		CanvasProvider.release(ctx);
	}

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SvgElement = new function() {
	var svg = 'http://www.w3.org/2000/svg',
		xmlns = 'http://www.w3.org/2000/xmlns',
		xlink = 'http://www.w3.org/1999/xlink',
		attributeNamespace = {
			href: xlink,
			xlink: xmlns,
			xmlns: xmlns + '/',
			'xmlns:xlink': xmlns + '/'
		};

	function create(tag, attributes, formatter) {
		return set(document.createElementNS(svg, tag), attributes, formatter);
	}

	function get(node, name) {
		var namespace = attributeNamespace[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		return value === 'null' ? null : value;
	}

	function set(node, attributes, formatter) {
		for (var name in attributes) {
			var value = attributes[name],
				namespace = attributeNamespace[name];
			if (typeof value === 'number' && formatter)
				value = formatter.number(value);
			if (namespace) {
				node.setAttributeNS(namespace, name, value);
			} else {
				node.setAttribute(name, value);
			}
		}
		return node;
	}

	return {
		svg: svg,
		xmlns: xmlns,
		xlink: xlink,

		create: create,
		get: get,
		set: set
	};
};

var SvgStyles = Base.each({
	fillColor: ['fill', 'color'],
	fillRule: ['fill-rule', 'string'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'style']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

new function() {
	var formatter;

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			var point;
			if (matrix.isInvertible()) {
				matrix = matrix._shiftless();
				point = matrix._inverseTransform(trans);
				trans = null;
			} else {
				point = new Point();
			}
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling,
					skew = decomposed.skewing;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (skew.x)
					parts.push('skewX(' + formatter.number(skew.x) + ')');
				if (skew.y)
					parts.push('skewY(' + formatter.number(skew.y) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = SvgElement.create('g', attrs, formatter);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = SvgElement.create('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					SvgElement.set(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages == false && image && image.src
				|| item.toDataURL();
		return SvgElement.create('image', attrs, formatter);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			length = segments.length,
			type,
			attrs = getTransform(item._matrix);
		if (matchShapes && length >= 2 && !item.hasHandles()) {
			if (length > 2) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for (var i = 0; i < length; i++) {
					parts.push(formatter.point(segments[i]._point));
				}
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var start = segments[0]._point,
					end = segments[1]._point;
				attrs.set({
					x1: start.x,
					y1: start.y,
					x2: end.x,
					y2: end.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return SvgElement.create(type, attrs, formatter);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return SvgElement.create('path', attrs, formatter);
	}

	function exportSymbolItem(item, options) {
		var attrs = getTransform(item._matrix, true),
			definition = item._definition,
			node = getDefinition(definition, 'symbol'),
			definitionItem = definition._item,
			bounds = definitionItem.getStrokeBounds();
		if (!node) {
			node = SvgElement.create('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			node.appendChild(exportSVG(definitionItem, options));
			setDefinition(definition, node, 'symbol');
		}
		attrs.href = '#' + node.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = bounds.width;
		attrs.height = bounds.height;
		attrs.overflow = 'visible';
		return SvgElement.create('use', attrs, formatter);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin(),
				destination = color.getDestination(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = SvgElement.create((radial ? 'radial' : 'linear')
					+ 'Gradient', attrs, formatter);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha(),
					offset = stop._offset;
				attrs = {
					offset: offset == null ? i / (l - 1) : offset
				};
				if (stopColor)
					attrs['stop-color'] = stopColor.toCSS(true);
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(
						SvgElement.create('stop', attrs, formatter));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = SvgElement.create('text', getTransform(item._matrix, true),
				formatter);
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		SymbolItem: exportSymbolItem,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent(),
			style = [];

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SvgStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				if (type === 'style') {
					style.push(entry.attribute + ': ' + value);
				} else {
					attrs[entry.attribute] = value == null ? 'none'
							: type === 'color' ? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array' ? value.join(',')
							: type === 'lookup' ? entry.toSVG[value]
							: value;
				}
			}
		});

		if (style.length)
			attrs.style = style.join(';');

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return SvgElement.set(node, attrs, formatter);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-'
				+ (item._id || item.__id || (item.__id = UID.get('svg')))];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + typeId;
		definitions.svgs[type + '-' + (item._id || item.__id)] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = SvgElement.create('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(SvgElement.create('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new self.XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var children = this._children,
				view = this.getView(),
				bounds = Base.pick(options.bounds, 'view'),
				mx = options.matrix || bounds === 'view' && view._matrix,
				matrix = mx && Matrix.read([mx]),
				rect = bounds === 'view'
					? new Rectangle([0, 0], view.getViewSize())
					: bounds === 'content'
						? Item._getBounds(children, matrix, { stroke: true })
							.rect
						: Rectangle.read([bounds], 0, { readNull: true }),
				attrs = {
					version: '1.1',
					xmlns: SvgElement.svg,
					'xmlns:xlink': SvgElement.xlink,
				};
			if (rect) {
				attrs.width = rect.width;
				attrs.height = rect.height;
				if (rect.x || rect.x === 0 || rect.y || rect.y === 0)
					attrs.viewBox = formatter.rectangle(rect);
			}
			var node = SvgElement.create('svg', attrs, formatter),
				parent = node;
			if (matrix && !matrix.isIdentity()) {
				parent = node.appendChild(SvgElement.create('g',
						getTransform(matrix), formatter));
			}
			for (var i = 0, l = children.length; i < l; i++) {
				parent.appendChild(exportSVG(children[i], options, true));
			}
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	var definitions = {},
		rootSize;

	function getValue(node, name, isString, allowNull, allowPercent,
			defaultValue) {
		var value = SvgElement.get(node, name) || defaultValue,
			res = value == null
				? allowNull
					? null
					: isString ? '' : 0
				: isString
					? value
					: parseFloat(value);
		return /%\s*$/.test(value)
			? (res / 100) * (allowPercent ? 1
				: rootSize[/x|^width/.test(name) ? 'width' : 'height'])
			: res;
	}

	function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {
		x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
		y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull, allowPercent) {
		w = getValue(node, w || 'width', false, allowNull, allowPercent);
		h = getValue(node, h || 'height', false, allowNull, allowPercent);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none' ? null
				: type === 'number' ? parseFloat(value)
				: type === 'array' ?
					value ? value.split(/[\s,]+/g).map(parseFloat) : []
				: type === 'color' ? getDefinition(value) || value
				: type === 'lookup' ? lookup[value]
				: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			isDefs = type === 'defs',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip && !isDefs) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importNode(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& !/^defs$/i.test(childNode.nodeName)
					&& (child = importNode(childNode, options, false))
					&& !(child instanceof SymbolDefinition))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || isDefs) {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		return PathItem.create(node.getAttribute('d'));
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			radial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
			if (gradient._radial ^ radial) {
				gradient = gradient.clone();
				gradient._radial = radial;
			}
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, radial);
		}
		var origin, destination, highlight,
			scaleToBounds = getValue(node, 'gradientUnits', true) !==
				'userSpaceOnUse';
		if (radial) {
			origin = getPoint(node, 'cx', 'cy', false, scaleToBounds,
				'50%', '50%');
			destination = origin.add(
				getValue(node, 'r', false, false, scaleToBounds, '50%'), 0);
			highlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);
		} else {
			origin = getPoint(node, 'x1', 'y1', false, scaleToBounds,
				'0%', '0%');
			destination = getPoint(node, 'x2', 'y2', false, scaleToBounds,
				'100%', '0%');
		}
		var color = applyAttributes(
				new Color(gradient, origin, destination, highlight), node);
		color._scaleToBounds = scaleToBounds;
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					return importNode(child, options, isRoot);
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node);
				this.setSize(size);
				var center = getPoint(node).add(size.divide(2));
				this._matrix.append(new Matrix().translate(center));
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new SymbolDefinition(
					importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node);
			return definition
					? definition instanceof SymbolDefinition
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(
					getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			return new Shape.Rectangle(new Rectangle(
						getPoint(node),
						getSize(node)
					), getSize(node, 'rx', 'ry'));
			},

		line: function(node) {
			return new Path.Line(
					getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node).add(
					getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		},

		switch: importGroup
	};

	function applyTransform(item, value, name, node) {
		if (item.transform) {
			var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
				matrix = new Matrix();
			for (var i = 0, l = transforms.length; i < l; i++) {
				var transform = transforms[i];
				if (!transform)
					break;
				var parts = transform.split(/\(\s*/),
					command = parts[0],
					v = parts[1].split(/[\s,]+/g);
				for (var j = 0, m = v.length; j < m; j++)
					v[j] = parseFloat(v[j]);
				switch (command) {
				case 'matrix':
					matrix.append(
							new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
					break;
				case 'rotate':
					matrix.rotate(v[0], v[1] || 0, v[2] || 0);
					break;
				case 'translate':
					matrix.translate(v[0], v[1] || 0);
					break;
				case 'scale':
					matrix.scale(v);
					break;
				case 'skewX':
					matrix.skew(v[0], 0);
					break;
				case 'skewY':
					matrix.skew(0, v[0]);
					break;
				}
			}
			item.transform(matrix);
		}
	}

	function applyOpacity(item, value, name) {
		var key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',
			color = item[key] && item[key]();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SvgStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			if (item[entry.set]) {
				item[entry.set](convertValue(value, entry.type, entry.fromSVG));
				if (entry.type === 'color') {
					var color = item[entry.get]();
					if (color) {
						if (color._scaleToBounds) {
							var bounds = item.getBounds();
							color.transform(new Matrix()
								.translate(bounds.getPoint())
								.scale(bounds.getSize()));
						}
					}
				}
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			if (item.setVisible)
				item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			if (item.setVisible)
				item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			if (item.setOffset) {
				var percent = value.match(/(.*)%$/);
				item.setOffset(percent ? percent[1] / 100 : parseFloat(value));
			}
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, null, null, true),
				group,
				matrix;
			if (item instanceof Group) {
				var scale = size ? size.divide(rect.getSize()) : 1,
				matrix = new Matrix().scale(scale)
						.translate(rect.getPoint().negate());
				group = item;
			} else if (item instanceof SymbolDefinition) {
				if (size)
					rect.setSize(size);
				group = item._item;
			}
			if (group)  {
				if (getAttribute(node, 'overflow', styles) !== 'visible') {
					var clip = new Shape.Rectangle(rect);
					clip.setClipMask(true);
					group.addChild(clip);
				}
				if (matrix)
					group.transform(matrix);
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value && node.style) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value ? undefined
				: value === 'none' ? null
				: value;
	}

	function applyAttributes(item, node, isRoot) {
		var parent = node.parentNode,
			styles = {
				node: DomElement.getStyles(node) || {},
				parent: !isRoot && !/^defs$/i.test(parent.tagName)
						&& DomElement.getStyles(parent) || {}
			};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			item = value !== undefined
					&& apply(item, value, name, node, styles) || item;
		});
		return item;
	}

	function getDefinition(value) {
		var match = value && value.match(/\((?:["'#]*)([^"')]+)/),
			name = match && match[1],
			res = name && definitions[window
					? name.replace(window.location.href.split('#')[0] + '#', '')
					: name];
		if (res && res._scaleToBounds) {
			res = res.clone();
			res._scaleToBounds = true;
		}
		return res;
	}

	function importNode(node, options, isRoot) {
		var type = node.nodeName.toLowerCase(),
			isElement = type !== '#document',
			body = document.body,
			container,
			parent,
			next;
		if (isRoot && isElement) {
			rootSize = paper.getView().getSize();
			rootSize = getSize(node, null, null, true) || rootSize;
			container = SvgElement.create('svg', {
				style: 'stroke-width: 1px; stroke-miterlimit: 10'
			});
			parent = node.parentNode;
			next = node.nextSibling;
			container.appendChild(node);
			body.appendChild(container);
		}
		var settings = paper.settings,
			applyMatrix = settings.applyMatrix,
			insertItems = settings.insertItems;
		settings.applyMatrix = false;
		settings.insertItems = false;
		var importer = importers[type],
			item = importer && importer(node, type, options, isRoot) || null;
		settings.insertItems = insertItems;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (isElement && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport,
				data = isElement && node.getAttribute('data-paper-data');
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (container) {
			body.removeChild(container);
			if (parent) {
				if (next) {
					parent.insertBefore(node, next);
				} else {
					parent.appendChild(node);
				}
			}
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	function importSVG(source, options, owner) {
		if (!source)
			return null;
		options = typeof options === 'function' ? { onLoad: options }
				: options || {};
		var scope = paper,
			item = null;

		function onLoad(svg) {
			try {
				var node = typeof svg === 'object' ? svg : new self.DOMParser()
						.parseFromString(svg, 'image/svg+xml');
				if (!node.nodeName) {
					node = null;
					throw new Error('Unsupported SVG source: ' + source);
				}
				paper = scope;
				item = importNode(node, options, true);
				if (!options || options.insert !== false) {
					owner._insertItem(undefined, item);
				}
				var onLoad = options.onLoad;
				if (onLoad)
					onLoad(item, svg);
			} catch (e) {
				onError(e);
			}
		}

		function onError(message, status) {
			var onError = options.onError;
			if (onError) {
				onError(message, status);
			} else {
				throw new Error(message);
			}
		}

		if (typeof source === 'string' && !/^.*</.test(source)) {
			var node = document.getElementById(source);
			if (node) {
				onLoad(node);
			} else {
				Http.request({
					url: source,
					async: true,
					onLoad: onLoad,
					onError: onError
				});
			}
		} else if (typeof File !== 'undefined' && source instanceof File) {
			var reader = new FileReader();
			reader.onload = function() {
				onLoad(reader.result);
			};
			reader.onerror = function() {
				onError(reader.error);
			};
			return reader.readAsText(source);
		} else {
			onLoad(source);
		}

		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return importSVG(node, options, this);
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, this);
		}
	});
};

Base.exports.PaperScript = function() {
	var global = this,
		acorn = global.acorn;
	if (!acorn && "function" !== 'undefined') {
		try { acorn = __webpack_require__(/*! acorn */ "./node_modules/acorn/dist/acorn.mjs"); } catch(e) {}
	}
	if (!acorn) {
		var exports, module;
		acorn = exports = module = {};

(function(root, mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports);
  if (true) return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  mod(root.acorn || (root.acorn = {}));
})(this, function(exports) {
  "use strict";

  exports.version = "0.5.0";

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();
	return parseTopLevel(options.program);
  };

  var defaultOptions = exports.defaultOptions = {
	ecmaVersion: 5,
	strictSemicolons: false,
	allowTrailingCommas: true,
	forbidReserved: false,
	allowReturnOutsideFunction: false,
	locations: false,
	onComment: null,
	ranges: false,
	program: null,
	sourceFile: null,
	directSourceFile: null
  };

  function setOptions(opts) {
	options = opts || {};
	for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
	  options[opt] = defaultOptions[opt];
	sourceFile = options.sourceFile || null;
  }

  var getLineInfo = exports.getLineInfo = function(input, offset) {
	for (var line = 1, cur = 0;;) {
	  lineBreak.lastIndex = cur;
	  var match = lineBreak.exec(input);
	  if (match && match.index < offset) {
		++line;
		cur = match.index + match[0].length;
	  } else break;
	}
	return {line: line, column: offset - cur};
  };

  exports.tokenize = function(inpt, opts) {
	input = String(inpt); inputLen = input.length;
	setOptions(opts);
	initTokenState();

	var t = {};
	function getToken(forceRegexp) {
	  lastEnd = tokEnd;
	  readToken(forceRegexp);
	  t.start = tokStart; t.end = tokEnd;
	  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
	  t.type = tokType; t.value = tokVal;
	  return t;
	}
	getToken.jumpTo = function(pos, reAllowed) {
	  tokPos = pos;
	  if (options.locations) {
		tokCurLine = 1;
		tokLineStart = lineBreak.lastIndex = 0;
		var match;
		while ((match = lineBreak.exec(input)) && match.index < pos) {
		  ++tokCurLine;
		  tokLineStart = match.index + match[0].length;
		}
	  }
	  tokRegexpAllowed = reAllowed;
	  skipSpace();
	};
	return getToken;
  };

  var tokPos;

  var tokStart, tokEnd;

  var tokStartLoc, tokEndLoc;

  var tokType, tokVal;

  var tokRegexpAllowed;

  var tokCurLine, tokLineStart;

  var lastStart, lastEnd, lastEndLoc;

  var inFunction, labels, strict;

  function raise(pos, message) {
	var loc = getLineInfo(input, pos);
	message += " (" + loc.line + ":" + loc.column + ")";
	var err = new SyntaxError(message);
	err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
	throw err;
  }

  var empty = [];

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
					  "continue": _continue, "debugger": _debugger, "default": _default,
					  "do": _do, "else": _else, "finally": _finally, "for": _for,
					  "function": _function, "if": _if, "return": _return, "switch": _switch,
					  "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
					  "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
					  "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
					  "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
					  "void": {keyword: "void", prefix: true, beforeExpr: true},
					  "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true};
  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _logicalOR = {binop: 1, beforeExpr: true};
  var _logicalAND = {binop: 2, beforeExpr: true};
  var _bitwiseOR = {binop: 3, beforeExpr: true};
  var _bitwiseXOR = {binop: 4, beforeExpr: true};
  var _bitwiseAND = {binop: 5, beforeExpr: true};
  var _equality = {binop: 6, beforeExpr: true};
  var _relational = {binop: 7, beforeExpr: true};
  var _bitShift = {binop: 8, beforeExpr: true};
  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};
  var _multiplyModulo = {binop: 10, beforeExpr: true};

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
					  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
					  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
					  num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  function makePredicate(words) {
	words = words.split(" ");
	var f = "", cats = [];
	out: for (var i = 0; i < words.length; ++i) {
	  for (var j = 0; j < cats.length; ++j)
		if (cats[j][0].length == words[i].length) {
		  cats[j].push(words[i]);
		  continue out;
		}
	  cats.push([words[i]]);
	}
	function compareTo(arr) {
	  if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
	  f += "switch(str){";
	  for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
	  f += "return true}return false;";
	}

	if (cats.length > 3) {
	  cats.sort(function(a, b) {return b.length - a.length;});
	  f += "switch(str.length){";
	  for (var i = 0; i < cats.length; ++i) {
		var cat = cats[i];
		f += "case " + cat[0].length + ":";
		compareTo(cat);
	  }
	  f += "}";

	} else {
	  compareTo(words);
	}
	return new Function("str", f);
  }

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  var isStrictBadIdWord = makePredicate("eval arguments");

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  var newline = /[\n\r\u2028\u2029]/;

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
	if (code < 65) return code === 36;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
	if (code < 48) return code === 36;
	if (code < 58) return true;
	if (code < 65) return false;
	if (code < 91) return true;
	if (code < 97) return code === 95;
	if (code < 123)return true;
	return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  function line_loc_t() {
	this.line = tokCurLine;
	this.column = tokPos - tokLineStart;
  }

  function initTokenState() {
	tokCurLine = 1;
	tokPos = tokLineStart = 0;
	tokRegexpAllowed = true;
	skipSpace();
  }

  function finishToken(type, val) {
	tokEnd = tokPos;
	if (options.locations) tokEndLoc = new line_loc_t;
	tokType = type;
	skipSpace();
	tokVal = val;
	tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var start = tokPos, end = input.indexOf("*/", tokPos += 2);
	if (end === -1) raise(tokPos - 2, "Unterminated comment");
	tokPos = end + 2;
	if (options.locations) {
	  lineBreak.lastIndex = start;
	  var match;
	  while ((match = lineBreak.exec(input)) && match.index < tokPos) {
		++tokCurLine;
		tokLineStart = match.index + match[0].length;
	  }
	}
	if (options.onComment)
	  options.onComment(true, input.slice(start + 2, end), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
	var start = tokPos;
	var startLoc = options.onComment && options.locations && new line_loc_t;
	var ch = input.charCodeAt(tokPos+=2);
	while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	  ++tokPos;
	  ch = input.charCodeAt(tokPos);
	}
	if (options.onComment)
	  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
						startLoc, options.locations && new line_loc_t);
  }

  function skipSpace() {
	while (tokPos < inputLen) {
	  var ch = input.charCodeAt(tokPos);
	  if (ch === 32) {
		++tokPos;
	  } else if (ch === 13) {
		++tokPos;
		var next = input.charCodeAt(tokPos);
		if (next === 10) {
		  ++tokPos;
		}
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch === 10 || ch === 8232 || ch === 8233) {
		++tokPos;
		if (options.locations) {
		  ++tokCurLine;
		  tokLineStart = tokPos;
		}
	  } else if (ch > 8 && ch < 14) {
		++tokPos;
	  } else if (ch === 47) {
		var next = input.charCodeAt(tokPos + 1);
		if (next === 42) {
		  skipBlockComment();
		} else if (next === 47) {
		  skipLineComment();
		} else break;
	  } else if (ch === 160) {
		++tokPos;
	  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
		++tokPos;
	  } else {
		break;
	  }
	}
  }

  function readToken_dot() {
	var next = input.charCodeAt(tokPos + 1);
	if (next >= 48 && next <= 57) return readNumber(true);
	++tokPos;
	return finishToken(_dot);
  }

  function readToken_slash() {
	var next = input.charCodeAt(tokPos + 1);
	if (tokRegexpAllowed) {++tokPos; return readRegexp();}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_multiplyModulo, 1);
  }

  function readToken_pipe_amp(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);
  }

  function readToken_caret() {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_bitwiseXOR, 1);
  }

  function readToken_plus_min(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === code) {
	  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&
		  newline.test(input.slice(lastEnd, tokPos))) {
		tokPos += 3;
		skipLineComment();
		skipSpace();
		return readToken();
	  }
	  return finishOp(_incDec, 2);
	}
	if (next === 61) return finishOp(_assign, 2);
	return finishOp(_plusMin, 1);
  }

  function readToken_lt_gt(code) {
	var next = input.charCodeAt(tokPos + 1);
	var size = 1;
	if (next === code) {
	  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;
	  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
	  return finishOp(_bitShift, size);
	}
	if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&
		input.charCodeAt(tokPos + 3) == 45) {
	  tokPos += 4;
	  skipLineComment();
	  skipSpace();
	  return readToken();
	}
	if (next === 61)
	  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;
	return finishOp(_relational, size);
  }

  function readToken_eq_excl(code) {
	var next = input.charCodeAt(tokPos + 1);
	if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);
	return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
	switch(code) {
	case 46:
	  return readToken_dot();

	case 40: ++tokPos; return finishToken(_parenL);
	case 41: ++tokPos; return finishToken(_parenR);
	case 59: ++tokPos; return finishToken(_semi);
	case 44: ++tokPos; return finishToken(_comma);
	case 91: ++tokPos; return finishToken(_bracketL);
	case 93: ++tokPos; return finishToken(_bracketR);
	case 123: ++tokPos; return finishToken(_braceL);
	case 125: ++tokPos; return finishToken(_braceR);
	case 58: ++tokPos; return finishToken(_colon);
	case 63: ++tokPos; return finishToken(_question);

	case 48:
	  var next = input.charCodeAt(tokPos + 1);
	  if (next === 120 || next === 88) return readHexNumber();
	case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:
	  return readNumber(false);

	case 34: case 39:
	  return readString(code);

	case 47:
	  return readToken_slash(code);

	case 37: case 42:
	  return readToken_mult_modulo();

	case 124: case 38:
	  return readToken_pipe_amp(code);

	case 94:
	  return readToken_caret();

	case 43: case 45:
	  return readToken_plus_min(code);

	case 60: case 62:
	  return readToken_lt_gt(code);

	case 61: case 33:
	  return readToken_eq_excl(code);

	case 126:
	  return finishOp(_prefix, 1);
	}

	return false;
  }

  function readToken(forceRegexp) {
	if (!forceRegexp) tokStart = tokPos;
	else tokPos = tokStart + 1;
	if (options.locations) tokStartLoc = new line_loc_t;
	if (forceRegexp) return readRegexp();
	if (tokPos >= inputLen) return finishToken(_eof);

	var code = input.charCodeAt(tokPos);
	if (isIdentifierStart(code) || code === 92 ) return readWord();

	var tok = getTokenFromCode(code);

	if (tok === false) {
	  var ch = String.fromCharCode(code);
	  if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
	  raise(tokPos, "Unexpected character '" + ch + "'");
	}
	return tok;
  }

  function finishOp(type, size) {
	var str = input.slice(tokPos, tokPos + size);
	tokPos += size;
	finishToken(type, str);
  }

  function readRegexp() {
	var content = "", escaped, inClass, start = tokPos;
	for (;;) {
	  if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
	  var ch = input.charAt(tokPos);
	  if (newline.test(ch)) raise(start, "Unterminated regular expression");
	  if (!escaped) {
		if (ch === "[") inClass = true;
		else if (ch === "]" && inClass) inClass = false;
		else if (ch === "/" && !inClass) break;
		escaped = ch === "\\";
	  } else escaped = false;
	  ++tokPos;
	}
	var content = input.slice(start, tokPos);
	++tokPos;
	var mods = readWord1();
	if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
	try {
	  var value = new RegExp(content, mods);
	} catch (e) {
	  if (e instanceof SyntaxError) raise(start, e.message);
	  raise(e);
	}
	return finishToken(_regexp, value);
  }

  function readInt(radix, len) {
	var start = tokPos, total = 0;
	for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	  var code = input.charCodeAt(tokPos), val;
	  if (code >= 97) val = code - 97 + 10;
	  else if (code >= 65) val = code - 65 + 10;
	  else if (code >= 48 && code <= 57) val = code - 48;
	  else val = Infinity;
	  if (val >= radix) break;
	  ++tokPos;
	  total = total * radix + val;
	}
	if (tokPos === start || len != null && tokPos - start !== len) return null;

	return total;
  }

  function readHexNumber() {
	tokPos += 2;
	var val = readInt(16);
	if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
	return finishToken(_num, val);
  }

  function readNumber(startsWithDot) {
	var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
	if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
	if (input.charCodeAt(tokPos) === 46) {
	  ++tokPos;
	  readInt(10);
	  isFloat = true;
	}
	var next = input.charCodeAt(tokPos);
	if (next === 69 || next === 101) {
	  next = input.charCodeAt(++tokPos);
	  if (next === 43 || next === 45) ++tokPos;
	  if (readInt(10) === null) raise(start, "Invalid number");
	  isFloat = true;
	}
	if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

	var str = input.slice(start, tokPos), val;
	if (isFloat) val = parseFloat(str);
	else if (!octal || str.length === 1) val = parseInt(str, 10);
	else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
	else val = parseInt(str, 8);
	return finishToken(_num, val);
  }

  function readString(quote) {
	tokPos++;
	var out = "";
	for (;;) {
	  if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
	  var ch = input.charCodeAt(tokPos);
	  if (ch === quote) {
		++tokPos;
		return finishToken(_string, out);
	  }
	  if (ch === 92) {
		ch = input.charCodeAt(++tokPos);
		var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
		if (octal) octal = octal[0];
		while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);
		if (octal === "0") octal = null;
		++tokPos;
		if (octal) {
		  if (strict) raise(tokPos - 2, "Octal literal in strict mode");
		  out += String.fromCharCode(parseInt(octal, 8));
		  tokPos += octal.length - 1;
		} else {
		  switch (ch) {
		  case 110: out += "\n"; break;
		  case 114: out += "\r"; break;
		  case 120: out += String.fromCharCode(readHexChar(2)); break;
		  case 117: out += String.fromCharCode(readHexChar(4)); break;
		  case 85: out += String.fromCharCode(readHexChar(8)); break;
		  case 116: out += "\t"; break;
		  case 98: out += "\b"; break;
		  case 118: out += "\u000b"; break;
		  case 102: out += "\f"; break;
		  case 48: out += "\0"; break;
		  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;
		  case 10:
			if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
			break;
		  default: out += String.fromCharCode(ch); break;
		  }
		}
	  } else {
		if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, "Unterminated string constant");
		out += String.fromCharCode(ch);
		++tokPos;
	  }
	}
  }

  function readHexChar(len) {
	var n = readInt(16, len);
	if (n === null) raise(tokStart, "Bad character escape sequence");
	return n;
  }

  var containsEsc;

  function readWord1() {
	containsEsc = false;
	var word, first = true, start = tokPos;
	for (;;) {
	  var ch = input.charCodeAt(tokPos);
	  if (isIdentifierChar(ch)) {
		if (containsEsc) word += input.charAt(tokPos);
		++tokPos;
	  } else if (ch === 92) {
		if (!containsEsc) word = input.slice(start, tokPos);
		containsEsc = true;
		if (input.charCodeAt(++tokPos) != 117)
		  raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
		++tokPos;
		var esc = readHexChar(4);
		var escStr = String.fromCharCode(esc);
		if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
		if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
		  raise(tokPos - 4, "Invalid Unicode escape");
		word += escStr;
	  } else {
		break;
	  }
	  first = false;
	}
	return containsEsc ? word : input.slice(start, tokPos);
  }

  function readWord() {
	var word = readWord1();
	var type = _name;
	if (!containsEsc && isKeyword(word))
	  type = keywordTypes[word];
	return finishToken(type, word);
  }

  function next() {
	lastStart = tokStart;
	lastEnd = tokEnd;
	lastEndLoc = tokEndLoc;
	readToken();
  }

  function setStrict(strct) {
	strict = strct;
	tokPos = tokStart;
	if (options.locations) {
	  while (tokPos < tokLineStart) {
		tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
		--tokCurLine;
	  }
	}
	skipSpace();
	readToken();
  }

  function node_t() {
	this.type = null;
	this.start = tokStart;
	this.end = null;
  }

  function node_loc_t() {
	this.start = tokStartLoc;
	this.end = null;
	if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
	var node = new node_t();
	if (options.locations)
	  node.loc = new node_loc_t();
	if (options.directSourceFile)
	  node.sourceFile = options.directSourceFile;
	if (options.ranges)
	  node.range = [tokStart, 0];
	return node;
  }

  function startNodeFrom(other) {
	var node = new node_t();
	node.start = other.start;
	if (options.locations) {
	  node.loc = new node_loc_t();
	  node.loc.start = other.loc.start;
	}
	if (options.ranges)
	  node.range = [other.range[0], 0];

	return node;
  }

  function finishNode(node, type) {
	node.type = type;
	node.end = lastEnd;
	if (options.locations)
	  node.loc.end = lastEndLoc;
	if (options.ranges)
	  node.range[1] = lastEnd;
	return node;
  }

  function isUseStrict(stmt) {
	return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	  stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  function eat(type) {
	if (tokType === type) {
	  next();
	  return true;
	}
  }

  function canInsertSemicolon() {
	return !options.strictSemicolons &&
	  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  function semicolon() {
	if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  function expect(type) {
	if (tokType === type) next();
	else unexpected();
  }

  function unexpected() {
	raise(tokStart, "Unexpected token");
  }

  function checkLVal(expr) {
	if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
	  raise(expr.start, "Assigning to rvalue");
	if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
	  raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  function parseTopLevel(program) {
	lastStart = lastEnd = tokPos;
	if (options.locations) lastEndLoc = new line_loc_t;
	inFunction = strict = null;
	labels = [];
	readToken();

	var node = program || startNode(), first = true;
	if (!program) node.body = [];
	while (tokType !== _eof) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && isUseStrict(stmt)) setStrict(true);
	  first = false;
	}
	return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  function parseStatement() {
	if (tokType === _slash || tokType === _assign && tokVal == "/=")
	  readToken(true);

	var starttype = tokType, node = startNode();

	switch (starttype) {
	case _break: case _continue:
	  next();
	  var isBreak = starttype === _break;
	  if (eat(_semi) || canInsertSemicolon()) node.label = null;
	  else if (tokType !== _name) unexpected();
	  else {
		node.label = parseIdent();
		semicolon();
	  }

	  for (var i = 0; i < labels.length; ++i) {
		var lab = labels[i];
		if (node.label == null || lab.name === node.label.name) {
		  if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
		  if (node.label && isBreak) break;
		}
	  }
	  if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
	  return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	case _debugger:
	  next();
	  semicolon();
	  return finishNode(node, "DebuggerStatement");

	case _do:
	  next();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  expect(_while);
	  node.test = parseParenExpression();
	  semicolon();
	  return finishNode(node, "DoWhileStatement");

	case _for:
	  next();
	  labels.push(loopLabel);
	  expect(_parenL);
	  if (tokType === _semi) return parseFor(node, null);
	  if (tokType === _var) {
		var init = startNode();
		next();
		parseVar(init, true);
		finishNode(init, "VariableDeclaration");
		if (init.declarations.length === 1 && eat(_in))
		  return parseForIn(node, init);
		return parseFor(node, init);
	  }
	  var init = parseExpression(false, true);
	  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
	  return parseFor(node, init);

	case _function:
	  next();
	  return parseFunction(node, true);

	case _if:
	  next();
	  node.test = parseParenExpression();
	  node.consequent = parseStatement();
	  node.alternate = eat(_else) ? parseStatement() : null;
	  return finishNode(node, "IfStatement");

	case _return:
	  if (!inFunction && !options.allowReturnOutsideFunction)
		raise(tokStart, "'return' outside of function");
	  next();

	  if (eat(_semi) || canInsertSemicolon()) node.argument = null;
	  else { node.argument = parseExpression(); semicolon(); }
	  return finishNode(node, "ReturnStatement");

	case _switch:
	  next();
	  node.discriminant = parseParenExpression();
	  node.cases = [];
	  expect(_braceL);
	  labels.push(switchLabel);

	  for (var cur, sawDefault; tokType != _braceR;) {
		if (tokType === _case || tokType === _default) {
		  var isCase = tokType === _case;
		  if (cur) finishNode(cur, "SwitchCase");
		  node.cases.push(cur = startNode());
		  cur.consequent = [];
		  next();
		  if (isCase) cur.test = parseExpression();
		  else {
			if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
			cur.test = null;
		  }
		  expect(_colon);
		} else {
		  if (!cur) unexpected();
		  cur.consequent.push(parseStatement());
		}
	  }
	  if (cur) finishNode(cur, "SwitchCase");
	  next();
	  labels.pop();
	  return finishNode(node, "SwitchStatement");

	case _throw:
	  next();
	  if (newline.test(input.slice(lastEnd, tokStart)))
		raise(lastEnd, "Illegal newline after throw");
	  node.argument = parseExpression();
	  semicolon();
	  return finishNode(node, "ThrowStatement");

	case _try:
	  next();
	  node.block = parseBlock();
	  node.handler = null;
	  if (tokType === _catch) {
		var clause = startNode();
		next();
		expect(_parenL);
		clause.param = parseIdent();
		if (strict && isStrictBadIdWord(clause.param.name))
		  raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
		expect(_parenR);
		clause.guard = null;
		clause.body = parseBlock();
		node.handler = finishNode(clause, "CatchClause");
	  }
	  node.guardedHandlers = empty;
	  node.finalizer = eat(_finally) ? parseBlock() : null;
	  if (!node.handler && !node.finalizer)
		raise(node.start, "Missing catch or finally clause");
	  return finishNode(node, "TryStatement");

	case _var:
	  next();
	  parseVar(node);
	  semicolon();
	  return finishNode(node, "VariableDeclaration");

	case _while:
	  next();
	  node.test = parseParenExpression();
	  labels.push(loopLabel);
	  node.body = parseStatement();
	  labels.pop();
	  return finishNode(node, "WhileStatement");

	case _with:
	  if (strict) raise(tokStart, "'with' in strict mode");
	  next();
	  node.object = parseParenExpression();
	  node.body = parseStatement();
	  return finishNode(node, "WithStatement");

	case _braceL:
	  return parseBlock();

	case _semi:
	  next();
	  return finishNode(node, "EmptyStatement");

	default:
	  var maybeName = tokVal, expr = parseExpression();
	  if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
		for (var i = 0; i < labels.length; ++i)
		  if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
		var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
		labels.push({name: maybeName, kind: kind});
		node.body = parseStatement();
		labels.pop();
		node.label = expr;
		return finishNode(node, "LabeledStatement");
	  } else {
		node.expression = expr;
		semicolon();
		return finishNode(node, "ExpressionStatement");
	  }
	}
  }

  function parseParenExpression() {
	expect(_parenL);
	var val = parseExpression();
	expect(_parenR);
	return val;
  }

  function parseBlock(allowStrict) {
	var node = startNode(), first = true, strict = false, oldStrict;
	node.body = [];
	expect(_braceL);
	while (!eat(_braceR)) {
	  var stmt = parseStatement();
	  node.body.push(stmt);
	  if (first && allowStrict && isUseStrict(stmt)) {
		oldStrict = strict;
		setStrict(strict = true);
	  }
	  first = false;
	}
	if (strict && !oldStrict) setStrict(false);
	return finishNode(node, "BlockStatement");
  }

  function parseFor(node, init) {
	node.init = init;
	expect(_semi);
	node.test = tokType === _semi ? null : parseExpression();
	expect(_semi);
	node.update = tokType === _parenR ? null : parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForStatement");
  }

  function parseForIn(node, init) {
	node.left = init;
	node.right = parseExpression();
	expect(_parenR);
	node.body = parseStatement();
	labels.pop();
	return finishNode(node, "ForInStatement");
  }

  function parseVar(node, noIn) {
	node.declarations = [];
	node.kind = "var";
	for (;;) {
	  var decl = startNode();
	  decl.id = parseIdent();
	  if (strict && isStrictBadIdWord(decl.id.name))
		raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
	  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
	  node.declarations.push(finishNode(decl, "VariableDeclarator"));
	  if (!eat(_comma)) break;
	}
	return node;
  }

  function parseExpression(noComma, noIn) {
	var expr = parseMaybeAssign(noIn);
	if (!noComma && tokType === _comma) {
	  var node = startNodeFrom(expr);
	  node.expressions = [expr];
	  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
	  return finishNode(node, "SequenceExpression");
	}
	return expr;
  }

  function parseMaybeAssign(noIn) {
	var left = parseMaybeConditional(noIn);
	if (tokType.isAssign) {
	  var node = startNodeFrom(left);
	  node.operator = tokVal;
	  node.left = left;
	  next();
	  node.right = parseMaybeAssign(noIn);
	  checkLVal(left);
	  return finishNode(node, "AssignmentExpression");
	}
	return left;
  }

  function parseMaybeConditional(noIn) {
	var expr = parseExprOps(noIn);
	if (eat(_question)) {
	  var node = startNodeFrom(expr);
	  node.test = expr;
	  node.consequent = parseExpression(true);
	  expect(_colon);
	  node.alternate = parseExpression(true, noIn);
	  return finishNode(node, "ConditionalExpression");
	}
	return expr;
  }

  function parseExprOps(noIn) {
	return parseExprOp(parseMaybeUnary(), -1, noIn);
  }

  function parseExprOp(left, minPrec, noIn) {
	var prec = tokType.binop;
	if (prec != null && (!noIn || tokType !== _in)) {
	  if (prec > minPrec) {
		var node = startNodeFrom(left);
		node.left = left;
		node.operator = tokVal;
		var op = tokType;
		next();
		node.right = parseExprOp(parseMaybeUnary(), prec, noIn);
		var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? "LogicalExpression" : "BinaryExpression");
		return parseExprOp(exprNode, minPrec, noIn);
	  }
	}
	return left;
  }

  function parseMaybeUnary() {
	if (tokType.prefix) {
	  var node = startNode(), update = tokType.isUpdate;
	  node.operator = tokVal;
	  node.prefix = true;
	  tokRegexpAllowed = true;
	  next();
	  node.argument = parseMaybeUnary();
	  if (update) checkLVal(node.argument);
	  else if (strict && node.operator === "delete" &&
			   node.argument.type === "Identifier")
		raise(node.start, "Deleting local variable in strict mode");
	  return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	}
	var expr = parseExprSubscripts();
	while (tokType.postfix && !canInsertSemicolon()) {
	  var node = startNodeFrom(expr);
	  node.operator = tokVal;
	  node.prefix = false;
	  node.argument = expr;
	  checkLVal(expr);
	  next();
	  expr = finishNode(node, "UpdateExpression");
	}
	return expr;
  }

  function parseExprSubscripts() {
	return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
	if (eat(_dot)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseIdent(true);
	  node.computed = false;
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (eat(_bracketL)) {
	  var node = startNodeFrom(base);
	  node.object = base;
	  node.property = parseExpression();
	  node.computed = true;
	  expect(_bracketR);
	  return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
	} else if (!noCalls && eat(_parenL)) {
	  var node = startNodeFrom(base);
	  node.callee = base;
	  node.arguments = parseExprList(_parenR, false);
	  return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
	} else return base;
  }

  function parseExprAtom() {
	switch (tokType) {
	case _this:
	  var node = startNode();
	  next();
	  return finishNode(node, "ThisExpression");
	case _name:
	  return parseIdent();
	case _num: case _string: case _regexp:
	  var node = startNode();
	  node.value = tokVal;
	  node.raw = input.slice(tokStart, tokEnd);
	  next();
	  return finishNode(node, "Literal");

	case _null: case _true: case _false:
	  var node = startNode();
	  node.value = tokType.atomValue;
	  node.raw = tokType.keyword;
	  next();
	  return finishNode(node, "Literal");

	case _parenL:
	  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
	  next();
	  var val = parseExpression();
	  val.start = tokStart1;
	  val.end = tokEnd;
	  if (options.locations) {
		val.loc.start = tokStartLoc1;
		val.loc.end = tokEndLoc;
	  }
	  if (options.ranges)
		val.range = [tokStart1, tokEnd];
	  expect(_parenR);
	  return val;

	case _bracketL:
	  var node = startNode();
	  next();
	  node.elements = parseExprList(_bracketR, true, true);
	  return finishNode(node, "ArrayExpression");

	case _braceL:
	  return parseObj();

	case _function:
	  var node = startNode();
	  next();
	  return parseFunction(node, false);

	case _new:
	  return parseNew();

	default:
	  unexpected();
	}
  }

  function parseNew() {
	var node = startNode();
	next();
	node.callee = parseSubscripts(parseExprAtom(), true);
	if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
	else node.arguments = empty;
	return finishNode(node, "NewExpression");
  }

  function parseObj() {
	var node = startNode(), first = true, sawGetSet = false;
	node.properties = [];
	next();
	while (!eat(_braceR)) {
	  if (!first) {
		expect(_comma);
		if (options.allowTrailingCommas && eat(_braceR)) break;
	  } else first = false;

	  var prop = {key: parsePropertyName()}, isGetSet = false, kind;
	  if (eat(_colon)) {
		prop.value = parseExpression(true);
		kind = prop.kind = "init";
	  } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
				 (prop.key.name === "get" || prop.key.name === "set")) {
		isGetSet = sawGetSet = true;
		kind = prop.kind = prop.key.name;
		prop.key = parsePropertyName();
		if (tokType !== _parenL) unexpected();
		prop.value = parseFunction(startNode(), false);
	  } else unexpected();

	  if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
		for (var i = 0; i < node.properties.length; ++i) {
		  var other = node.properties[i];
		  if (other.key.name === prop.key.name) {
			var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
			  kind === "init" && (other.kind === "get" || other.kind === "set");
			if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
			if (conflict) raise(prop.key.start, "Redefinition of property");
		  }
		}
	  }
	  node.properties.push(prop);
	}
	return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
	if (tokType === _num || tokType === _string) return parseExprAtom();
	return parseIdent(true);
  }

  function parseFunction(node, isStatement) {
	if (tokType === _name) node.id = parseIdent();
	else if (isStatement) unexpected();
	else node.id = null;
	node.params = [];
	var first = true;
	expect(_parenL);
	while (!eat(_parenR)) {
	  if (!first) expect(_comma); else first = false;
	  node.params.push(parseIdent());
	}

	var oldInFunc = inFunction, oldLabels = labels;
	inFunction = true; labels = [];
	node.body = parseBlock(true);
	inFunction = oldInFunc; labels = oldLabels;

	if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
	  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
		var id = i < 0 ? node.id : node.params[i];
		if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
		  raise(id.start, "Defining '" + id.name + "' in strict mode");
		if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
		  raise(id.start, "Argument name clash in strict mode");
	  }
	}

	return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  function parseExprList(close, allowTrailingComma, allowEmpty) {
	var elts = [], first = true;
	while (!eat(close)) {
	  if (!first) {
		expect(_comma);
		if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
	  } else first = false;

	  if (allowEmpty && tokType === _comma) elts.push(null);
	  else elts.push(parseExpression(true));
	}
	return elts;
  }

  function parseIdent(liberal) {
	var node = startNode();
	if (liberal && options.forbidReserved == "everywhere") liberal = false;
	if (tokType === _name) {
	  if (!liberal &&
		  (options.forbidReserved &&
		   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||
		   strict && isStrictReservedWord(tokVal)) &&
		  input.slice(tokStart, tokEnd).indexOf("\\") == -1)
		raise(tokStart, "The keyword '" + tokVal + "' is reserved");
	  node.name = tokVal;
	} else if (liberal && tokType.keyword) {
	  node.name = tokType.keyword;
	} else {
	  unexpected();
	}
	tokRegexpAllowed = false;
	next();
	return finishNode(node, "Identifier");
  }

});

		if (!acorn.version)
			acorn = null;
	}

	function parse(code, options) {
		return (global.acorn || acorn).parse(code, options);
	}

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': '__equals',
		'!=': '__equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': '__self'
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{
			__self: function() {
				return this;
			}
		}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code, options) {
		if (!code)
			return '';
		options = options || {};

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range' || key === 'loc')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (node.prefix) {
							str = '(' + str + ')';
						} else if (
							parentType === 'AssignmentExpression' ||
							parentType === 'VariableDeclarator' ||
							parentType === 'BinaryExpression'
						) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right),
								exp = left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')';
							replaceCode(node, /^\(.*\)$/.test(getCode(node))
									? '(' + exp + ')' : exp);
						}
					}
				}
				break;
			case 'ExportDefaultDeclaration':
				replaceCode({
					range: [node.start, node.declaration.start]
				}, 'module.exports = ');
				break;
			case 'ExportNamedDeclaration':
				var declaration = node.declaration;
				var specifiers = node.specifiers;
				if (declaration) {
					var declarations = declaration.declarations;
					if (declarations) {
						declarations.forEach(function(dec) {
							replaceCode(dec, 'module.exports.' + getCode(dec));
						});
						replaceCode({
							range: [
								node.start,
								declaration.start + declaration.kind.length
							]
						}, '');
					}
				} else if (specifiers) {
					var exports = specifiers.map(function(specifier) {
						var name = getCode(specifier);
						return 'module.exports.' + name + ' = ' + name + '; ';
					}).join('');
					if (exports) {
						replaceCode(node, exports);
					}
				}
				break;
			}
		}

		function encodeVLQ(value) {
			var res = '',
				base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
			value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);
			while (value || !res) {
				var next = value & (32 - 1);
				value >>= 5;
				if (value)
					next |= 32;
				res += base64[next];
			}
			return res;
		}

		var url = options.url || '',
			agent = paper.agent,
			version = agent.versionNumber,
			offsetCode = false,
			sourceMaps = options.sourceMaps,
			source = options.source || code,
			lineBreaks = /\r\n|\n|\r/mg,
			offset = options.offset || 0,
			map;
		if (sourceMaps && (agent.chrome && version >= 30
				|| agent.webkit && version >= 537.76
				|| agent.firefox && version >= 23
				|| agent.node)) {
			if (agent.node) {
				offset -= 2;
			} else if (window && url && !window.location.href.indexOf(url)) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			offsetCode = offset > 0 && !(
					agent.chrome && version >= 36 ||
					agent.safari && version >= 600 ||
					agent.firefox && version >= 40 ||
					agent.node);
			var mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];
			mappings.length = (code.match(lineBreaks) || []).length + 1
					+ (offsetCode ? offset : 0);
			map = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url],
				sourcesContent: [source]
			};
		}
		walkAST(parse(code, {
			ranges: true,
			preserveParens: true,
			sourceType: 'module'
		}));
		if (map) {
			if (offsetCode) {
				code = new Array(offset + 1).join('\n') + code;
			}
			if (/^(inline|both)$/.test(sourceMaps)) {
				code += "\n//# sourceMappingURL=data:application/json;base64,"
						+ self.btoa(unescape(encodeURIComponent(
							JSON.stringify(map))));
			}
			code += "\n//# sourceURL=" + (url || 'paperscript');
		}
		return {
			url: url,
			source: source,
			code: code,
			map: map
		};
	}

	function execute(code, scope, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/
					.test(code) && !/\bnew\s+Tool\b/.test(code)
						? new Tool() : null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func,
			compiled = typeof code === 'object' ? code : compile(code, options);
		code = compiled.code;
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, tool: tool },
				true);
		expose(scope);
		code = 'var module = { exports: {} }; ' + code;
		var exports = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push('module.exports.' + key + ' = ' + key + ';');
			}
		}, []).join('\n');
		if (exports) {
			code += '\n' + exports;
		}
		code += '\nreturn module.exports;';
		var agent = paper.agent;
		if (document && (agent.chrome
				|| agent.firefox && agent.versionNumber < 40)) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (agent.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'document.__paperscript__ = function(' + params + ') {' +
					code +
				'\n}'
			));
			head.appendChild(script);
			func = document.__paperscript__;
			delete document.__paperscript__;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var exports = func && func.apply(scope, args);
		var obj = exports || {};
		Base.each(toolHandlers, function(key) {
			var value = obj[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (obj.onResize)
				view.setOnResize(obj.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (obj.onFrame)
				view.setOnFrame(obj.onFrame);
			view.requestUpdate();
		}
		return exports;
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request({
					url: src,
					async: async,
					mimeType: 'text/plain',
					onLoad: function(code) {
						execute(code, scope, src);
					}
				});
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document && document.getElementsByTagName('script'),
				loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (window) {
		if (document.readyState === 'complete') {
			setTimeout(loadAll);
		} else {
			DomEvent.add(window, { load: loadAll });
		}
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse,
		calculateBinary: __$__,
		calculateUnary: $__
	};

}.call(this);

var paper = new (PaperScope.inject(Base.exports, {
	Base: Base,
	Numerical: Numerical,
	Key: Key,
	DomEvent: DomEvent,
	DomElement: DomElement,
	document: document,
	window: window,
	Symbol: SymbolDefinition,
	PlacedSymbol: SymbolItem
}))();

if (paper.agent.node) {
	__webpack_require__(/*! ./node/extend.js */ 1)(paper);
}

if (true) {
	!(__WEBPACK_AMD_DEFINE_FACTORY__ = (paper),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

return paper;
}.call(this, typeof self === 'object' ? self : null);


/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/randomcolor/randomColor.js":
/*!*************************************************!*\
  !*** ./node_modules/randomcolor/randomColor.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {// randomColor by David Merfield under the CC0 license
// https://github.com/davidmerfield/randomColor/

;(function(root, factory) {

  // Support CommonJS
  if (true) {
    var randomColor = factory();

    // Support NodeJS & Component, which allow module.exports to be a function
    if ( true && module && module.exports) {
      exports = module.exports = randomColor;
    }

    // Support CommonJS 1.1.1 spec
    exports.randomColor = randomColor;

  // Support AMD
  } else {}

}(this, function() {

  // Seed to get repeatable colors
  var seed = null;

  // Shared color dictionary
  var colorDictionary = {};

  // Populate the color dictionary
  loadColorBounds();

  // check if a range is taken
  var colorRanges = [];

  var randomColor = function (options) {

    options = options || {};

    // Check if there is a seed and ensure it's an
    // integer. Otherwise, reset the seed value.
    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
      seed = options.seed;

    // A string was passed as a seed
    } else if (typeof options.seed === 'string') {
      seed = stringToInteger(options.seed);

    // Something was passed as a seed but it wasn't an integer or string
    } else if (options.seed !== undefined && options.seed !== null) {
      throw new TypeError('The seed value must be an integer or string');

    // No seed, reset the value outside.
    } else {
      seed = null;
    }

    var H,S,B;

    // Check if we need to generate multiple colors
    if (options.count !== null && options.count !== undefined) {

      var totalColors = options.count,
          colors = [];
      // Value false at index i means the range i is not taken yet.
      for (var i = 0; i < options.count; i++) {
        colorRanges.push(false)
        }
      options.count = null;

      while (totalColors > colors.length) {

        // Since we're generating multiple colors,
        // incremement the seed. Otherwise we'd just
        // generate the same color each time...
        if (seed && options.seed) options.seed += 1;

        colors.push(randomColor(options));
      }

      options.count = totalColors;

      return colors;
    }

    // First we pick a hue (H)
    H = pickHue(options);

    // Then use H to determine saturation (S)
    S = pickSaturation(H, options);

    // Then use S and H to determine brightness (B).
    B = pickBrightness(H, S, options);

    // Then we return the HSB color in the desired format
    return setFormat([H,S,B], options);
  };

  function pickHue(options) {
    if (colorRanges.length > 0) {
      var hueRange = getRealHueRange(options.hue)

      var hue = randomWithin(hueRange)

      //Each of colorRanges.length ranges has a length equal approximatelly one step
      var step = (hueRange[1] - hueRange[0]) / colorRanges.length

      var j = parseInt((hue - hueRange[0]) / step)

      //Check if the range j is taken
      if (colorRanges[j] === true) {
        j = (j + 2) % colorRanges.length
      }
      else {
        colorRanges[j] = true
           }

      var min = (hueRange[0] + j * step) % 359,
          max = (hueRange[0] + (j + 1) * step) % 359;

      hueRange = [min, max]

      hue = randomWithin(hueRange)

      if (hue < 0) {hue = 360 + hue;}
      return hue
    }
    else {
      var hueRange = getHueRange(options.hue)

      hue = randomWithin(hueRange);
      // Instead of storing red as two seperate ranges,
      // we group them, using negative numbers
      if (hue < 0) {
        hue = 360 + hue;
      }

      return hue;
    }
  }

  function pickSaturation (hue, options) {

    if (options.hue === 'monochrome') {
      return 0;
    }

    if (options.luminosity === 'random') {
      return randomWithin([0,100]);
    }

    var saturationRange = getSaturationRange(hue);

    var sMin = saturationRange[0],
        sMax = saturationRange[1];

    switch (options.luminosity) {

      case 'bright':
        sMin = 55;
        break;

      case 'dark':
        sMin = sMax - 10;
        break;

      case 'light':
        sMax = 55;
        break;
   }

    return randomWithin([sMin, sMax]);

  }

  function pickBrightness (H, S, options) {

    var bMin = getMinimumBrightness(H, S),
        bMax = 100;

    switch (options.luminosity) {

      case 'dark':
        bMax = bMin + 20;
        break;

      case 'light':
        bMin = (bMax + bMin)/2;
        break;

      case 'random':
        bMin = 0;
        bMax = 100;
        break;
    }

    return randomWithin([bMin, bMax]);
  }

  function setFormat (hsv, options) {

    switch (options.format) {

      case 'hsvArray':
        return hsv;

      case 'hslArray':
        return HSVtoHSL(hsv);

      case 'hsl':
        var hsl = HSVtoHSL(hsv);
        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';

      case 'hsla':
        var hslColor = HSVtoHSL(hsv);
        var alpha = options.alpha || Math.random();
        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';

      case 'rgbArray':
        return HSVtoRGB(hsv);

      case 'rgb':
        var rgb = HSVtoRGB(hsv);
        return 'rgb(' + rgb.join(', ') + ')';

      case 'rgba':
        var rgbColor = HSVtoRGB(hsv);
        var alpha = options.alpha || Math.random();
        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';

      default:
        return HSVtoHex(hsv);
    }

  }

  function getMinimumBrightness(H, S) {

    var lowerBounds = getColorInfo(H).lowerBounds;

    for (var i = 0; i < lowerBounds.length - 1; i++) {

      var s1 = lowerBounds[i][0],
          v1 = lowerBounds[i][1];

      var s2 = lowerBounds[i+1][0],
          v2 = lowerBounds[i+1][1];

      if (S >= s1 && S <= s2) {

         var m = (v2 - v1)/(s2 - s1),
             b = v1 - m*s1;

         return m*S + b;
      }

    }

    return 0;
  }

  function getHueRange (colorInput) {

    if (typeof parseInt(colorInput) === 'number') {

      var number = parseInt(colorInput);

      if (number < 360 && number > 0) {
        return [number, number];
      }

    }

    if (typeof colorInput === 'string') {

      if (colorDictionary[colorInput]) {
        var color = colorDictionary[colorInput];
        if (color.hueRange) {return color.hueRange;}
      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorInput)[0];
        return [ hue, hue ];
      }
    }

    return [0,360];

  }

  function getSaturationRange (hue) {
    return getColorInfo(hue).saturationRange;
  }

  function getColorInfo (hue) {

    // Maps red colors to make picking hue easier
    if (hue >= 334 && hue <= 360) {
      hue-= 360;
    }

    for (var colorName in colorDictionary) {
       var color = colorDictionary[colorName];
       if (color.hueRange &&
           hue >= color.hueRange[0] &&
           hue <= color.hueRange[1]) {
          return colorDictionary[colorName];
       }
    } return 'Color not found';
  }

  function randomWithin (range) {
    if (seed === null) {
      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/
      var golden_ratio = 0.618033988749895
      var r=Math.random()
      r += golden_ratio
      r %= 1
      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));
    } else {
      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/
      var max = range[1] || 1;
      var min = range[0] || 0;
      seed = (seed * 9301 + 49297) % 233280;
      var rnd = seed / 233280.0;
      return Math.floor(min + rnd * (max - min));
}
  }

  function HSVtoHex (hsv){

    var rgb = HSVtoRGB(hsv);

    function componentToHex(c) {
        var hex = c.toString(16);
        return hex.length == 1 ? '0' + hex : hex;
    }

    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);

    return hex;

  }

  function defineColor (name, hueRange, lowerBounds) {

    var sMin = lowerBounds[0][0],
        sMax = lowerBounds[lowerBounds.length - 1][0],

        bMin = lowerBounds[lowerBounds.length - 1][1],
        bMax = lowerBounds[0][1];

    colorDictionary[name] = {
      hueRange: hueRange,
      lowerBounds: lowerBounds,
      saturationRange: [sMin, sMax],
      brightnessRange: [bMin, bMax]
    };

  }

  function loadColorBounds () {

    defineColor(
      'monochrome',
      null,
      [[0,0],[100,0]]
    );

    defineColor(
      'red',
      [-26,18],
      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]
    );

    defineColor(
      'orange',
      [19,46],
      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]
    );

    defineColor(
      'yellow',
      [47,62],
      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]
    );

    defineColor(
      'green',
      [63,178],
      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]
    );

    defineColor(
      'blue',
      [179, 257],
      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]
    );

    defineColor(
      'purple',
      [258, 282],
      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]
    );

    defineColor(
      'pink',
      [283, 334],
      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]
    );

  }

  function HSVtoRGB (hsv) {

    // this doesn't work for the values of 0 and 360
    // here's the hacky fix
    var h = hsv[0];
    if (h === 0) {h = 1;}
    if (h === 360) {h = 359;}

    // Rebase the h,s,v values
    h = h/360;
    var s = hsv[1]/100,
        v = hsv[2]/100;

    var h_i = Math.floor(h*6),
      f = h * 6 - h_i,
      p = v * (1 - s),
      q = v * (1 - f*s),
      t = v * (1 - (1 - f)*s),
      r = 256,
      g = 256,
      b = 256;

    switch(h_i) {
      case 0: r = v; g = t; b = p;  break;
      case 1: r = q; g = v; b = p;  break;
      case 2: r = p; g = v; b = t;  break;
      case 3: r = p; g = q; b = v;  break;
      case 4: r = t; g = p; b = v;  break;
      case 5: r = v; g = p; b = q;  break;
    }

    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
    return result;
  }

  function HexToHSB (hex) {
    hex = hex.replace(/^#/, '');
    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;

    var red = parseInt(hex.substr(0, 2), 16) / 255,
          green = parseInt(hex.substr(2, 2), 16) / 255,
          blue = parseInt(hex.substr(4, 2), 16) / 255;

    var cMax = Math.max(red, green, blue),
          delta = cMax - Math.min(red, green, blue),
          saturation = cMax ? (delta / cMax) : 0;

    switch (cMax) {
      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];
      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];
      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];
    }
  }

  function HSVtoHSL (hsv) {
    var h = hsv[0],
      s = hsv[1]/100,
      v = hsv[2]/100,
      k = (2-s)*v;

    return [
      h,
      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,
      k/2 * 100
    ];
  }

  function stringToInteger (string) {
    var total = 0
    for (var i = 0; i !== string.length; i++) {
      if (total >= Number.MAX_SAFE_INTEGER) break;
      total += string.charCodeAt(i)
    }
    return total
  }

  // get The range of given hue when options.count!=0
  function getRealHueRange(colorHue)
  { if (!isNaN(colorHue)) {
    var number = parseInt(colorHue);

    if (number < 360 && number > 0) {
      return getColorInfo(colorHue).hueRange
    }
  }
    else if (typeof colorHue === 'string') {

      if (colorDictionary[colorHue]) {
        var color = colorDictionary[colorHue];

        if (color.hueRange) {
          return color.hueRange
       }
    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
        var hue = HexToHSB(colorHue)[0]
        return getColorInfo(hue).hueRange
    }
  }

    return [0,360]
}
  return randomColor;
}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/socket.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(/*! ./url */ "./node_modules/socket.io-client/lib/url.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  }
  return io.socket(parsed.path, opts);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(/*! ./manager */ "./node_modules/socket.io-client/lib/manager.js");
exports.Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");


/***/ }),

/***/ "./node_modules/socket.io-client/lib/manager.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/lib/manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(/*! engine.io-client */ "./node_modules/engine.io-client/lib/index.js");
var Socket = __webpack_require__(/*! ./socket */ "./node_modules/socket.io-client/lib/socket.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('socket.io-client:manager');
var indexOf = __webpack_require__(/*! indexof */ "./node_modules/indexof/index.js");
var Backoff = __webpack_require__(/*! backo2 */ "./node_modules/backo2/index.js");

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  var _parser = opts.parser || parser;
  this.encoder = new _parser.Encoder();
  this.decoder = new _parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.generateId(nsp);
    }
  }
};

/**
 * generate `socket.id` for the given `nsp`
 *
 * @param {String} nsp
 * @return {String}
 * @api private
 */

Manager.prototype.generateId = function (nsp) {
  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.generateId(nsp);
    });

    if (this.autoConnect) {
      // manually call here since connecting event is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/on.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-client/lib/on.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),

/***/ "./node_modules/socket.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js");
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var toArray = __webpack_require__(/*! to-array */ "./node_modules/to-array/index.js");
var on = __webpack_require__(/*! ./on */ "./node_modules/socket.io-client/lib/on.js");
var bind = __webpack_require__(/*! component-bind */ "./node_modules/component-bind/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('socket.io-client:socket');
var parseqs = __webpack_require__(/*! parseqs */ "./node_modules/parseqs/index.js");
var hasBin = __webpack_require__(/*! has-binary2 */ "./node_modules/has-binary2/index.js");

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.flags = {};
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var packet = {
    type: (this.flags.binary !== undefined ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
    data: args
  };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  this.flags = {};

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;
      debug('sending connect packet with query %s', query);
      this.packet({type: parser.CONNECT, query: query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  var sameNamespace = packet.nsp === this.nsp;
  var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === '/';

  if (!sameNamespace && !rootNamespaceError) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    self.packet({
      type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags.compress = compress;
  return this;
};

/**
 * Sets the binary flag
 *
 * @param {Boolean} whether the emitted data contains binary
 * @return {Socket} self
 * @api public
 */

Socket.prototype.binary = function (binary) {
  this.flags.binary = binary;
  return this;
};


/***/ }),

/***/ "./node_modules/socket.io-client/lib/url.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io-client/lib/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(/*! parseuri */ "./node_modules/parseuri/index.js");
var debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js")('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || (typeof location !== 'undefined' && location);
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/component-emitter/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/component-emitter/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/isarray/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/isarray/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/ms/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(/*! isarray */ "./node_modules/socket.io-client/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js");
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
var withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (isBuf(data)) {
    var placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === 'object' && !(data instanceof Date)) {
    var newData = {};
    for (var key in data) {
      newData[key] = _deconstructPacket(data[key], buffers);
    }
    return newData;
  }
  return data;
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful
  return packet;
};

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === 'object') {
    for (var key in data) {
      data[key] = _reconstructPacket(data[key], buffers);
    }
  }

  return data;
}

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js")('socket.io-parser');
var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/socket.io-client/node_modules/component-emitter/index.js");
var binary = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-client/node_modules/socket.io-parser/binary.js");
var isArray = __webpack_require__(/*! isarray */ "./node_modules/socket.io-client/node_modules/isarray/index.js");
var isBuf = __webpack_require__(/*! ./is-buffer */ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js");

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

var ERROR_PACKET = exports.ERROR + '"encode error"';

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    encodeAsBinary(obj, callback);
  } else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {

  // first is type
  var str = '' + obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
    str += obj.attachments + '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' !== obj.nsp) {
    str += obj.nsp + ',';
  }

  // immediately followed by the id
  if (null != obj.id) {
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    var payload = tryStringify(obj.data);
    if (payload !== false) {
      str += payload;
    } else {
      return ERROR_PACKET;
    }
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

function tryStringify(str) {
  try {
    return JSON.stringify(str);
  } catch(e){
    return false;
  }
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an encoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if (typeof obj === 'string') {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  } else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  } else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var i = 0;
  // look up type
  var p = {
    type: Number(str.charAt(0))
  };

  if (null == exports.types[p.type]) {
    return error('unknown packet type ' + p.type);
  }

  // look up attachments if type binary
  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
    var buf = '';
    while (str.charAt(++i) !== '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) !== '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' === str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' === c) break;
      p.nsp += c;
      if (i === str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i === str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    var payload = tryParse(str.substr(i));
    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));
    if (isPayloadValid) {
      p.data = payload;
    } else {
      return error('invalid payload');
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch(e){
    return false;
  }
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(msg) {
  return {
    type: exports.ERROR,
    data: 'parser error: ' + msg
  };
}


/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {
module.exports = isBuf;

var withNativeBuffer = typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function';
var withNativeArrayBuffer = typeof ArrayBuffer === 'function';

var isView = function (obj) {
  return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : (obj.buffer instanceof ArrayBuffer);
};

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (withNativeBuffer && Buffer.isBuffer(obj)) ||
          (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',
  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',
  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',
  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',
  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',
  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',
  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',
  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',
  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',
  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',
  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/debug/src/debug.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io-client/node_modules/ms/index.js");

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy () {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/to-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/to-array/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var randomcolor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! randomcolor */ "./node_modules/randomcolor/randomColor.js");
/* harmony import */ var randomcolor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(randomcolor__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var animejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! animejs */ "./node_modules/animejs/lib/anime.es.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! paper */ "./node_modules/paper/dist/paper-full.js");
/* harmony import */ var paper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(paper__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-client */ "./node_modules/socket.io-client/lib/index.js");
/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(socket_io_client__WEBPACK_IMPORTED_MODULE_3__);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





var server = 'https://speakinggg-server.herokuapp.com/';
var socket = socket_io_client__WEBPACK_IMPORTED_MODULE_3___default.a.connect(server);

var emit = function emit(event) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (socket.connected) {
    socket.emit.apply(socket, [event].concat(args));
  } else {
    console.log('socket disconnected... Waiting for connection established.');
    socket.on('connect', function () {
      console.log('this.socket reconnected. Emitting...');
      socket.socket.connect();
      socket.emit.apply(socket, [event].concat(args));
    });
  }
};

var sendMessage = function sendMessage(message) {
  emit('message new', message);
};

var last = function last(array) {
  return array[array.length - 1];
};

var colorsArray = function colorsArray(nb) {
  var array = [];

  for (var i = 0; i < nb; i++) {
    array.push(randomcolor__WEBPACK_IMPORTED_MODULE_0___default()());
  }

  return array;
};

var random = function random(min, max) {
  var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // min and max included
  var result = Math.random() * (max - min + 1) + min;
  return round ? Math.floor(result) : result;
};

var PaperApp =
/*#__PURE__*/
function () {
  function PaperApp(container, word) {
    _classCallCheck(this, PaperApp);

    this.container = container;
    this.word = word;
    this.init();
  }

  _createClass(PaperApp, [{
    key: "init",
    value: function init() {
      paper__WEBPACK_IMPORTED_MODULE_2___default.a.setup(this.container);
      this.vw = window.innerWidth / 100;
      this.tool = new paper__WEBPACK_IMPORTED_MODULE_2__["Tool"]();
      this.path = new paper__WEBPACK_IMPORTED_MODULE_2__["Path"]();
      this.points = this.word.length;
      this.length = this.word.length;
      this.start = new paper__WEBPACK_IMPORTED_MODULE_2___default.a.Point(paper__WEBPACK_IMPORTED_MODULE_2___default.a.view.center._x / 2, paper__WEBPACK_IMPORTED_MODULE_2___default.a.view.center._y / 2);
      this.tool.onMouseMove = this.onMouseMove.bind(this);
      this.tool.activate();
    }
  }, {
    key: "update",
    value: function update(word) {
      this.word = word;
      this.points = this.word.length;
      this.length = this.word.length;
      this.path = new paper__WEBPACK_IMPORTED_MODULE_2__["Path"]();
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      paper__WEBPACK_IMPORTED_MODULE_2__["project"].clear();

      for (var i = 0; i < this.points; i++) {
        this.path.add(new paper__WEBPACK_IMPORTED_MODULE_2___default.a.Point(this.start.x + this.length * i, this.start.y));
      }

      this.path.firstSegment.point = event ? event.point : this.start;

      for (var _i = 0; _i < this.points - 1; _i++) {
        var segment = this.path.segments[_i];
        var nextSegment = segment.next;
        var vector = new paper__WEBPACK_IMPORTED_MODULE_2___default.a.Point(segment.point.x - nextSegment.point.x, segment.point.y - nextSegment.point.y);
        vector.length = length;
        nextSegment.point = new paper__WEBPACK_IMPORTED_MODULE_2___default.a.Point(segment.point.x - vector.x, segment.point.y - vector.y);
      }

      this.path.strokeColor = '#fff';
      this.path.smooth({
        type: 'continuous'
      });

      if (window.innerWidth <= 900) {
        this.alignedText(this.word, this.path, {
          fontSize: this.vw * 6,
          fontFamily: 'Open Sans'
        });
      } else {
        this.alignedText(this.word, this.path, {
          fontSize: this.vw * 8,
          fontFamily: 'Open Sans'
        });
      }
    }
  }, {
    key: "pointText",
    value: function pointText(str, style) {
      var text = new paper__WEBPACK_IMPORTED_MODULE_2__["PointText"]();
      text.content = str;
      text.fillColor = '#fff';
      text.blendMode = 'difference';

      if (style) {
        if (style.font) text.font = style.font;
        if (style.fontFamily) text.fontFamily = style.fontFamily;
        if (style.fontSize) text.fontSize = style.fontSize;
        if (style.fontWeight) text.fontWeight = style.fontWeight;
      }

      return text;
    }
  }, {
    key: "alignedText",
    value: function alignedText(str, path, style) {
      if (str && str.length > 0 && path) {
        // create PointText object for each glyph
        var glyphTexts = [];

        for (var i = 0; i < str.length; i++) {
          glyphTexts[i] = this.pointText(str.substring(i, i + 1), style);
          glyphTexts[i].justification = 'center';
        } // for each glyph find center xOffset


        var xOffsets = [0];

        for (var _i2 = 1; _i2 < str.length; _i2++) {
          var pairText = this.pointText(str.substring(_i2 - 1, _i2 + 1), style); // pairText.remove()

          xOffsets[_i2] = xOffsets[_i2 - 1] + pairText.bounds.width + glyphTexts[_i2 - 1].bounds.width / 2 - glyphTexts[_i2].bounds.width / 2;
        } // set point for each glyph and rotate glyph around the point


        for (var _i3 = 0; _i3 < str.length; _i3++) {
          var centerOffs = xOffsets[_i3];

          if (path.length < centerOffs) {
            if (path.closed) {
              centerOffs = centerOffs % path.length;
            } else {
              centerOffs = undefined;
            }
          }

          if (centerOffs === undefined) {
            glyphTexts[_i3].remove();
          } else {
            var pathPoint = path.getPointAt(centerOffs);
            glyphTexts[_i3].point = pathPoint;
            var tan = path.getTangentAt(centerOffs);

            glyphTexts[_i3].rotate(tan.angle, pathPoint);
          }
        }
      }
    }
  }]);

  return PaperApp;
}();

var Recognition =
/*#__PURE__*/
function () {
  function Recognition(langSelector, historyContainer, speechContainer, paperContainer, bbContainer) {
    _classCallCheck(this, Recognition);

    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition || window.mozSpeechRecognition || window.msSpeechRecognition || window.oSpeechRecognition;

    if (window.SpeechRecognition) {
      this.speechContainer = speechContainer;
      this.paperContainer = paperContainer;
      this.historyContainer = historyContainer;
      this.bbContainer = bbContainer;
      this.langSelector = langSelector;
      this.lang = langSelector.value;
      this.init();
    }
  }

  _createClass(Recognition, [{
    key: "init",
    value: function init() {
      this.recognition = new SpeechRecognition(); // this.recognition.continuous = false;

      this.recognition.interimResult = true;
      this.recognition.lang = this.lang;
      this.log = [];
      this.paper = new PaperApp(this.paperContainer, this.speechContainer.innerHTML);
      this.text();
      var bb = ['./assets/bb1.svg', './assets/bb2.svg', './assets/bb3.svg', './assets/bb4.svg'];
      this.bbContainer.style.backgroundImage = "url('".concat(bb[Math.floor(Math.random() * bb.length)], "')");
      this.events();
    }
  }, {
    key: "text",
    value: function text(word) {
      animejs__WEBPACK_IMPORTED_MODULE_1__["default"].timeline({
        easing: 'easeInOutSine',
        duration: 400
      }).add({
        targets: this.speechContainer,
        opacity: 0
      }).add({
        targets: this.speechContainer,
        opacity: 1
      });
      word = word ? word : this.speechContainer.innerHTML;

      if (word.length <= 24) {
        var text = new Blotter.Text(word, {
          family: 'Open Sans',
          size: window.innerWidth / 100 * word.length * (word.length > 10 ? 0.2 : 0.8),
          fill: '#fff',
          paddingLeft: 40,
          paddingRight: 40
        });
        var material = new Blotter.LiquidDistortMaterial();
        material.uniforms.uVolatility.value = animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(0.04, 0.2);
        material.uniforms.uSeed.value = animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(0.2, 0.4);
        var blotter = new Blotter(material, {
          texts: text
        });
        var scope = blotter.forText(text);
        blotter.needsUpdate = true;
        this.speechContainer.innerHTML = '';
        scope.appendTo(this.speechContainer);
      } else {
        this.speechContainer.innerHTML = word;
      }
    }
  }, {
    key: "events",
    value: function events() {
      var _this = this;

      this.onLangChange();
      this.onResult();
      this.onEnd();
      this.start();
      this.onKey();
      socket.on('connect', function (e) {
        return console.log(e);
      });
      socket.on('messages update', function (_ref) {
        var messages = _ref.messages;
        console.log(messages);
      });
      socket.on('message new', function (_ref2) {
        var message = _ref2.message,
            messages = _ref2.messages;
        console.log(messages, message);

        if (_this.log.length < messages.length) {
          messages.forEach(function (m) {
            return _this.updateLog(m, false);
          });
        }
      });
    }
  }, {
    key: "onKey",
    value: function onKey() {
      var _this2 = this;

      window.addEventListener('keydown', function (e) {
        if (e.keyCode === 32) {
          _this2.clearLog();
        }
      });
    }
  }, {
    key: "onLangChange",
    value: function onLangChange() {
      var _this3 = this;

      this.langSelector.addEventListener('change', function (e) {
        _this3.lang = e.target.value;
        _this3.recognition.lang = _this3.lang;
      });
    }
  }, {
    key: "onResult",
    value: function onResult() {
      var _this4 = this;

      this.recognition.addEventListener('result', function (e) {
        _this4.updateLog(e);

        var message = last(_this4.log).transcript;
        sendMessage(message);

        _this4.updateSpeech(message);
      });
    }
  }, {
    key: "onEnd",
    value: function onEnd() {
      this.recognition.addEventListener('end', this.start.bind(this));
    }
  }, {
    key: "start",
    value: function start() {
      this.recognition.start();
    }
  }, {
    key: "clearLog",
    value: function clearLog() {
      this.log = [last(this.log)];
      this.historyContainer.innerHTML = '';
      this.appendToHistory(last(this.log));
    }
  }, {
    key: "updateLog",
    value: function updateLog(e) {
      var isCompletedData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var data;

      if (isCompletedData) {
        var results = Array.from(e.results).map(function (r) {
          return r[0];
        });
        data = {
          lang: this.lang,
          timeStamp: e.timeStamp,
          confidence: results.map(function (r) {
            return r.confidence;
          }),
          transcript: results.map(function (r) {
            return r.transcript;
          }).join()
        };
      } else {
        data = {
          timeStamp: e.created,
          transcript: e.text
        };
      }

      this.log.push(data);
      this.appendToHistory(data);
      console.clear();
      console.table(this.log);
    }
  }, {
    key: "updateSpeech",
    value: function updateSpeech(sentences) {
      this.text(sentences);
      this.paper.update(sentences);
    }
  }, {
    key: "appendToHistory",
    value: function appendToHistory(data) {
      var p = document.createElement('p');
      p.innerHTML = data.transcript;
      p.setAttribute('title', data.transcript);
      Object(animejs__WEBPACK_IMPORTED_MODULE_1__["default"])({
        targets: p,
        top: "".concat(animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(10, 90), "%"),
        left: "".concat(animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(10, 90), "%"),
        translateX: '-50%',
        translateY: '-50%',
        fontSize: "".concat(animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(0.8, 2.2), "rem"),
        opacity: animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(0.1, 0.4),
        rotate: animejs__WEBPACK_IMPORTED_MODULE_1__["default"].random(0, 360)
      });
      this.historyContainer.append(p);
    }
  }]);

  return Recognition;
}();

var Waveform =
/*#__PURE__*/
function () {
  function Waveform(sound, container) {
    var _this5 = this;

    _classCallCheck(this, Waveform);

    this.sound = sound;
    this.container = container;
    this.config = {
      spectrumColors: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
        count: 512,
        hue: 'blue'
      }),
      bgColors: {
        red: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'red'
        }),
        orange: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'orange'
        }),
        yellow: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'yellow'
        }),
        green: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'green'
        }),
        blue: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'blue'
        }),
        purple: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'purple'
        }),
        pink: randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
          count: 3,
          hue: 'pink'
        })
      },
      borderHeight: 0
    };
    Object.keys(this.config.bgColors).forEach(function (bg) {
      var div = document.createElement('div');
      div.classList.add('app__waveform__bg', "bg--".concat(bg));
      div.style.background = "linear-gradient(-60deg, ".concat(_this5.config.bgColors[bg].join(' ,'), ")");
      div.style.opacity = bg === 'blue' ? 1 : 0;

      _this5.container.appendChild(div);
    });
    this.canvas = document.createElement('canvas');
    this.canvas.width = 512;
    this.canvas.height = 300;
    this.container.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    window.addEventListener('resize', this.resize.bind(this), false);
    this.resize();
  }

  _createClass(Waveform, [{
    key: "updateConfig",
    value: function updateConfig(hue) {
      if (hue === undefined) {
        hue = 'blue';
      }

      this.config.spectrumColors = randomcolor__WEBPACK_IMPORTED_MODULE_0___default()({
        count: 512,
        hue: hue
      });
      var bg = this.container.querySelector(".bg--".concat(hue));
      var rest = this.container.querySelectorAll(".app__waveform__bg");
      animejs__WEBPACK_IMPORTED_MODULE_1__["default"].timeline({
        easing: 'easeInOutSine',
        duration: 400
      }).add({
        targets: rest,
        opacity: 0
      }).add({
        targets: bg,
        opacity: 1
      }, 0);
    }
  }, {
    key: "resize",
    value: function resize() {
      this.canvas.width = window.innerWidth;
    }
  }, {
    key: "draw",
    value: function draw() {
      var spectrum = this.sound.getSpectrum();
      var waveform = this.sound.getWaveform();
      this.config = _objectSpread({}, this.config, {
        spectrum: spectrum,
        waveform: waveform,
        spectrumLength: spectrum.length,
        waveformLength: waveform.length
      });
      this.background();
      this.spectrum();
      this.waveform(); // draw frequency
      // this.ctx.beginPath();
      // this.ctx.font = '10px Arial';
      // this.ctx.textBaseline = 'middle';
      // this.ctx.textAlign = 'left';
      // for (let i = 0, len = spectrumLength; i < len; i++) {
      //   if (i % 10 == 0) {
      //     this.ctx.rect(
      //       i * spectrumWidth,
      //       spectrumHeight,
      //       spectrumWidth / 2,
      //       borderHeight
      //     );
      //     this.ctx.fillText(
      //       i,
      //       i * spectrumWidth + 4,
      //       spectrumHeight + borderHeight * 0.5
      //     );
      //   }
      // }
      // this.ctx.fillStyle = '#ffffff';
      // this.ctx.fill();
      // draw time
      // this.ctx.beginPath();
      // this.ctx.textAlign = 'right';
      // this.ctx.textBaseline = 'top';
      // this.ctx.font = '15px Arial';
      // this.ctx.fillStyle = '#ffffff';
      // this.ctx.fillText(
      //   Math.round(this.sound.time * 10) / 10 +
      //     ' / ' +
      //     Math.round(this.sound.duration * 10) / 10,
      //   this.canvas.width - 5,
      //   5
      // );
    }
  }, {
    key: "background",
    value: function background() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.beginPath();
      this.ctx.rect(0, 0, this.canvas.width, this.canvas.height);
    }
  }, {
    key: "spectrum",
    value: function spectrum() {
      var _this6 = this;

      var _this$config = this.config,
          spectrum = _this$config.spectrum,
          spectrumLength = _this$config.spectrumLength,
          spectrumColors = _this$config.spectrumColors,
          borderHeight = _this$config.borderHeight;
      var spectrumWidth = this.canvas.width / spectrumLength;
      var spectrumHeight = this.canvas.height - borderHeight;
      var spectrumValue = null;
      spectrum.forEach(function (s, i) {
        _this6.ctx.beginPath();

        spectrumValue = s / 256;

        _this6.ctx.rect(i * spectrumWidth, spectrumHeight - spectrumHeight * spectrumValue, spectrumWidth / 2, spectrumHeight * spectrumValue);

        _this6.ctx.fillStyle = spectrumColors[i];

        _this6.ctx.fill();
      });
    }
  }, {
    key: "waveform",
    value: function waveform() {
      var _this7 = this;

      var _this$config2 = this.config,
          waveform = _this$config2.waveform,
          waveformLength = _this$config2.waveformLength,
          borderHeight = _this$config2.borderHeight;
      var waveformWidth = this.canvas.width / waveformLength;
      var waveformHeight = this.canvas.height - borderHeight;
      var waveformValue = null;
      this.ctx.beginPath();
      waveform.forEach(function (w, i) {
        waveformValue = w / 256;
        if (i == 0) _this7.ctx.moveTo(i * waveformWidth, waveformHeight * waveformValue);else _this7.ctx.lineTo(i * waveformWidth, waveformHeight * waveformValue);
      });
      this.ctx.strokeStyle = '#0000ff';
      this.ctx.stroke();
    }
  }]);

  return Waveform;
}();

var AudioProcessing =
/*#__PURE__*/
function () {
  function AudioProcessing(stream, volumeContainer, noteContainer, waveformContainer) {
    _classCallCheck(this, AudioProcessing);

    this.volumeContainer = volumeContainer;
    this.noteContainer = noteContainer;
    this.waveform = new Waveform(this, waveformContainer);
    this.audioContext = new AudioContext();
    this.analyser = this.audioContext.createAnalyser();
    this.micInput = this.audioContext.createMediaStreamSource(stream);
    this.scriptProcessor = this.audioContext.createScriptProcessor(2048, 1, 1);
    this.analyser.smoothingTimeConstant = 0.8;
    this.analyser.fftSize = 512;
    this.micInput.connect(this.analyser);
    this.analyser.connect(this.scriptProcessor);
    this.scriptProcessor.connect(this.audioContext.destination);
    this.scriptProcessor.onaudioprocess = this.audioProcess.bind(this);
  }

  _createClass(AudioProcessing, [{
    key: "audioProcess",
    value: function audioProcess() {
      var streamData = new Uint8Array(this.analyser.frequencyBinCount);
      this.analyser.getByteFrequencyData(streamData);
      var average = this.getAverageVolume(streamData);
      this.volumeContainer.innerHTML = average;
      this.waveform.draw();
      var note = this.getNoteFromPitch(this.getNoteNbFromPitch(average));
      this.noteContainer.innerHTML = note ? note : '';
      var hue = this.getHueFromNote(note);
      this.waveform.updateConfig(hue);
    }
  }, {
    key: "getSpectrum",
    value: function getSpectrum() {
      var streamData = new Uint8Array(this.analyser.frequencyBinCount);
      this.analyser.getByteFrequencyData(streamData);
      return streamData;
    }
  }, {
    key: "getWaveform",
    value: function getWaveform() {
      var streamData = new Uint8Array(this.analyser.frequencyBinCount);
      this.analyser.getByteTimeDomainData(streamData);
      return streamData;
    }
  }, {
    key: "getFrequency",
    value: function getFrequency(freq) {
      var endFreq = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sum = 0;
      var spectrum = this.getSpectrum();

      if (endFreq !== undefined) {
        for (var i = freq; i <= endFreq; i++) {
          sum += spectrum[i];
        }

        return sum / (endFreq - freq + 1);
      } else {
        return spectrum[freq];
      }
    }
  }, {
    key: "getAverageVolume",
    value: function getAverageVolume(frequencies) {
      var values = 0;
      frequencies.forEach(function (v) {
        return values += v;
      });
      var average = values / frequencies.length;
      return average;
    }
  }, {
    key: "getNoteNbFromPitch",
    value: function getNoteNbFromPitch(frequency) {
      var noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
      return Math.round(noteNum) + 69;
    }
  }, {
    key: "getNoteFromPitch",
    value: function getNoteFromPitch(noteNb) {
      var notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      return notes[noteNb % 12];
    }
  }, {
    key: "getHueFromNote",
    value: function getHueFromNote(note) {
      var hue = {
        C: 'red',
        'C#': 'red',
        D: 'orange',
        'D#': 'orange',
        E: 'yellow',
        F: 'green',
        'F#': 'green',
        G: 'blue',
        'G#': 'blue',
        A: 'purple',
        'A#': 'purple',
        B: 'pink'
      };
      return hue[note];
    }
  }, {
    key: "getFrequencyFromNoteNumber",
    value: function getFrequencyFromNoteNumber(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }
  }, {
    key: "getCentsOffFromPitch",
    value: function getCentsOffFromPitch(frequency, note) {
      return Math.floor(1200 * Math.log(frequency / this.frequencyFromNoteNumber(note)) / Math.log(2));
    }
  }]);

  return AudioProcessing;
}();

var App =
/*#__PURE__*/
function () {
  function App(app) {
    _classCallCheck(this, App);

    this.root = document.querySelector(app);
    this.els = {
      speechContainer: this.root.querySelector("".concat(app, "__speech")),
      bbContainer: this.root.querySelector("".concat(app, "__bb")),
      paperContainer: this.root.querySelector("".concat(app, "__paper")),
      historyContainer: this.root.querySelector("".concat(app, "__history")),
      langContainer: this.root.querySelector("".concat(app, "__lang select")),
      volumeContainer: this.root.querySelector("".concat(app, "__volume")),
      noteContainer: this.root.querySelector("".concat(app, "__note")),
      waveformContainer: this.root.querySelector("".concat(app, "__waveform"))
    };
    this.init();
    window.addEventListener('mousedown', function (e) {// navigator.mediaDevices.getDisplayMedia().catch(e => console.log(e))
    });
  }

  _createClass(App, [{
    key: "init",
    value: function init() {
      var _this8 = this;

      navigator.mediaDevices.getUserMedia({
        audio: true
      }).then(function (stream) {
        _this8.initRecognition();

        _this8.initAudioProcessing(stream);
      })["catch"](function (e) {
        return console.log(e);
      });
    }
  }, {
    key: "initRecognition",
    value: function initRecognition() {
      this.recognition = new Recognition(this.els.langContainer, this.els.historyContainer, this.els.speechContainer, this.els.paperContainer, this.els.bbContainer);
    }
  }, {
    key: "initAudioProcessing",
    value: function initAudioProcessing(stream) {
      this.audioProcessing = new AudioProcessing(stream, this.els.volumeContainer, this.els.noteContainer, this.els.waveformContainer);
    }
  }]);

  return App;
}();

window.onload = function () {
  window.app = new App('.app');
  setTimeout(function () {
    Object(animejs__WEBPACK_IMPORTED_MODULE_1__["default"])({
      targets: document.querySelector('.app__overlay'),
      easing: 'easeOutSine',
      opacity: 0,
      scale: 0
    });
  }, 4000);
};

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** ./node/self.js (ignored) ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************************!*\
  !*** ./node/extend.js (ignored) ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fjb3JuL2Rpc3QvYWNvcm4ubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hZnRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5pbWVqcy9saWIvYW5pbWUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNrbzIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1pbmhlcml0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeTIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5kZXhvZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2Vxcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tY29sb3IvcmFuZG9tQ29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9iaW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaXMtYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3llYXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZS9zZWxmLmpzIChpZ25vcmVkKSIsIndlYnBhY2s6Ly8vLi9ub2RlL2V4dGVuZC5qcyAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vL3dzIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJzZXJ2ZXIiLCJzb2NrZXQiLCJpbyIsImNvbm5lY3QiLCJlbWl0IiwiZXZlbnQiLCJhcmdzIiwiY29ubmVjdGVkIiwiY29uc29sZSIsImxvZyIsIm9uIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwibGFzdCIsImFycmF5IiwibGVuZ3RoIiwiY29sb3JzQXJyYXkiLCJuYiIsImkiLCJwdXNoIiwicmFuZG9tQ29sb3IiLCJyYW5kb20iLCJtaW4iLCJtYXgiLCJyb3VuZCIsInJlc3VsdCIsIk1hdGgiLCJmbG9vciIsIlBhcGVyQXBwIiwiY29udGFpbmVyIiwid29yZCIsImluaXQiLCJwYXBlciIsInNldHVwIiwidnciLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwidG9vbCIsIlRvb2wiLCJwYXRoIiwiUGF0aCIsInBvaW50cyIsInN0YXJ0IiwiUG9pbnQiLCJ2aWV3IiwiY2VudGVyIiwiX3giLCJfeSIsIm9uTW91c2VNb3ZlIiwiYmluZCIsImFjdGl2YXRlIiwicHJvamVjdCIsImNsZWFyIiwiYWRkIiwieCIsInkiLCJmaXJzdFNlZ21lbnQiLCJwb2ludCIsInNlZ21lbnQiLCJzZWdtZW50cyIsIm5leHRTZWdtZW50IiwibmV4dCIsInZlY3RvciIsInN0cm9rZUNvbG9yIiwic21vb3RoIiwidHlwZSIsImFsaWduZWRUZXh0IiwiZm9udFNpemUiLCJmb250RmFtaWx5Iiwic3RyIiwic3R5bGUiLCJ0ZXh0IiwiUG9pbnRUZXh0IiwiY29udGVudCIsImZpbGxDb2xvciIsImJsZW5kTW9kZSIsImZvbnQiLCJmb250V2VpZ2h0IiwiZ2x5cGhUZXh0cyIsInBvaW50VGV4dCIsInN1YnN0cmluZyIsImp1c3RpZmljYXRpb24iLCJ4T2Zmc2V0cyIsInBhaXJUZXh0IiwiYm91bmRzIiwid2lkdGgiLCJjZW50ZXJPZmZzIiwiY2xvc2VkIiwidW5kZWZpbmVkIiwicmVtb3ZlIiwicGF0aFBvaW50IiwiZ2V0UG9pbnRBdCIsInRhbiIsImdldFRhbmdlbnRBdCIsInJvdGF0ZSIsImFuZ2xlIiwiUmVjb2duaXRpb24iLCJsYW5nU2VsZWN0b3IiLCJoaXN0b3J5Q29udGFpbmVyIiwic3BlZWNoQ29udGFpbmVyIiwicGFwZXJDb250YWluZXIiLCJiYkNvbnRhaW5lciIsIlNwZWVjaFJlY29nbml0aW9uIiwid2Via2l0U3BlZWNoUmVjb2duaXRpb24iLCJtb3pTcGVlY2hSZWNvZ25pdGlvbiIsIm1zU3BlZWNoUmVjb2duaXRpb24iLCJvU3BlZWNoUmVjb2duaXRpb24iLCJsYW5nIiwidmFsdWUiLCJyZWNvZ25pdGlvbiIsImludGVyaW1SZXN1bHQiLCJpbm5lckhUTUwiLCJiYiIsImJhY2tncm91bmRJbWFnZSIsImV2ZW50cyIsImFuaW1lIiwidGltZWxpbmUiLCJlYXNpbmciLCJkdXJhdGlvbiIsInRhcmdldHMiLCJvcGFjaXR5IiwiQmxvdHRlciIsIlRleHQiLCJmYW1pbHkiLCJzaXplIiwiZmlsbCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwibWF0ZXJpYWwiLCJMaXF1aWREaXN0b3J0TWF0ZXJpYWwiLCJ1bmlmb3JtcyIsInVWb2xhdGlsaXR5IiwidVNlZWQiLCJibG90dGVyIiwidGV4dHMiLCJzY29wZSIsImZvclRleHQiLCJuZWVkc1VwZGF0ZSIsImFwcGVuZFRvIiwib25MYW5nQ2hhbmdlIiwib25SZXN1bHQiLCJvbkVuZCIsIm9uS2V5IiwiZSIsIm1lc3NhZ2VzIiwiZm9yRWFjaCIsIm0iLCJ1cGRhdGVMb2ciLCJhZGRFdmVudExpc3RlbmVyIiwia2V5Q29kZSIsImNsZWFyTG9nIiwidGFyZ2V0IiwidHJhbnNjcmlwdCIsInVwZGF0ZVNwZWVjaCIsImFwcGVuZFRvSGlzdG9yeSIsImlzQ29tcGxldGVkRGF0YSIsImRhdGEiLCJyZXN1bHRzIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiciIsInRpbWVTdGFtcCIsImNvbmZpZGVuY2UiLCJqb2luIiwiY3JlYXRlZCIsInRhYmxlIiwic2VudGVuY2VzIiwidXBkYXRlIiwicCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInRvcCIsImxlZnQiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImFwcGVuZCIsIldhdmVmb3JtIiwic291bmQiLCJjb25maWciLCJzcGVjdHJ1bUNvbG9ycyIsImNvdW50IiwiaHVlIiwiYmdDb2xvcnMiLCJyZWQiLCJvcmFuZ2UiLCJ5ZWxsb3ciLCJncmVlbiIsImJsdWUiLCJwdXJwbGUiLCJwaW5rIiwiYm9yZGVySGVpZ2h0IiwiT2JqZWN0Iiwia2V5cyIsImJnIiwiZGl2IiwiY2xhc3NMaXN0IiwiYmFja2dyb3VuZCIsImFwcGVuZENoaWxkIiwiY2FudmFzIiwiaGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsInJlc2l6ZSIsInF1ZXJ5U2VsZWN0b3IiLCJyZXN0IiwicXVlcnlTZWxlY3RvckFsbCIsInNwZWN0cnVtIiwiZ2V0U3BlY3RydW0iLCJ3YXZlZm9ybSIsImdldFdhdmVmb3JtIiwic3BlY3RydW1MZW5ndGgiLCJ3YXZlZm9ybUxlbmd0aCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsInJlY3QiLCJzcGVjdHJ1bVdpZHRoIiwic3BlY3RydW1IZWlnaHQiLCJzcGVjdHJ1bVZhbHVlIiwicyIsImZpbGxTdHlsZSIsIndhdmVmb3JtV2lkdGgiLCJ3YXZlZm9ybUhlaWdodCIsIndhdmVmb3JtVmFsdWUiLCJ3IiwibW92ZVRvIiwibGluZVRvIiwic3Ryb2tlU3R5bGUiLCJzdHJva2UiLCJBdWRpb1Byb2Nlc3NpbmciLCJzdHJlYW0iLCJ2b2x1bWVDb250YWluZXIiLCJub3RlQ29udGFpbmVyIiwid2F2ZWZvcm1Db250YWluZXIiLCJhdWRpb0NvbnRleHQiLCJBdWRpb0NvbnRleHQiLCJhbmFseXNlciIsImNyZWF0ZUFuYWx5c2VyIiwibWljSW5wdXQiLCJjcmVhdGVNZWRpYVN0cmVhbVNvdXJjZSIsInNjcmlwdFByb2Nlc3NvciIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsInNtb290aGluZ1RpbWVDb25zdGFudCIsImZmdFNpemUiLCJkZXN0aW5hdGlvbiIsIm9uYXVkaW9wcm9jZXNzIiwiYXVkaW9Qcm9jZXNzIiwic3RyZWFtRGF0YSIsIlVpbnQ4QXJyYXkiLCJmcmVxdWVuY3lCaW5Db3VudCIsImdldEJ5dGVGcmVxdWVuY3lEYXRhIiwiYXZlcmFnZSIsImdldEF2ZXJhZ2VWb2x1bWUiLCJkcmF3Iiwibm90ZSIsImdldE5vdGVGcm9tUGl0Y2giLCJnZXROb3RlTmJGcm9tUGl0Y2giLCJnZXRIdWVGcm9tTm90ZSIsInVwZGF0ZUNvbmZpZyIsImdldEJ5dGVUaW1lRG9tYWluRGF0YSIsImZyZXEiLCJlbmRGcmVxIiwic3VtIiwiZnJlcXVlbmNpZXMiLCJ2YWx1ZXMiLCJ2IiwiZnJlcXVlbmN5Iiwibm90ZU51bSIsIm5vdGVOYiIsIm5vdGVzIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJBIiwiQiIsInBvdyIsImZyZXF1ZW5jeUZyb21Ob3RlTnVtYmVyIiwiQXBwIiwiYXBwIiwicm9vdCIsImVscyIsImxhbmdDb250YWluZXIiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJhdWRpbyIsInRoZW4iLCJpbml0UmVjb2duaXRpb24iLCJpbml0QXVkaW9Qcm9jZXNzaW5nIiwiYXVkaW9Qcm9jZXNzaW5nIiwib25sb2FkIiwic2V0VGltZW91dCIsInNjYWxlIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFH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QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7QUFDQSxLQUFLLHVDQUF1QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLLHNDQUFzQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDbEVXOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDbkdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxvREFBVztBQUNoQyxjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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S0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdHQUFnRztBQUNoRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNqTkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxXQUFXLDJEQUEyRDtBQUN0RSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsV0FBVztBQUNYLGdEQUFnRDtBQUNoRCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EseUNBQXlDLDhCQUE4QjtBQUN2RSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEdBQUc7O0FBRUgsY0FBYztBQUNkLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsY0FBYztBQUNkO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsMENBQTBDLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixlQUFlO0FBQ25DLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQjtBQUN0QixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxnQkFBZ0I7QUFDM0M7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFD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QUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQ7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYyxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixrQkFBa0IsK0JBQStCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7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RUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLGFBQWE7QUFDOUM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLHVDQUF1Qyw4QkFBOEI7QUFDckU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsVUFBVTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhLGlCQUFpQjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtQ0FBbUMsYUFBYTtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBLHdCQUF3QixZQUFZLEdBQUc7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUMsbUJBQU8sQ0FBQyx5QkFBa0I7QUFDM0I7O0FBRUEsSUFBSSxJQUEwQztBQUM5QyxDQUFDLG9DQUFnQixLQUFLO0FBQUE7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDdkIsQ0FBQyxNQUFNLEVBRU47O0FBRUQ7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNycmhCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5R0FBeUcsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJOztBQUVqSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0U7QUFDeEU7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsa0ZBQWtGO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EsTUFBTSxJQUEyQjtBQUNqQzs7QUFFQTtBQUNBLFFBQVEsS0FBMEI7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxNQUFNLEVBTU47O0FBRUgsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxtQkFBbUIsNEJBQTRCOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsT0FBTyx5Q0FBeUMsRUFBRSxVQUFVLEVBQUU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7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QUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3RELEtBQUs7QUFDTCxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FB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LGFBSFksRUFJckIsS0FBS2tELEdBQUwsQ0FBU2pELGlCQUpZLENBQXZCO0FBTUQ7Ozs7OztBQUdIdk0sTUFBTSxDQUFDa1EsTUFBUCxHQUFnQixZQUFNO0FBQ3BCbFEsUUFBTSxDQUFDc1AsR0FBUCxHQUFhLElBQUlELEdBQUosQ0FBUSxNQUFSLENBQWI7QUFFQWMsWUFBVSxDQUFDLFlBQU07QUFDZm5MLDJEQUFLLENBQUM7QUFDSkksYUFBTyxFQUFFbUQsUUFBUSxDQUFDbUMsYUFBVCxDQUF1QixlQUF2QixDQURMO0FBRUp4RixZQUFNLEVBQUUsYUFGSjtBQUdKRyxhQUFPLEVBQUUsQ0FITDtBQUlKK0ssV0FBSyxFQUFFO0FBSkgsS0FBRCxDQUFMO0FBTUQsR0FQUyxFQU9QLElBUE8sQ0FBVjtBQVFELENBWEQsQzs7Ozs7Ozs7Ozs7QUM3dEJBLGU7Ozs7Ozs7Ozs7O0FDQUEsZTs7Ozs7Ozs7Ozs7QUNBQSxlIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FwcC5qc1wiKTtcbiIsIi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBcImVudW1cIixcbiAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbnZhciBrZXl3b3JkcyA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIFwiNW1vZHVsZVwiOiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGV4cG9ydCBpbXBvcnRcIixcbiAgNjogZWNtYTVBbmRMZXNzS2V5d29yZHMgKyBcIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXJcIlxufTtcblxudmFyIGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvXmluKHN0YW5jZW9mKT8kLztcblxuLy8gIyMgQ2hhcmFjdGVyIGNhdGVnb3JpZXNcblxuLy8gQmlnIHVnbHkgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoIGNoYXJhY3RlcnMgaW4gdGhlXG4vLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuLy8gYXJlIG9ubHkgYXBwbGllZCB3aGVuIGEgY2hhcmFjdGVyIGlzIGZvdW5kIHRvIGFjdHVhbGx5IGhhdmUgYVxuLy8gY29kZSBwb2ludCBhYm92ZSAxMjguXG4vLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4YTAtXFx1MDhiNFxcdTA4YjYtXFx1MDhiZFxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZlZlxcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2JmXFx1YTdjMi1cXHVhN2M2XFx1YTdmNy1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2N1xcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xudmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkMy1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNjJcXHUwYjYzXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAwLVxcdTBjMDRcXHUwYzNlLVxcdTBjNDRcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjJcXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MS1cXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGY5XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOGZmLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjgsNDMsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDE0LDM1LDQ3NywyOCwxMSwwLDksMjEsMTU1LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMTIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMCwzMyw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiwwLDE2MSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDM1LDU2LDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMjcwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSw3NTQsOTQ4NiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxMCw0Miw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSw1MjUsMTAsMTc2LDIsNTQsMTQsMzIsOSwxNiwzLDQ2LDEwLDU0LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMyw0LDksODMsMTEsNywwLDE2MSwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSwyMzIsNiwzLDYsNCwwLDI5LDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksMTM1LDQsNjAsNiwyNiw5LDEwMTQsMCwyLDU0LDgsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDI2Miw2LDEwLDksNDE5LDEzLDE0OTUsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbi8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbi8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbi8vIHJhcmUuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX0sIHN0YXJ0c0V4cHIgPSB7c3RhcnRzRXhwcjogdHJ1ZX07XG5cbi8vIE1hcCBrZXl3b3JkIG5hbWVzIHRvIHRva2VuIHR5cGVzLlxuXG52YXIga2V5d29yZHMkMSA9IHt9O1xuXG4vLyBTdWNjaW5jdCBkZWZpbml0aW9ucyBvZiBrZXl3b3JkIHRva2VuIHR5cGVzXG5mdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIG9wdGlvbnMua2V5d29yZCA9IG5hbWU7XG4gIHJldHVybiBrZXl3b3JkcyQxW25hbWVdID0gbmV3IFRva2VuVHlwZShuYW1lLCBvcHRpb25zKVxufVxuXG52YXIgdHlwZXMgPSB7XG4gIG51bTogbmV3IFRva2VuVHlwZShcIm51bVwiLCBzdGFydHNFeHByKSxcbiAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICBzdHJpbmc6IG5ldyBUb2tlblR5cGUoXCJzdHJpbmdcIiwgc3RhcnRzRXhwciksXG4gIG5hbWU6IG5ldyBUb2tlblR5cGUoXCJuYW1lXCIsIHN0YXJ0c0V4cHIpLFxuICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW4gdHlwZXMuXG4gIGJyYWNrZXRMOiBuZXcgVG9rZW5UeXBlKFwiW1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gIGJyYWNlTDogbmV3IFRva2VuVHlwZShcIntcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgYnJhY2VSOiBuZXcgVG9rZW5UeXBlKFwifVwiKSxcbiAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBwYXJlblI6IG5ldyBUb2tlblR5cGUoXCIpXCIpLFxuICBjb21tYTogbmV3IFRva2VuVHlwZShcIixcIiwgYmVmb3JlRXhwciksXG4gIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICBjb2xvbjogbmV3IFRva2VuVHlwZShcIjpcIiwgYmVmb3JlRXhwciksXG4gIGRvdDogbmV3IFRva2VuVHlwZShcIi5cIiksXG4gIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgYXJyb3c6IG5ldyBUb2tlblR5cGUoXCI9PlwiLCBiZWZvcmVFeHByKSxcbiAgdGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJ0ZW1wbGF0ZVwiKSxcbiAgaW52YWxpZFRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwiaW52YWxpZFRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogbmV3IFRva2VuVHlwZShcIi4uLlwiLCBiZWZvcmVFeHByKSxcbiAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgZG9sbGFyQnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwiJHtcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcblxuICAvLyBPcGVyYXRvcnMuIFRoZXNlIGNhcnJ5IHNldmVyYWwga2luZHMgb2YgcHJvcGVydGllcyB0byBoZWxwIHRoZVxuICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gIC8vIHdoYXQgY2F0ZWdvcml6ZXMgdGhlbSBhcyBvcGVyYXRvcnMpLlxuICAvL1xuICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgLy8gb3BlcmF0b3IsIGFuZCB3aWxsIHJlZmVyIHRvIGl0cyBwcmVjZWRlbmNlLlxuICAvL1xuICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgLy8gdW5hcnkgb3BlcmF0b3IuXG4gIC8vXG4gIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gIC8vIGJpbmFyeSBvcGVyYXRvcnMgd2l0aCBhIHZlcnkgbG93IHByZWNlZGVuY2UsIHRoYXQgc2hvdWxkIHJlc3VsdFxuICAvLyBpbiBBc3NpZ25tZW50RXhwcmVzc2lvbiBub2Rlcy5cblxuICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGFzc2lnbjogbmV3IFRva2VuVHlwZShcIl89XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBpc0Fzc2lnbjogdHJ1ZX0pLFxuICBpbmNEZWM6IG5ldyBUb2tlblR5cGUoXCIrKy8tLVwiLCB7cHJlZml4OiB0cnVlLCBwb3N0Zml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHByZWZpeDogbmV3IFRva2VuVHlwZShcIiEvflwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGxvZ2ljYWxPUjogYmlub3AoXCJ8fFwiLCAxKSxcbiAgbG9naWNhbEFORDogYmlub3AoXCImJlwiLCAyKSxcbiAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gIGJpdHdpc2VYT1I6IGJpbm9wKFwiXlwiLCA0KSxcbiAgYml0d2lzZUFORDogYmlub3AoXCImXCIsIDUpLFxuICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPS89PT0vIT09XCIsIDYpLFxuICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIG1vZHVsbzogYmlub3AoXCIlXCIsIDEwKSxcbiAgc3RhcjogYmlub3AoXCIqXCIsIDEwKSxcbiAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gIHN0YXJzdGFyOiBuZXcgVG9rZW5UeXBlKFwiKipcIiwge2JlZm9yZUV4cHI6IHRydWV9KSxcblxuICAvLyBLZXl3b3JkIHRva2VuIHR5cGVzLlxuICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gIF9jYXNlOiBrdyhcImNhc2VcIiwgYmVmb3JlRXhwciksXG4gIF9jYXRjaDoga3coXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICBfZGVidWdnZXI6IGt3KFwiZGVidWdnZXJcIiksXG4gIF9kZWZhdWx0OiBrdyhcImRlZmF1bHRcIiwgYmVmb3JlRXhwciksXG4gIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gIF9lbHNlOiBrdyhcImVsc2VcIiwgYmVmb3JlRXhwciksXG4gIF9maW5hbGx5OiBrdyhcImZpbmFsbHlcIiksXG4gIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX2Z1bmN0aW9uOiBrdyhcImZ1bmN0aW9uXCIsIHN0YXJ0c0V4cHIpLFxuICBfaWY6IGt3KFwiaWZcIiksXG4gIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICBfc3dpdGNoOiBrdyhcInN3aXRjaFwiKSxcbiAgX3Rocm93OiBrdyhcInRocm93XCIsIGJlZm9yZUV4cHIpLFxuICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgX3Zhcjoga3coXCJ2YXJcIiksXG4gIF9jb25zdDoga3coXCJjb25zdFwiKSxcbiAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgX3dpdGg6IGt3KFwid2l0aFwiKSxcbiAgX25ldzoga3coXCJuZXdcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgX3N1cGVyOiBrdyhcInN1cGVyXCIsIHN0YXJ0c0V4cHIpLFxuICBfY2xhc3M6IGt3KFwiY2xhc3NcIiwgc3RhcnRzRXhwciksXG4gIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gIF9leHBvcnQ6IGt3KFwiZXhwb3J0XCIpLFxuICBfaW1wb3J0OiBrdyhcImltcG9ydFwiLCBzdGFydHNFeHByKSxcbiAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgX3RydWU6IGt3KFwidHJ1ZVwiLCBzdGFydHNFeHByKSxcbiAgX2ZhbHNlOiBrdyhcImZhbHNlXCIsIHN0YXJ0c0V4cHIpLFxuICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF9pbnN0YW5jZW9mOiBrdyhcImluc3RhbmNlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gIF90eXBlb2Y6IGt3KFwidHlwZW9mXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIF9kZWxldGU6IGt3KFwiZGVsZXRlXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KVxufTtcblxuLy8gTWF0Y2hlcyBhIHdob2xlIGxpbmUgYnJlYWsgKHdoZXJlIENSTEYgaXMgY29uc2lkZXJlZCBhIHNpbmdsZVxuLy8gbGluZSBicmVhaykuIFVzZWQgdG8gY291bnQgbGluZXMuXG5cbnZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5LztcbnZhciBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlLCBlY21hMjAxOVN0cmluZykge1xuICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgKCFlY21hMjAxOVN0cmluZyAmJiAoY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT09IDB4MjAyOSkpXG59XG5cbnZhciBub25BU0NJSXdoaXRlc3BhY2UgPSAvW1xcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuZnVuY3Rpb24gd29yZHNSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbn1cblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2w7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG59O1xuXG52YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdCBiZVxuICAvLyBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCA4ICgyMDE3KSwgOSAoMjAxOCksIG9yIDEwXG4gIC8vICgyMDE5KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnQgZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mXG4gIC8vIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3IgbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHRcbiAgLy8gaXMgOS5cbiAgZWNtYVZlcnNpb246IDksXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBjb21tYSBhcyBhbiBvZmZzZXQsIGFuZCBpZiBgbG9jYXRpb25zYCBpc1xuICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAvLyBhcyBzZWNvbmQgYXJndW1lbnQuXG4gIG9uSW5zZXJ0ZWRTZW1pY29sb246IG51bGwsXG4gIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gIC8vIHRyYWlsaW5nIGNvbW1hcy5cbiAgb25UcmFpbGluZ0NvbW1hOiBudWxsLFxuICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAvLyBTZXQgYGFsbG93UmVzZXJ2ZWRgIHRvIGEgYm9vbGVhbiB2YWx1ZSB0byBleHBsaWNpdGx5IHR1cm4gdGhpcyBvblxuICAvLyBhbiBvZmYuIFdoZW4gdGhpcyBvcHRpb24gaGFzIHRoZSB2YWx1ZSBcIm5ldmVyXCIsIHJlc2VydmVkIHdvcmRzXG4gIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgYWxsb3dSZXNlcnZlZDogbnVsbCxcbiAgLy8gV2hlbiBlbmFibGVkLCBhIHJldHVybiBhdCB0aGUgdG9wIGxldmVsIGlzIG5vdCBjb25zaWRlcmVkIGFuXG4gIC8vIGVycm9yLlxuICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgaW1wb3J0L2V4cG9ydCBzdGF0ZW1lbnRzIGFyZSBub3QgY29uc3RyYWluZWQgdG9cbiAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gIC8vIFdoZW4gZW5hYmxlZCwgYXdhaXQgaWRlbnRpZmllcnMgYXJlIGFsbG93ZWQgdG8gYXBwZWFyIGF0IHRoZSB0b3AtbGV2ZWwgc2NvcGUsXG4gIC8vIGJ1dCB0aGV5IGFyZSBzdGlsbCBub3QgYWxsb3dlZCBpbiBub24tYXN5bmMgZnVuY3Rpb25zLlxuICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZVxufTtcblxuLy8gSW50ZXJwcmV0IGFuZCBkZWZhdWx0IGFuIG9wdGlvbnMgb2JqZWN0XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucylcbiAgICB7IG9wdGlvbnNbb3B0XSA9IG9wdHMgJiYgaGFzKG9wdHMsIG9wdCkgPyBvcHRzW29wdF0gOiBkZWZhdWx0T3B0aW9uc1tvcHRdOyB9XG5cbiAgaWYgKG9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMjAxNSlcbiAgICB7IG9wdGlvbnMuZWNtYVZlcnNpb24gLT0gMjAwOTsgfVxuXG4gIGlmIChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gbnVsbClcbiAgICB7IG9wdGlvbnMuYWxsb3dSZXNlcnZlZCA9IG9wdGlvbnMuZWNtYVZlcnNpb24gPCA1OyB9XG5cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgIHZhciB0b2tlbnMgPSBvcHRpb25zLm9uVG9rZW47XG4gICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH07XG4gIH1cbiAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgIHsgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudCk7IH1cblxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24oYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICB2YXIgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IGJsb2NrID8gXCJCbG9ja1wiIDogXCJMaW5lXCIsXG4gICAgICB2YWx1ZTogdGV4dCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICB7IGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpOyB9XG4gICAgaWYgKG9wdGlvbnMucmFuZ2VzKVxuICAgICAgeyBjb21tZW50LnJhbmdlID0gW3N0YXJ0LCBlbmRdOyB9XG4gICAgYXJyYXkucHVzaChjb21tZW50KTtcbiAgfVxufVxuXG4vLyBFYWNoIHNjb3BlIGdldHMgYSBiaXRzZXQgdGhhdCBtYXkgY29udGFpbiB0aGVzZSBmbGFnc1xudmFyXG4gICAgU0NPUEVfVE9QID0gMSxcbiAgICBTQ09QRV9GVU5DVElPTiA9IDIsXG4gICAgU0NPUEVfVkFSID0gU0NPUEVfVE9QIHwgU0NPUEVfRlVOQ1RJT04sXG4gICAgU0NPUEVfQVNZTkMgPSA0LFxuICAgIFNDT1BFX0dFTkVSQVRPUiA9IDgsXG4gICAgU0NPUEVfQVJST1cgPSAxNixcbiAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAzMixcbiAgICBTQ09QRV9TVVBFUiA9IDY0LFxuICAgIFNDT1BFX0RJUkVDVF9TVVBFUiA9IDEyODtcblxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhhc3luYywgZ2VuZXJhdG9yKSB7XG4gIHJldHVybiBTQ09QRV9GVU5DVElPTiB8IChhc3luYyA/IFNDT1BFX0FTWU5DIDogMCkgfCAoZ2VuZXJhdG9yID8gU0NPUEVfR0VORVJBVE9SIDogMClcbn1cblxuLy8gVXNlZCBpbiBjaGVja0xWYWwgYW5kIGRlY2xhcmVOYW1lIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBhIGJpbmRpbmdcbnZhclxuICAgIEJJTkRfTk9ORSA9IDAsIC8vIE5vdCBhIGJpbmRpbmdcbiAgICBCSU5EX1ZBUiA9IDEsIC8vIFZhci1zdHlsZSBiaW5kaW5nXG4gICAgQklORF9MRVhJQ0FMID0gMiwgLy8gTGV0LSBvciBjb25zdC1zdHlsZSBiaW5kaW5nXG4gICAgQklORF9GVU5DVElPTiA9IDMsIC8vIEZ1bmN0aW9uIGRlY2xhcmF0aW9uXG4gICAgQklORF9TSU1QTEVfQ0FUQ0ggPSA0LCAvLyBTaW1wbGUgKGlkZW50aWZpZXIgcGF0dGVybikgY2F0Y2ggYmluZGluZ1xuICAgIEJJTkRfT1VUU0lERSA9IDU7IC8vIFNwZWNpYWwgY2FzZSBmb3IgZnVuY3Rpb24gbmFtZXMgYXMgYm91bmQgaW5zaWRlIHRoZSBmdW5jdGlvblxuXG52YXIgUGFyc2VyID0gZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMsIGlucHV0LCBzdGFydFBvcykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5zb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlO1xuICB0aGlzLmtleXdvcmRzID0gd29yZHNSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwiNW1vZHVsZVwiIDogNV0pO1xuICB2YXIgcmVzZXJ2ZWQgPSBcIlwiO1xuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkICE9PSB0cnVlKSB7XG4gICAgZm9yICh2YXIgdiA9IG9wdGlvbnMuZWNtYVZlcnNpb247OyB2LS0pXG4gICAgICB7IGlmIChyZXNlcnZlZCA9IHJlc2VydmVkV29yZHNbdl0pIHsgYnJlYWsgfSB9XG4gICAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikgeyByZXNlcnZlZCArPSBcIiBhd2FpdFwiOyB9XG4gIH1cbiAgdGhpcy5yZXNlcnZlZFdvcmRzID0gd29yZHNSZWdleHAocmVzZXJ2ZWQpO1xuICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QpO1xuICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0gd29yZHNSZWdleHAocmVzZXJ2ZWRTdHJpY3QgKyBcIiBcIiArIHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG4gIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpO1xuXG4gIC8vIFVzZWQgdG8gc2lnbmFsIHRvIGNhbGxlcnMgb2YgYHJlYWRXb3JkMWAgd2hldGhlciB0aGUgd29yZFxuICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAvLyBlc2NhcGUgc2VxdWVuY2VzIG11c3Qgbm90IGJlIGludGVycHJldGVkIGFzIGtleXdvcmRzLlxuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG5cbiAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gIGlmIChzdGFydFBvcykge1xuICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gIH1cblxuICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAvLyBJdHMgdHlwZVxuICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuXG4gIC8vIFBvc2l0aW9ucyB0byBkZWxheWVkLWNoZWNrIHRoYXQgeWllbGQvYXdhaXQgZG9lcyBub3QgZXhpc3QgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzLlxuICB0aGlzLnlpZWxkUG9zID0gdGhpcy5hd2FpdFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gIC8vIExhYmVscyBpbiBzY29wZS5cbiAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgLy8gVGh1cy1mYXIgdW5kZWZpbmVkIGV4cG9ydHMuXG4gIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IHt9O1xuXG4gIC8vIElmIGVuYWJsZWQsIHNraXAgbGVhZGluZyBoYXNoYmFuZyBsaW5lLlxuICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09IFwiIyFcIilcbiAgICB7IHRoaXMuc2tpcExpbmVDb21tZW50KDIpOyB9XG5cbiAgLy8gU2NvcGUgdHJhY2tpbmcgZm9yIGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcyAoc2VlIHNjb3BlLmpzKVxuICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgdGhpcy5lbnRlclNjb3BlKFNDT1BFX1RPUCk7XG5cbiAgLy8gRm9yIFJlZ0V4cCB2YWxpZGF0aW9uXG4gIHRoaXMucmVnZXhwU3RhdGUgPSBudWxsO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgaW5GdW5jdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkdlbmVyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbkFzeW5jOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGFsbG93U3VwZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sYWxsb3dEaXJlY3RTdXBlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx0cmVhdEZ1bmN0aW9uc0FzVmFyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5vcHRpb25zLnByb2dyYW0gfHwgdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmluRnVuY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuaW5HZW5lcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9HRU5FUkFUT1IpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLmluQXN5bmMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MgJiBTQ09QRV9BU1lOQykgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9TVVBFUikgPiAwIH07XG5wcm90b3R5cGVBY2Nlc3NvcnMuYWxsb3dEaXJlY3RTdXBlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MgJiBTQ09QRV9ESVJFQ1RfU1VQRVIpID4gMCB9O1xucHJvdG90eXBlQWNjZXNzb3JzLnRyZWF0RnVuY3Rpb25zQXNWYXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKSB9O1xuXG4vLyBTd2l0Y2ggdG8gYSBnZXR0ZXIgZm9yIDcuMC4wLlxuUGFyc2VyLnByb3RvdHlwZS5pbk5vbkFycm93RnVuY3Rpb24gPSBmdW5jdGlvbiBpbk5vbkFycm93RnVuY3Rpb24gKCkgeyByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzICYgU0NPUEVfRlVOQ1RJT04pID4gMCB9O1xuXG5QYXJzZXIuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kICgpIHtcbiAgICB2YXIgcGx1Z2lucyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBwbHVnaW5zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgdmFyIGNscyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykgeyBjbHMgPSBwbHVnaW5zW2ldKGNscyk7IH1cbiAgcmV0dXJuIGNsc1xufTtcblxuUGFyc2VyLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dCkucGFyc2UoKVxufTtcblxuUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0ID0gZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQgKGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyB0aGlzKG9wdGlvbnMsIGlucHV0LCBwb3MpO1xuICBwYXJzZXIubmV4dFRva2VuKCk7XG4gIHJldHVybiBwYXJzZXIucGFyc2VFeHByZXNzaW9uKClcbn07XG5cblBhcnNlci50b2tlbml6ZXIgPSBmdW5jdGlvbiB0b2tlbml6ZXIgKGlucHV0LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgdGhpcyhvcHRpb25zLCBpbnB1dClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQYXJzZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIHBwID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gIyMgUGFyc2VyIHV0aWxpdGllc1xuXG52YXIgbGl0ZXJhbCA9IC9eKD86JygoPzpcXFxcLnxbXiddKSo/KSd8XCIoKD86XFxcXC58W15cIl0pKj8pXCIpLztcbnBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIGZvciAoOzspIHtcbiAgICAvLyBUcnkgdG8gZmluZCBzdHJpbmcgbGl0ZXJhbC5cbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDtcbiAgICB2YXIgbWF0Y2ggPSBsaXRlcmFsLmV4ZWModGhpcy5pbnB1dC5zbGljZShzdGFydCkpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKG1hdGNoWzFdIHx8IG1hdGNoWzJdKSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIC8vIFNraXAgc2VtaWNvbG9uLCBpZiBhbnkuXG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gc3RhcnQ7XG4gICAgc3RhcnQgKz0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW5wdXRbc3RhcnRdID09PSBcIjtcIilcbiAgICAgIHsgc3RhcnQrKzsgfVxuICB9XG59O1xuXG4vLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuLy8gdHlwZSwgYW5kIGlmIHllcywgY29uc3VtZXMgaXQgYXMgYSBzaWRlIGVmZmVjdC5cblxucHAuZWF0ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmlzQ29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSAmJiB0aGlzLnZhbHVlID09PSBuYW1lICYmICF0aGlzLmNvbnRhaW5zRXNjXG59O1xuXG4vLyBDb25zdW1lcyBjb250ZXh0dWFsIGtleXdvcmQgaWYgcG9zc2libGUuXG5cbnBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5pc0NvbnRleHR1YWwobmFtZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBBc3NlcnRzIHRoYXQgZm9sbG93aW5nIHRva2VuIGlzIGdpdmVuIGNvbnRleHR1YWwga2V5d29yZC5cblxucHAuZXhwZWN0Q29udGV4dHVhbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbi8vIFRlc3Qgd2hldGhlciBhIHNlbWljb2xvbiBjYW4gYmUgaW5zZXJ0ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbnBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50eXBlID09PSB0eXBlcy5lb2YgfHxcbiAgICB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNlUiB8fFxuICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbnBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbilcbiAgICAgIHsgdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3VtZSBhIHNlbWljb2xvbiwgb3IsIGZhaWxpbmcgdGhhdCwgc2VlIGlmIHdlIGFyZSBhbGxvd2VkIHRvXG4vLyBwcmV0ZW5kIHRoYXQgdGhlcmUgaXMgYSBzZW1pY29sb24gYXQgdGhpcyBwb3NpdGlvbi5cblxucHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5lYXQodHlwZXMuc2VtaSkgJiYgIXRoaXMuaW5zZXJ0U2VtaWNvbG9uKCkpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUsIG5vdE5leHQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdG9rVHlwZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICBpZiAoIW5vdE5leHQpXG4gICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbn07XG5cbmZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gIHRoaXMuZG91YmxlUHJvdG8gPVxuICAgIC0xO1xufVxuXG5wcC5jaGVja1BhdHRlcm5FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBpc0Fzc2lnbikge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIH1cbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA+IC0xKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgdmFyIHBhcmVucyA9IGlzQXNzaWduID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDogcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZDtcbiAgaWYgKHBhcmVucyA+IC0xKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwYXJlbnMsIFwiUGFyZW50aGVzaXplZCBwYXR0ZXJuXCIpOyB9XG59O1xuXG5wcC5jaGVja0V4cHJlc3Npb25FcnJvcnMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhbmRUaHJvdykge1xuICBpZiAoIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICB2YXIgZG91YmxlUHJvdG8gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLmRvdWJsZVByb3RvO1xuICBpZiAoIWFuZFRocm93KSB7IHJldHVybiBzaG9ydGhhbmRBc3NpZ24gPj0gMCB8fCBkb3VibGVQcm90byA+PSAwIH1cbiAgaWYgKHNob3J0aGFuZEFzc2lnbiA+PSAwKVxuICAgIHsgdGhpcy5yYWlzZShzaG9ydGhhbmRBc3NpZ24sIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbiAgaWYgKGRvdWJsZVByb3RvID49IDApXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZG91YmxlUHJvdG8sIFwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiKTsgfVxufTtcblxucHAuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnlpZWxkUG9zICYmICghdGhpcy5hd2FpdFBvcyB8fCB0aGlzLnlpZWxkUG9zIDwgdGhpcy5hd2FpdFBvcykpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMueWllbGRQb3MsIFwiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlXCIpOyB9XG4gIGlmICh0aGlzLmF3YWl0UG9zKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCBcIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxufTtcblxucHAuaXNTaW1wbGVBc3NpZ25UYXJnZXQgPSBmdW5jdGlvbihleHByKSB7XG4gIGlmIChleHByLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIilcbiAgICB7IHJldHVybiB0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGV4cHIuZXhwcmVzc2lvbikgfVxuICByZXR1cm4gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiXG59O1xuXG52YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbi8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4vLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2Zcbi8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4vLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4vLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbnBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuZW9mKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRydWUsIGV4cG9ydHMpO1xuICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpO1xuICB9XG4gIGlmICh0aGlzLmluTW9kdWxlKVxuICAgIHsgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBPYmplY3Qua2V5cyh0aGlzLnVuZGVmaW5lZEV4cG9ydHMpOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV0uc3RhcnQsIChcIkV4cG9ydCAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkXCIpKTtcbiAgICAgIH0gfVxuICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5KTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxudmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn0sIHN3aXRjaExhYmVsID0ge2tpbmQ6IFwic3dpdGNoXCJ9O1xuXG5wcCQxLmlzTGV0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gdGhpcy5wb3M7XG4gIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCk7XG4gIC8vIEZvciBhbWJpZ3VvdXMgY2FzZXMsIGRldGVybWluZSBpZiBhIExleGljYWxEZWNsYXJhdGlvbiAob3Igb25seSBhXG4gIC8vIFN0YXRlbWVudCkgaXMgYWxsb3dlZCBoZXJlLiBJZiBjb250ZXh0IGlzIG5vdCBlbXB0eSB0aGVuIG9ubHkgYSBTdGF0ZW1lbnRcbiAgLy8gaXMgYWxsb3dlZC4gSG93ZXZlciwgYGxldCBbYCBpcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSBsb29rYWhlYWQgZm9yXG4gIC8vIEV4cHJlc3Npb25TdGF0ZW1lbnQsIHNvIHNwZWNpYWwtY2FzZSBpdCBmaXJzdC5cbiAgaWYgKG5leHRDaCA9PT0gOTEpIHsgcmV0dXJuIHRydWUgfSAvLyAnWydcbiAgaWYgKGNvbnRleHQpIHsgcmV0dXJuIGZhbHNlIH1cblxuICBpZiAobmV4dENoID09PSAxMjMpIHsgcmV0dXJuIHRydWUgfSAvLyAneydcbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHRDaCwgdHJ1ZSkpIHtcbiAgICB2YXIgcG9zID0gbmV4dCArIDE7XG4gICAgd2hpbGUgKGlzSWRlbnRpZmllckNoYXIodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyksIHRydWUpKSB7ICsrcG9zOyB9XG4gICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpO1xuICAgIGlmICgha2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBjaGVjayAnYXN5bmMgW25vIExpbmVUZXJtaW5hdG9yIGhlcmVdIGZ1bmN0aW9uJ1xuLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4vLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxucHAkMS5pc0FzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDggfHwgIXRoaXMuaXNDb250ZXh0dWFsKFwiYXN5bmNcIikpXG4gICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zO1xuICB2YXIgc2tpcCA9IHNraXBXaGl0ZVNwYWNlLmV4ZWModGhpcy5pbnB1dCk7XG4gIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aDtcbiAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCBuZXh0KSkgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKG5leHQsIG5leHQgKyA4KSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgKG5leHQgKyA4ID09PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxufTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGNvbnRleHQsIHRvcExldmVsLCBleHBvcnRzKSB7XG4gIHZhciBzdGFydHR5cGUgPSB0aGlzLnR5cGUsIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kO1xuXG4gIGlmICh0aGlzLmlzTGV0KGNvbnRleHQpKSB7XG4gICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICBraW5kID0gXCJsZXRcIjtcbiAgfVxuXG4gIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAvLyBjb21wbGV4aXR5LlxuXG4gIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIC8vIEZ1bmN0aW9uIGFzIHNvbGUgYm9keSBvZiBlaXRoZXIgYW4gaWYgc3RhdGVtZW50IG9yIGEgbGFiZWxlZCBzdGF0ZW1lbnRcbiAgICAvLyB3b3JrcywgYnV0IG5vdCB3aGVuIGl0IGlzIHBhcnQgb2YgYSBsYWJlbGVkIHN0YXRlbWVudCB0aGF0IGlzIHRoZSBzb2xlXG4gICAgLy8gYm9keSBvZiBhbiBpZiBzdGF0ZW1lbnQuXG4gICAgaWYgKChjb250ZXh0ICYmICh0aGlzLnN0cmljdCB8fCBjb250ZXh0ICE9PSBcImlmXCIgJiYgY29udGV4dCAhPT0gXCJsYWJlbFwiKSkgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhY29udGV4dClcbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gIGNhc2UgdHlwZXMuX2lmOiByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3JldHVybjogcmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90aHJvdzogcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl90cnk6IHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2NvbnN0OiBjYXNlIHR5cGVzLl92YXI6XG4gICAga2luZCA9IGtpbmQgfHwgdGhpcy52YWx1ZTtcbiAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZClcbiAgY2FzZSB0eXBlcy5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fd2l0aDogcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuYnJhY2VMOiByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKHRydWUsIG5vZGUpXG4gIGNhc2UgdHlwZXMuc2VtaTogcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9leHBvcnQ6XG4gIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTAgJiYgc3RhcnR0eXBlID09PSB0eXBlcy5faW1wb3J0KSB7XG4gICAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgICAgIHZhciBza2lwID0gc2tpcFdoaXRlU3BhY2UuZXhlYyh0aGlzLmlucHV0KTtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5wb3MgKyBza2lwWzBdLmxlbmd0aCwgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDApIC8vICcoJ1xuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCB0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKGNvbnRleHQpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dClcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVOYW1lID0gdGhpcy52YWx1ZSwgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHlwZXMubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR5cGVzLmNvbG9uKSlcbiAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgY29udGV4dCkgfVxuICAgIGVsc2UgeyByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgfVxuICB9XG59O1xuXG5wcCQxLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleXdvcmQpIHtcbiAgdmFyIGlzQnJlYWsgPSBrZXl3b3JkID09PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgLy8gY29udGludWUgdG8uXG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzLmxhYmVsc1tpXTtcbiAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIHsgYnJlYWsgfVxuICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsga2V5d29yZCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRG9TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJkb1wiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLl93aGlsZSk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgdGhpcy5lYXQodHlwZXMuc2VtaSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxufTtcblxuLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuLy8gbG9vcCBpcyBub24tdHJpdmlhbC4gQmFzaWNhbGx5LCB3ZSBoYXZlIHRvIHBhcnNlIHRoZSBpbml0IGB2YXJgXG4vLyBzdGF0ZW1lbnQgb3IgZXhwcmVzc2lvbiwgZGlzYWxsb3dpbmcgdGhlIGBpbmAgb3BlcmF0b3IgKHNlZVxuLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuLy8gd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBgaW5gIG9yIGBvZmAuIFdoZW4gdGhlcmUgaXMgbm8gaW5pdFxuLy8gcGFydCAoc2VtaWNvbG9uIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBvcGVuaW5nIHBhcmVudGhlc2lzKSwgaXRcbi8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG5wcCQxLnBhcnNlRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgdmFyIGF3YWl0QXQgPSAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpICYmIHRoaXMuZWF0Q29udGV4dHVhbChcImF3YWl0XCIpKSA/IHRoaXMubGFzdFRva1N0YXJ0IDogLTE7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgdGhpcy5lbnRlclNjb3BlKDApO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pKSB7XG4gICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKVxuICB9XG4gIHZhciBpc0xldCA9IHRoaXMuaXNMZXQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX3ZhciB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9jb25zdCB8fCBpc0xldCkge1xuICAgIHZhciBpbml0JDEgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGluaXQkMSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICAgIGlmICgodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSAmJiBpbml0JDEuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbikge1xuICAgICAgICAgIGlmIChhd2FpdEF0ID4gLTEpIHsgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpOyB9XG4gICAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgfVxuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4pIHtcbiAgICAgICAgaWYgKGF3YWl0QXQgPiAtMSkgeyB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7IH1cbiAgICAgIH0gZWxzZSB7IG5vZGUuYXdhaXQgPSBhd2FpdEF0ID4gLTE7IH1cbiAgICB9XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGluaXQpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgfVxuICBpZiAoYXdhaXRBdCA+IC0xKSB7IHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTsgfVxuICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBpbml0KVxufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgaXNBc3luYywgZGVjbGFyYXRpb25Qb3NpdGlvbikge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBGVU5DX1NUQVRFTUVOVCB8IChkZWNsYXJhdGlvblBvc2l0aW9uID8gMCA6IEZVTkNfSEFOR0lOR19TVEFURU1FTlQpLCBmYWxzZSwgaXNBc3luYylcbn07XG5cbnBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgLy8gYWxsb3cgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGluIGJyYW5jaGVzLCBidXQgb25seSBpbiBub24tc3RyaWN0IG1vZGVcbiAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpO1xuICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KHR5cGVzLl9lbHNlKSA/IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKSA6IG51bGw7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVJldHVyblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgLy8gb3B0aW9uYWwgYXJndW1lbnRzLCB3ZSBlYWdlcmx5IGxvb2sgZm9yIGEgc2VtaWNvbG9uIG9yIHRoZVxuICAvLyBwb3NzaWJpbGl0eSB0byBpbnNlcnQgb25lLlxuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IG5vZGUuYXJndW1lbnQgPSBudWxsOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlU3dpdGNoU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIG5vZGUuY2FzZXMgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gIHRoaXMuZW50ZXJTY29wZSgwKTtcblxuICAvLyBTdGF0ZW1lbnRzIHVuZGVyIG11c3QgYmUgZ3JvdXBlZCAoYnkgbGFiZWwpIGluIFN3aXRjaENhc2VcbiAgLy8gbm9kZXMuIGBjdXJgIGlzIHVzZWQgdG8ga2VlcCB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHlcbiAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgdmFyIGN1cjtcbiAgZm9yICh2YXIgc2F3RGVmYXVsdCA9IGZhbHNlOyB0aGlzLnR5cGUgIT09IHR5cGVzLmJyYWNlUjspIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2FzZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLl9kZWZhdWx0KSB7XG4gICAgICB2YXIgaXNDYXNlID0gdGhpcy50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gICAgICBub2RlLmNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzYXdEZWZhdWx0KSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjdXIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgfVxuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG4gIGlmIChjdXIpIHsgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpOyB9XG4gIHRoaXMubmV4dCgpOyAvLyBDbG9zaW5nIGJyYWNlXG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICB7IHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTsgfVxuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpXG59O1xuXG4vLyBSZXVzZWQgZW1wdHkgYXJyYXkgYWRkZWQgZm9yIG5vZGUgZmllbGRzIHRoYXQgYXJlIGFsd2F5cyBlbXB0eS5cblxudmFyIGVtcHR5ID0gW107XG5cbnBwJDEucGFyc2VUcnlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jYXRjaCkge1xuICAgIHZhciBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5wYXJlbkwpKSB7XG4gICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICAgIHZhciBzaW1wbGUgPSBjbGF1c2UucGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gICAgICB0aGlzLmVudGVyU2NvcGUoc2ltcGxlID8gU0NPUEVfU0lNUExFX0NBVENIIDogMCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIHNpbXBsZSA/IEJJTkRfU0lNUExFX0NBVENIIDogQklORF9MRVhJQ0FMKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCAxMCkgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgY2xhdXNlLnBhcmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZW50ZXJTY29wZSgwKTtcbiAgICB9XG4gICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIHRoaXMuZXhpdFNjb3BlKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKTtcbiAgfVxuICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR5cGVzLl9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxufTtcblxucHAkMS5wYXJzZVdoaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcIndpdGhcIik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzLmxhYmVsczsgaSQxIDwgbGlzdC5sZW5ndGg7IGkkMSArPSAxKVxuICAgIHtcbiAgICB2YXIgbGFiZWwgPSBsaXN0W2kkMV07XG5cbiAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKVxuICAgICAgeyB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gIH0gfVxuICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHlwZXMuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsO1xuICBmb3IgKHZhciBpID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFiZWwkMSA9IHRoaXMubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAvLyBVcGRhdGUgaW5mb3JtYXRpb24gYWJvdXQgcHJldmlvdXMgbGFiZWxzIG9uIHRoaXMgbm9kZVxuICAgICAgbGFiZWwkMS5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIG5vZGUpIHtcbiAgaWYgKCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPT09IHZvaWQgMCApIGNyZWF0ZU5ld0xleGljYWxTY29wZSA9IHRydWU7XG4gIGlmICggbm9kZSA9PT0gdm9pZCAwICkgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHsgdGhpcy5lbnRlclNjb3BlKDApOyB9XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIHZhciBzdG10ID0gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtcbiAgICBub2RlLmJvZHkucHVzaChzdG10KTtcbiAgfVxuICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7IHRoaXMuZXhpdFNjb3BlKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHJlZ3VsYXIgYGZvcmAgbG9vcC4gVGhlIGRpc2FtYmlndWF0aW9uIGNvZGUgaW5cbi8vIGBwYXJzZVN0YXRlbWVudGAgd2lsbCBhbHJlYWR5IGhhdmUgcGFyc2VkIHRoZSBpbml0IHN0YXRlbWVudCBvclxuLy8gZXhwcmVzc2lvbi5cblxucHAkMS5wYXJzZUZvciA9IGZ1bmN0aW9uKG5vZGUsIGluaXQpIHtcbiAgbm9kZS5pbml0ID0gaW5pdDtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5zZW1pKTtcbiAgbm9kZS51cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuUiA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlblIpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiZm9yXCIpO1xuICB0aGlzLmV4aXRTY29wZSgpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICB2YXIgaXNGb3JJbiA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luO1xuICB0aGlzLm5leHQoKTtcblxuICBpZiAoXG4gICAgaW5pdC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiAmJlxuICAgIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJlxuICAgIChcbiAgICAgICFpc0ZvckluIHx8XG4gICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8XG4gICAgICB0aGlzLnN0cmljdCB8fFxuICAgICAgaW5pdC5raW5kICE9PSBcInZhclwiIHx8XG4gICAgICBpbml0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIlxuICAgIClcbiAgKSB7XG4gICAgdGhpcy5yYWlzZShcbiAgICAgIGluaXQuc3RhcnQsXG4gICAgICAoKGlzRm9ySW4gPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIikgKyBcIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiKVxuICAgICk7XG4gIH0gZWxzZSBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICB0aGlzLnJhaXNlKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItbG9vcFwiKTtcbiAgfVxuICBub2RlLmxlZnQgPSBpbml0O1xuICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKTtcbiAgdGhpcy5leGl0U2NvcGUoKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcy5lYXQodHlwZXMuZXEpKSB7XG4gICAgICBkZWNsLmluaXQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oaXNGb3IpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIGlmIChkZWNsLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2luIHx8IHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgdGhpcy5yYWlzZSh0aGlzLmxhc3RUb2tFbmQsIFwiQ29tcGxleCBiaW5kaW5nIHBhdHRlcm5zIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2wuaW5pdCA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICBpZiAoIXRoaXMuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB0aGlzLmNoZWNrTFZhbChkZWNsLmlkLCBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUwsIGZhbHNlKTtcbn07XG5cbnZhciBGVU5DX1NUQVRFTUVOVCA9IDEsIEZVTkNfSEFOR0lOR19TVEFURU1FTlQgPSAyLCBGVU5DX05VTExBQkxFX0lEID0gNDtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlRgKS5cblxuLy8gUmVtb3ZlIGBhbGxvd0V4cHJlc3Npb25Cb2R5YCBmb3IgNy4wLjAsIGFzIGl0IGlzIG9ubHkgY2FsbGVkIHdpdGggZmFsc2VcbnBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIHN0YXRlbWVudCwgYWxsb3dFeHByZXNzaW9uQm9keSwgaXNBc3luYykge1xuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5IHx8IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFpc0FzeW5jKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3RhciAmJiAoc3RhdGVtZW50ICYgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCkpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgaWYgKHN0YXRlbWVudCAmIEZVTkNfU1RBVEVNRU5UKSB7XG4gICAgbm9kZS5pZCA9IChzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKSAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUgPyBudWxsIDogdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgaWYgKG5vZGUuaWQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UKSlcbiAgICAgIC8vIElmIGl0IGlzIGEgcmVndWxhciBmdW5jdGlvbiBkZWNsYXJhdGlvbiBpbiBzbG9wcHkgbW9kZSwgdGhlbiBpdCBpc1xuICAgICAgLy8gc3ViamVjdCB0byBBbm5leCBCIHNlbWFudGljcyAoQklORF9GVU5DVElPTikuIE90aGVyd2lzZSwgdGhlIGJpbmRpbmdcbiAgICAgIC8vIG1vZGUgZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNjb3BlIChzZWVcbiAgICAgIC8vIHRyZWF0RnVuY3Rpb25zQXNWYXIpLlxuICAgICAgeyB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCAodGhpcy5zdHJpY3QgfHwgbm9kZS5nZW5lcmF0b3IgfHwgbm9kZS5hc3luYykgPyB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04pOyB9XG4gIH1cblxuICB2YXIgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEF3YWl0SWRlbnRQb3MgPSB0aGlzLmF3YWl0SWRlbnRQb3M7XG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcbiAgdGhpcy5lbnRlclNjb3BlKGZ1bmN0aW9uRmxhZ3Mobm9kZS5hc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcblxuICBpZiAoIShzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVCkpXG4gICAgeyBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBudWxsOyB9XG5cbiAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGZhbHNlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCAoc3RhdGVtZW50ICYgRlVOQ19TVEFURU1FTlQpID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxucHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0eXBlcy5wYXJlblIsIGZhbHNlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCk7XG4gIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG59O1xuXG4vLyBQYXJzZSBhIGNsYXNzIGRlY2xhcmF0aW9uIG9yIGxpdGVyYWwgKGRlcGVuZGluZyBvbiB0aGVcbi8vIGBpc1N0YXRlbWVudGAgcGFyYW1ldGVyKS5cblxucHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgdGhpcy5uZXh0KCk7XG5cbiAgLy8gZWNtYS0yNjIgMTQuNiBDbGFzcyBEZWZpbml0aW9uc1xuICAvLyBBIGNsYXNzIGRlZmluaXRpb24gaXMgYWx3YXlzIHN0cmljdCBtb2RlIGNvZGUuXG4gIHZhciBvbGRTdHJpY3QgPSB0aGlzLnN0cmljdDtcbiAgdGhpcy5zdHJpY3QgPSB0cnVlO1xuXG4gIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50KTtcbiAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gIHZhciBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB2YXIgaGFkQ29uc3RydWN0b3IgPSBmYWxzZTtcbiAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50KG5vZGUuc3VwZXJDbGFzcyAhPT0gbnVsbCk7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBlbGVtZW50LmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcy5yYWlzZShlbGVtZW50LnN0YXJ0LCBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzc1wiKTsgfVxuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc0VsZW1lbnQgPSBmdW5jdGlvbihjb25zdHJ1Y3RvckFsbG93c1N1cGVyKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zZW1pKSkgeyByZXR1cm4gbnVsbCB9XG5cbiAgdmFyIG1ldGhvZCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciB0cnlDb250ZXh0dWFsID0gZnVuY3Rpb24gKGssIG5vTGluZUJyZWFrKSB7XG4gICAgaWYgKCBub0xpbmVCcmVhayA9PT0gdm9pZCAwICkgbm9MaW5lQnJlYWsgPSBmYWxzZTtcblxuICAgIHZhciBzdGFydCA9IHRoaXMkMS5zdGFydCwgc3RhcnRMb2MgPSB0aGlzJDEuc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzJDEuZWF0Q29udGV4dHVhbChrKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MICYmICghbm9MaW5lQnJlYWsgfHwgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChtZXRob2Qua2V5KSB7IHRoaXMkMS51bmV4cGVjdGVkKCk7IH1cbiAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICBtZXRob2Qua2V5ID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0LCBzdGFydExvYyk7XG4gICAgbWV0aG9kLmtleS5uYW1lID0gaztcbiAgICB0aGlzJDEuZmluaXNoTm9kZShtZXRob2Qua2V5LCBcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICBtZXRob2Quc3RhdGljID0gdHJ5Q29udGV4dHVhbChcInN0YXRpY1wiKTtcbiAgdmFyIGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gIHZhciBpc0FzeW5jID0gZmFsc2U7XG4gIGlmICghaXNHZW5lcmF0b3IpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgdHJ5Q29udGV4dHVhbChcImFzeW5jXCIsIHRydWUpKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIGlzR2VuZXJhdG9yID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuc3Rhcik7XG4gICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwiZ2V0XCIpKSB7XG4gICAgICBtZXRob2Qua2luZCA9IFwiZ2V0XCI7XG4gICAgfSBlbHNlIGlmICh0cnlDb250ZXh0dWFsKFwic2V0XCIpKSB7XG4gICAgICBtZXRob2Qua2luZCA9IFwic2V0XCI7XG4gICAgfVxuICB9XG4gIGlmICghbWV0aG9kLmtleSkgeyB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7IH1cbiAgdmFyIGtleSA9IG1ldGhvZC5rZXk7XG4gIHZhciBhbGxvd3NEaXJlY3RTdXBlciA9IGZhbHNlO1xuICBpZiAoIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHxcbiAgICAgIGtleS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICBpZiAobWV0aG9kLmtpbmQgIT09IFwibWV0aG9kXCIpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgaWYgKGlzR2VuZXJhdG9yKSB7IHRoaXMucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgaWYgKGlzQXN5bmMpIHsgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG4gICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBjb25zdHJ1Y3RvckFsbG93c1N1cGVyO1xuICB9IGVsc2UgaWYgKG1ldGhvZC5zdGF0aWMgJiYga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGtleS5uYW1lID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgdGhpcy5yYWlzZShrZXkuc3RhcnQsIFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgcHJvdG90eXBlXCIpO1xuICB9XG4gIHRoaXMucGFyc2VDbGFzc01ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIiAmJiBtZXRob2QudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gMClcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShtZXRob2QudmFsdWUuc3RhcnQsIFwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtc1wiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IDEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIgJiYgbWV0aG9kLnZhbHVlLnBhcmFtc1swXS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICByZXR1cm4gbWV0aG9kXG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NNZXRob2QgPSBmdW5jdGlvbihtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc0lkID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICBpZiAoaXNTdGF0ZW1lbnQpXG4gICAgICB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfTEVYSUNBTCwgZmFsc2UpOyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzU3RhdGVtZW50ID09PSB0cnVlKVxuICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIG5vZGUuaWQgPSBudWxsO1xuICB9XG59O1xuXG5wcCQxLnBhcnNlQ2xhc3NTdXBlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQodHlwZXMuX2V4dGVuZHMpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xufTtcblxuLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbnBwJDEucGFyc2VFeHBvcnQgPSBmdW5jdGlvbihub2RlLCBleHBvcnRzKSB7XG4gIHRoaXMubmV4dCgpO1xuICAvLyBleHBvcnQgKiBmcm9tICcuLi4nXG4gIGlmICh0aGlzLmVhdCh0eXBlcy5zdGFyKSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIik7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RyaW5nKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBmYWxzZSwgaXNBc3luYyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9jbGFzcykge1xuICAgICAgdmFyIGNOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLnBhcnNlQ2xhc3MoY05vZGUsIFwibnVsbGFibGVJRFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICB9XG4gIC8vIGV4cG9ydCB2YXJ8Y29uc3R8bGV0fGZ1bmN0aW9ufGNsYXNzIC4uLlxuICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gICAgICB7IHRoaXMuY2hlY2tWYXJpYWJsZUV4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk7IH1cbiAgICBlbHNlXG4gICAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5kZWNsYXJhdGlvbi5pZC5uYW1lLCBub2RlLmRlY2xhcmF0aW9uLmlkLnN0YXJ0KTsgfVxuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgfSBlbHNlIHsgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoZXhwb3J0cyk7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIikpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLnN0cmluZykgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBub2RlLnNwZWNpZmllcnM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICAgIHZhciBzcGVjID0gbGlzdFtpXTtcblxuICAgICAgICB0aGlzLmNoZWNrVW5yZXNlcnZlZChzcGVjLmxvY2FsKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgZXhwb3J0IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5jaGVja0xvY2FsRXhwb3J0KHNwZWMubG9jYWwpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEuY2hlY2tFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBwb3MpIHtcbiAgaWYgKCFleHBvcnRzKSB7IHJldHVybiB9XG4gIGlmIChoYXMoZXhwb3J0cywgbmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocG9zLCBcIkR1cGxpY2F0ZSBleHBvcnQgJ1wiICsgbmFtZSArIFwiJ1wiKTsgfVxuICBleHBvcnRzW25hbWVdID0gdHJ1ZTtcbn07XG5cbnBwJDEuY2hlY2tQYXR0ZXJuRXhwb3J0ID0gZnVuY3Rpb24oZXhwb3J0cywgcGF0KSB7XG4gIHZhciB0eXBlID0gcGF0LnR5cGU7XG4gIGlmICh0eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICB7IHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgcGF0Lm5hbWUsIHBhdC5zdGFydCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHByb3ApO1xuICAgICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBwYXQuZWxlbWVudHM7IGkkMSA8IGxpc3QkMS5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICB2YXIgZWx0ID0gbGlzdCQxW2kkMV07XG5cbiAgICAgICAgaWYgKGVsdCkgeyB0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUHJvcGVydHlcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC52YWx1ZSk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIilcbiAgICB7IHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIHBhdC5hcmd1bWVudCk7IH1cbiAgZWxzZSBpZiAodHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG59O1xuXG5wcCQxLmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGV4cG9ydHMsIGRlY2wuaWQpO1xuICB9XG59O1xuXG5wcCQxLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJ2YXJcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNvbnN0XCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJjbGFzc1wiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHRoaXMuaXNMZXQoKSB8fFxuICAgIHRoaXMuaXNBc3luY0Z1bmN0aW9uKClcbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIG1vZHVsZSBleHBvcnRzLlxuXG5wcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgLy8gZXhwb3J0IHsgeCwgeSBhcyB6IH0gW2Zyb20gJy4uLiddXG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzLnBhcnNlSWRlbnQodHJ1ZSkgOiBub2RlLmxvY2FsO1xuICAgIHRoaXMuY2hlY2tFeHBvcnQoZXhwb3J0cywgbm9kZS5leHBvcnRlZC5uYW1lLCBub2RlLmV4cG9ydGVkLnN0YXJ0KTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gaW1wb3J0ICcuLi4nXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbnBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlcy5jb21tYSkpIHsgcmV0dXJuIG5vZGVzIH1cbiAgfVxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zdGFyKSB7XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiYXNcIik7XG4gICAgbm9kZSQxLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50KCk7XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgIHJldHVybiBub2Rlc1xuICB9XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSQyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlJDIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSQyLmltcG9ydGVkKTtcbiAgICAgIG5vZGUkMi5sb2NhbCA9IG5vZGUkMi5pbXBvcnRlZDtcbiAgICB9XG4gICAgdGhpcy5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBCSU5EX0xFWElDQUwpO1xuICAgIG5vZGVzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gU2V0IGBFeHByZXNzaW9uU3RhdGVtZW50I2RpcmVjdGl2ZWAgcHJvcGVydHkgZm9yIGRpcmVjdGl2ZSBwcm9sb2d1ZXMuXG5wcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGggJiYgdGhpcy5pc0RpcmVjdGl2ZUNhbmRpZGF0ZShzdGF0ZW1lbnRzW2ldKTsgKytpKSB7XG4gICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgfVxufTtcbnBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgKVxufTtcblxudmFyIHBwJDIgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDb252ZXJ0IGV4aXN0aW5nIGV4cHJlc3Npb24gYXRvbSB0byBhc3NpZ25hYmxlIHBhdHRlcm5cbi8vIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgbm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmICh0aGlzLmluQXN5bmMgJiYgbm9kZS5uYW1lID09PSBcImF3YWl0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0JpbmRpbmcpO1xuICAgICAgICAvLyBFYXJseSBlcnJvcjpcbiAgICAgICAgLy8gICBBc3NpZ25tZW50UmVzdFByb3BlcnR5W1lpZWxkLCBBd2FpdF0gOlxuICAgICAgICAvLyAgICAgYC4uLmAgRGVzdHJ1Y3R1cmluZ0Fzc2lnbm1lbnRUYXJnZXRbWWllbGQsIEF3YWl0XVxuICAgICAgICAvL1xuICAgICAgICAvLyAgIEl0IGlzIGEgU3ludGF4IEVycm9yIGlmIHxEZXN0cnVjdHVyaW5nQXNzaWdubWVudFRhcmdldHwgaXMgYW4gfEFycmF5TGl0ZXJhbHwgb3IgYW4gfE9iamVjdExpdGVyYWx8LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiZcbiAgICAgICAgICAocHJvcC5hcmd1bWVudC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHByb3AuYXJndW1lbnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmFpc2UocHJvcC5hcmd1bWVudC5zdGFydCwgXCJVbmV4cGVjdGVkIHRva2VuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAvLyBBc3NpZ25tZW50UHJvcGVydHkgaGFzIHR5cGUgPT09IFwiUHJvcGVydHlcIlxuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJpbml0XCIpIHsgdGhpcy5yYWlzZShub2RlLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUudmFsdWUsIGlzQmluZGluZyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgbm9kZS50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5hcmd1bWVudCwgaXNCaW5kaW5nKTtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuYXJndW1lbnQuc3RhcnQsIFwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikgeyB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIik7IH1cbiAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0JpbmRpbmcpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byBBc3NpZ25tZW50UGF0dGVyblxuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGlmICghaXNCaW5kaW5nKSB7IGJyZWFrIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gQ29udmVydCBsaXN0IG9mIGV4cHJlc3Npb24gYXRvbXMgdG8gYmluZGluZyBsaXN0LlxuXG5wcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gIHZhciBlbmQgPSBleHByTGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzQmluZGluZyk7IH1cbiAgfVxuICBpZiAoZW5kKSB7XG4gICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxuLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG5wcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbn07XG5cbnBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbn07XG5cbnBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMuZXhwZWN0KHR5cGVzLmNvbW1hKTsgfVxuICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEpIHtcbiAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICB9IGVsc2UgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmVsbGlwc2lzKSB7XG4gICAgICB2YXIgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgdGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbGVtID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKTtcbiAgICAgIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0oZWxlbSk7XG4gICAgICBlbHRzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQyLnBhcnNlQmluZGluZ0xpc3RJdGVtID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgcmV0dXJuIHBhcmFtXG59O1xuXG4vLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG5wcCQyLnBhcnNlTWF5YmVEZWZhdWx0ID0gZnVuY3Rpb24oc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gIGxlZnQgPSBsZWZ0IHx8IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCAhdGhpcy5lYXQodHlwZXMuZXEpKSB7IHJldHVybiBsZWZ0IH1cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG59O1xuXG4vLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4vLyB0by5cbi8vIGJpbmRpbmdUeXBlIGNhbiBiZSBlaXRoZXI6XG4vLyAndmFyJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhICd2YXInIGJpbmRpbmdcbi8vICdsZXQnIGluZGljYXRpbmcgdGhhdCB0aGUgbHZhbCBjcmVhdGVzIGEgbGV4aWNhbCAoJ2xldCcgb3IgJ2NvbnN0JykgYmluZGluZ1xuLy8gJ25vbmUnIGluZGljYXRpbmcgdGhhdCB0aGUgYmluZGluZyBzaG91bGQgYmUgY2hlY2tlZCBmb3IgaWxsZWdhbCBpZGVudGlmaWVycywgYnV0IG5vdCBmb3IgZHVwbGljYXRlIHJlZmVyZW5jZXNcblxucHAkMi5jaGVja0xWYWwgPSBmdW5jdGlvbihleHByLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKSB7XG4gIGlmICggYmluZGluZ1R5cGUgPT09IHZvaWQgMCApIGJpbmRpbmdUeXBlID0gQklORF9OT05FO1xuXG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwgJiYgZXhwci5uYW1lID09PSBcImxldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJsZXQgaXMgZGlzYWxsb3dlZCBhcyBhIGxleGljYWxseSBib3VuZCBuYW1lXCIpOyB9XG4gICAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQudGVzdChleHByLm5hbWUpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nIFwiIDogXCJBc3NpZ25pbmcgdG8gXCIpICsgZXhwci5uYW1lICsgXCIgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpOyB9XG4gICAgICBjaGVja0NsYXNoZXNbZXhwci5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAhPT0gQklORF9OT05FICYmIGJpbmRpbmdUeXBlICE9PSBCSU5EX09VVFNJREUpIHsgdGhpcy5kZWNsYXJlTmFtZShleHByLm5hbWUsIGJpbmRpbmdUeXBlLCBleHByLnN0YXJ0KTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBpZiAoYmluZGluZ1R5cGUpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQmluZGluZyBtZW1iZXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGJyZWFrXG5cbiAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IGV4cHIucHJvcGVydGllczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAgICB7XG4gICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWwocHJvcCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgIC8vIEFzc2lnbm1lbnRQcm9wZXJ0eSBoYXMgdHlwZSA9PT0gXCJQcm9wZXJ0eVwiXG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gZXhwci5lbGVtZW50czsgaSQxIDwgbGlzdCQxLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgIHZhciBlbGVtID0gbGlzdCQxW2kkMV07XG5cbiAgICBpZiAoZWxlbSkgeyB0aGlzLmNoZWNrTFZhbChlbGVtLCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTsgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBiaW5kaW5nVHlwZSwgY2hlY2tDbGFzaGVzKTtcbiAgICBicmVha1xuXG4gIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBkZWZhdWx0OlxuICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGJpbmRpbmdUeXBlID8gXCJCaW5kaW5nXCIgOiBcIkFzc2lnbmluZyB0b1wiKSArIFwiIHJ2YWx1ZVwiKTtcbiAgfVxufTtcblxuLy8gQSByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgb3BlcmF0ZXMgYnkgZGVmaW5pbmcgZnVuY3Rpb25zIGZvciBhbGxcblxudmFyIHBwJDMgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuLy8gZWl0aGVyIHdpdGggZWFjaCBvdGhlciBvciB3aXRoIGFuIGluaXQgcHJvcGVydHkg4oCUIGFuZCBpblxuLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxucHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiBwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKVxuICAgIHsgcmV0dXJuIH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIChwcm9wLmNvbXB1dGVkIHx8IHByb3AubWV0aG9kIHx8IHByb3Auc2hvcnRoYW5kKSlcbiAgICB7IHJldHVybiB9XG4gIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgdmFyIG5hbWU7XG4gIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgY2FzZSBcIklkZW50aWZpZXJcIjogbmFtZSA9IGtleS5uYW1lOyBicmVha1xuICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gIGRlZmF1bHQ6IHJldHVyblxuICB9XG4gIHZhciBraW5kID0gcHJvcC5raW5kO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIiAmJiBraW5kID09PSBcImluaXRcIikge1xuICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB7XG4gICAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPCAwKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuZG91YmxlUHJvdG8gPSBrZXkuc3RhcnQ7IH1cbiAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdCBrbHVkZ2UuIENhbiBiZSByZW1vdmVkIGluIHZlcnNpb24gNi4wXG4gICAgICAgIGVsc2UgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgIH1cbiAgICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gIGlmIChvdGhlcikge1xuICAgIHZhciByZWRlZmluaXRpb247XG4gICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICByZWRlZmluaXRpb24gPSB0aGlzLnN0cmljdCAmJiBvdGhlci5pbml0IHx8IG90aGVyLmdldCB8fCBvdGhlci5zZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgfVxuICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgIHNldDogZmFsc2VcbiAgICB9O1xuICB9XG4gIG90aGVyW2tpbmRdID0gdHJ1ZTtcbn07XG5cbi8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4vLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4vLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4vLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuLy8gZm9yYmlkIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucylcbi8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4vLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4vLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxucHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBQYXJzZSBhbiBhc3NpZ25tZW50IGV4cHJlc3Npb24uIFRoaXMgaW5jbHVkZXMgYXBwbGljYXRpb25zIG9mXG4vLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG5wcCQzLnBhcnNlTWF5YmVBc3NpZ24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICBpZiAodGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkge1xuICAgIGlmICh0aGlzLmluR2VuZXJhdG9yKSB7IHJldHVybiB0aGlzLnBhcnNlWWllbGQobm9JbikgfVxuICAgIC8vIFRoZSB0b2tlbml6ZXIgd2lsbCBhc3N1bWUgYW4gZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGFmdGVyXG4gICAgLy8gYHlpZWxkYCwgYnV0IHRoaXMgaXNuJ3QgdGhhdCBraW5kIG9mIHlpZWxkXG4gICAgZWxzZSB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICB9XG5cbiAgdmFyIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSBmYWxzZSwgb2xkUGFyZW5Bc3NpZ24gPSAtMSwgb2xkVHJhaWxpbmdDb21tYSA9IC0xLCBvbGRTaG9ydGhhbmRBc3NpZ24gPSAtMTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICBvbGRQYXJlbkFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbjtcbiAgICBvbGRUcmFpbGluZ0NvbW1hID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hO1xuICAgIG9sZFNob3J0aGFuZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduO1xuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5wYXJlbkwgfHwgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vcGVyYXRvciA9IHRoaXMudmFsdWU7XG4gICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0eXBlcy5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSA6IGxlZnQ7XG4gICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IERlc3RydWN0dXJpbmdFcnJvcnMuY2FsbChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduID0gLTE7IC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgdGhpcy5jaGVja0xWYWwobGVmdCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIilcbiAgfSBlbHNlIHtcbiAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTsgfVxuICB9XG4gIGlmIChvbGRQYXJlbkFzc2lnbiA+IC0xKSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IG9sZFBhcmVuQXNzaWduOyB9XG4gIGlmIChvbGRUcmFpbGluZ0NvbW1hID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gb2xkVHJhaWxpbmdDb21tYTsgfVxuICBpZiAob2xkU2hvcnRoYW5kQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSBvbGRTaG9ydGhhbmRBc3NpZ247IH1cbiAgcmV0dXJuIGxlZnRcbn07XG5cbi8vIFBhcnNlIGEgdGVybmFyeSBjb25kaXRpb25hbCAoYD86YCkgb3BlcmF0b3IuXG5cbnBwJDMucGFyc2VNYXliZUNvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZUV4cHJPcHMobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5xdWVzdGlvbikpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLmNvbG9uKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxucHAkMy5wYXJzZUV4cHJPcHMgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCBmYWxzZSk7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgeyByZXR1cm4gZXhwciB9XG4gIHJldHVybiBleHByLnN0YXJ0ID09PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVmdFxufTtcblxucHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLm9wZXJhdG9yID0gb3A7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKFwiYXdhaXRcIikgJiYgKHRoaXMuaW5Bc3luYyB8fCAoIXRoaXMuaW5GdW5jdGlvbiAmJiB0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikpKSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlJDEub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgICAgbm9kZSQxLnByZWZpeCA9IGZhbHNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2F3VW5hcnkgJiYgdGhpcy5lYXQodHlwZXMuc3RhcnN0YXIpKVxuICAgIHsgcmV0dXJuIHRoaXMuYnVpbGRCaW5hcnkoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByLCB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIFwiKipcIiwgZmFsc2UpIH1cbiAgZWxzZVxuICAgIHsgcmV0dXJuIGV4cHIgfVxufTtcblxuLy8gUGFyc2UgY2FsbCwgZG90LCBhbmQgYFtdYC1zdWJzY3JpcHQgZXhwcmVzc2lvbnMuXG5cbnBwJDMucGFyc2VFeHByU3Vic2NyaXB0cyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgdmFyIHNraXBBcnJvd1N1YnNjcmlwdHMgPSBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tFbmQpICE9PSBcIilcIjtcbiAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHx8IHNraXBBcnJvd1N1YnNjcmlwdHMpIHsgcmV0dXJuIGV4cHIgfVxuICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVzdWx0LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gLTE7IH1cbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA+PSByZXN1bHQuc3RhcnQpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQmluZCA9IC0xOyB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdHMgPSBmdW5jdGlvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgdmFyIG1heWJlQXN5bmNBcnJvdyA9IHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAgIHRoaXMubGFzdFRva0VuZCA9PT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5pbnB1dC5zbGljZShiYXNlLnN0YXJ0LCBiYXNlLmVuZCkgPT09IFwiYXN5bmNcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBtYXliZUFzeW5jQXJyb3cpO1xuICAgIGlmIChlbGVtZW50ID09PSBiYXNlIHx8IGVsZW1lbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7IHJldHVybiBlbGVtZW50IH1cbiAgICBiYXNlID0gZWxlbWVudDtcbiAgfVxufTtcblxucHAkMy5wYXJzZVN1YnNjcmlwdCA9IGZ1bmN0aW9uKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgbWF5YmVBc3luY0Fycm93KSB7XG4gIHZhciBjb21wdXRlZCA9IHRoaXMuZWF0KHR5cGVzLmJyYWNrZXRMKTtcbiAgaWYgKGNvbXB1dGVkIHx8IHRoaXMuZWF0KHR5cGVzLmRvdCkpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IGNvbXB1dGVkID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCAhPT0gXCJuZXZlclwiKTtcbiAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHsgdGhpcy5leHBlY3QodHlwZXMuYnJhY2tldFIpOyB9XG4gICAgYmFzZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBvbGRBd2FpdElkZW50UG9zID0gdGhpcy5hd2FpdElkZW50UG9zO1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IDA7XG4gICAgdmFyIGV4cHJMaXN0ID0gdGhpcy5wYXJzZUV4cHJMaXN0KHR5cGVzLnBhcmVuUiwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDggJiYgYmFzZS50eXBlICE9PSBcIkltcG9ydFwiLCBmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5hcnJvdykpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgIHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCk7XG4gICAgICBpZiAodGhpcy5hd2FpdElkZW50UG9zID4gMClcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuYXdhaXRJZGVudFBvcywgXCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgIH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcbiAgICB0aGlzLmF3YWl0SWRlbnRQb3MgPSBvbGRBd2FpdElkZW50UG9zIHx8IHRoaXMuYXdhaXRJZGVudFBvcztcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgIG5vZGUkMS5hcmd1bWVudHMgPSBleHByTGlzdDtcbiAgICBpZiAobm9kZSQxLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICBpZiAobm9kZSQxLmFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShub2RlJDEuc3RhcnQsIFwiaW1wb3J0KCkgcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbXBvcnRBcmcgPSBub2RlJDEuYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGltcG9ydEFyZyAmJiBpbXBvcnRBcmcudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShpbXBvcnRBcmcuc3RhcnQsIFwiLi4uIGlzIG5vdCBhbGxvd2VkIGluIGltcG9ydCgpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBiYXNlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZSkge1xuICAgIHZhciBub2RlJDIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZSQyLnRhZyA9IGJhc2U7XG4gICAgbm9kZSQyLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHtpc1RhZ2dlZDogdHJ1ZX0pO1xuICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSQyLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICByZXR1cm4gYmFzZVxufTtcblxuLy8gUGFyc2UgYW4gYXRvbWljIGV4cHJlc3Npb24g4oCUIGVpdGhlciBhIHNpbmdsZSB0b2tlbiB0aGF0IGlzIGFuXG4vLyBleHByZXNzaW9uLCBhbiBleHByZXNzaW9uIHN0YXJ0ZWQgYnkgYSBrZXl3b3JkIGxpa2UgYGZ1bmN0aW9uYCBvclxuLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4vLyBvciBge31gLlxuXG5wcCQzLnBhcnNlRXhwckF0b20gPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIC8vIElmIGEgZGl2aXNpb24gb3BlcmF0b3IgYXBwZWFycyBpbiBhbiBleHByZXNzaW9uIHBvc2l0aW9uLCB0aGVcbiAgLy8gdG9rZW5pemVyIGdvdCBjb25mdXNlZCwgYW5kIHdlIGZvcmNlIGl0IHRvIHJlYWQgYSByZWdleHAgaW5zdGVhZC5cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc2xhc2gpIHsgdGhpcy5yZWFkUmVnZXhwKCk7IH1cblxuICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGFydDtcbiAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgY2FzZSB0eXBlcy5fc3VwZXI6XG4gICAgaWYgKCF0aGlzLmFsbG93U3VwZXIpXG4gICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIGtleXdvcmQgb3V0c2lkZSBhIG1ldGhvZFwiKTsgfVxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhdGhpcy5hbGxvd0RpcmVjdFN1cGVyKVxuICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzc1wiKTsgfVxuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciBBcmd1bWVudHNcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICBjYXNlIHR5cGVzLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMubmFtZTpcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQoZmFsc2UpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLl9mdW5jdGlvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCAwLCBmYWxzZSwgdHJ1ZSkgfVxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5lYXQodHlwZXMuYXJyb3cpKVxuICAgICAgICB7IHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgZmFsc2UpIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBpZC5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy50eXBlID09PSB0eXBlcy5uYW1lICYmICFjb250YWluc0VzYykge1xuICAgICAgICBpZCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0sIHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZFxuXG4gIGNhc2UgdHlwZXMucmVnZXhwOlxuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKTtcbiAgICBub2RlLnJlZ2V4ID0ge3BhdHRlcm46IHZhbHVlLnBhdHRlcm4sIGZsYWdzOiB2YWx1ZS5mbGFnc307XG4gICAgcmV0dXJuIG5vZGVcblxuICBjYXNlIHR5cGVzLm51bTogY2FzZSB0eXBlcy5zdHJpbmc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgY2FzZSB0eXBlcy5fbnVsbDogY2FzZSB0eXBlcy5fdHJ1ZTogY2FzZSB0eXBlcy5fZmFsc2U6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX251bGwgPyBudWxsIDogdGhpcy50eXBlID09PSB0eXBlcy5fdHJ1ZTtcbiAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJMaXRlcmFsXCIpXG5cbiAgY2FzZSB0eXBlcy5wYXJlbkw6XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydCwgZXhwciA9IHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA8IDAgJiYgIXRoaXMuaXNTaW1wbGVBc3NpZ25UYXJnZXQoZXhwcikpXG4gICAgICAgIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gc3RhcnQ7IH1cbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kID0gc3RhcnQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcblxuICBjYXNlIHR5cGVzLmJyYWNrZXRMOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICBjYXNlIHR5cGVzLmJyYWNlTDpcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9iaihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcblxuICBjYXNlIHR5cGVzLl9mdW5jdGlvbjpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDApXG5cbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gIGNhc2UgdHlwZXMuX2ltcG9ydDpcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID4gMTApIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgIH1cblxuICBkZWZhdWx0OlxuICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG59O1xuXG5wcCQzLnBhcnNlRHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5wYXJlbkwpIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpXG59O1xuXG5wcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLnJhdyA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICBpZiAobm9kZS5yYXcuY2hhckNvZGVBdChub2RlLnJhdy5sZW5ndGggLSAxKSA9PT0gMTEwKSB7IG5vZGUuYmlnaW50ID0gbm9kZS5yYXcuc2xpY2UoMCwgLTEpOyB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxufTtcblxucHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydDtcbiAgICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgICAvLyBEbyBub3Qgc2F2ZSBhd2FpdElkZW50UG9zIHRvIGFsbG93IGNoZWNraW5nIGF3YWl0cyBuZXN0ZWQgaW4gcGFyYW1ldGVyc1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5wYXJlblIsIHRydWUpKSB7XG4gICAgICAgIGxhc3RJc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbi8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuLy8gYXJndW1lbnQgbGlzdC5cblxudmFyIGVtcHR5JDEgPSBbXTtcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IFwidGFyZ2V0XCIgfHwgY29udGFpbnNFc2MpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnByb3BlcnR5LnN0YXJ0LCBcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyBuZXcudGFyZ2V0XCIpOyB9XG4gICAgaWYgKCF0aGlzLmluTm9uQXJyb3dGdW5jdGlvbigpKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+IDEwICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICB0aGlzLnJhaXNlKG5vZGUuY2FsbGVlLnN0YXJ0LCBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLilcIik7XG4gIH1cbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBub2RlLmNhbGxlZS50eXBlICE9PSBcIkltcG9ydFwiLCBmYWxzZSk7IH1cbiAgZWxzZSB7IG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTmV3RXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgdGVtcGxhdGUgZXhwcmVzc2lvbi5cblxucHAkMy5wYXJzZVRlbXBsYXRlRWxlbWVudCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7XG5cbiAgdmFyIGVsZW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpIHtcbiAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgfVxuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMudmFsdWUsXG4gICAgICBjb29rZWQ6IG51bGxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksXG4gICAgICBjb29rZWQ6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICBlbGVtLnRhaWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmJhY2tRdW90ZTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxufTtcblxucHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkOyBpZiAoIGlzVGFnZ2VkID09PSB2b2lkIDAgKSBpc1RhZ2dlZCA9IGZhbHNlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZXhwcmVzc2lvbnMgPSBbXTtcbiAgdmFyIGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOiBpc1RhZ2dlZH0pO1xuICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuICB3aGlsZSAoIWN1ckVsdC50YWlsKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWxcIik7IH1cbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5kb2xsYXJCcmFjZUwpO1xuICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSkpO1xuICB9XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpXG59O1xuXG5wcCQzLmlzQXN5bmNQcm9wID0gZnVuY3Rpb24ocHJvcCkge1xuICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcHJvcC5rZXkubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgKHRoaXMudHlwZSA9PT0gdHlwZXMubmFtZSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLm51bSB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmJyYWNrZXRMIHx8IHRoaXMudHlwZS5rZXl3b3JkIHx8ICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLnN0YXIpKSAmJlxuICAgICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgbGl0ZXJhbCBvciBiaW5kaW5nIHBhdHRlcm4uXG5cbnBwJDMucGFyc2VPYmogPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBmaXJzdCA9IHRydWUsIHByb3BIYXNoID0ge307XG4gIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKHRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5KGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKCFpc1BhdHRlcm4pIHsgdGhpcy5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7IH1cbiAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzUGF0dGVybiA/IFwiT2JqZWN0UGF0dGVyblwiIDogXCJPYmplY3RFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHkgPSBmdW5jdGlvbihpc1BhdHRlcm4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgaXNBc3luYywgc3RhcnRQb3MsIHN0YXJ0TG9jO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgdGhpcy5lYXQodHlwZXMuZWxsaXBzaXMpKSB7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudChmYWxzZSk7XG4gICAgICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5jb21tYSkge1xuICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpXG4gICAgfVxuICAgIC8vIFRvIGRpc2FsbG93IHBhcmVudGhlc2l6ZWQgaWRlbnRpZmllciB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCkge1xuICAgICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKSB7XG4gICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSB0aGlzLnN0YXJ0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBhcmd1bWVudC5cbiAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAvLyBUbyBkaXNhbGxvdyB0cmFpbGluZyBjb21tYSB2aWEgYHRoaXMudG9Bc3NpZ25hYmxlKClgLlxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMCkge1xuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgLy8gRmluaXNoXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBzdGFydFBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgfVxuICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgeyBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gIH1cbiAgdmFyIGNvbnRhaW5zRXNjID0gdGhpcy5jb250YWluc0VzYztcbiAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgaWYgKCFpc1BhdHRlcm4gJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiB0aGlzLmlzQXN5bmNQcm9wKHByb3ApKSB7XG4gICAgaXNBc3luYyA9IHRydWU7XG4gICAgaXNHZW5lcmF0b3IgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSAmJiB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICB9IGVsc2Uge1xuICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGNvbnRhaW5zRXNjKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlByb3BlcnR5XCIpXG59O1xuXG5wcCQzLnBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgY29udGFpbnNFc2MpIHtcbiAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJiAhY29udGFpbnNFc2MgJiZcbiAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNSAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxuICAgICAgICAgICAgIChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmXG4gICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gdHlwZXMuY29tbWEgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIGlmIChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQocHJvcC5rZXkpO1xuICAgIGlmIChwcm9wLmtleS5uYW1lID09PSBcImF3YWl0XCIgJiYgIXRoaXMuYXdhaXRJZGVudFBvcylcbiAgICAgIHsgdGhpcy5hd2FpdElkZW50UG9zID0gc3RhcnRQb3M7IH1cbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgIT09IFwibmV2ZXJcIilcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgbm9kZS5nZW5lcmF0b3IgPSBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9IGZhbHNlOyB9XG59O1xuXG4vLyBQYXJzZSBvYmplY3Qgb3IgY2xhc3MgbWV0aG9kLlxuXG5wcCQzLnBhcnNlTWV0aG9kID0gZnVuY3Rpb24oaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGFsbG93RGlyZWN0U3VwZXIpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy55aWVsZFBvcyA9IDA7XG4gIHRoaXMuYXdhaXRQb3MgPSAwO1xuICB0aGlzLmF3YWl0SWRlbnRQb3MgPSAwO1xuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikgfCBTQ09QRV9TVVBFUiB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuXG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgdGhpcy55aWVsZFBvcyA9IG9sZFlpZWxkUG9zO1xuICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gIHRoaXMuYXdhaXRJZGVudFBvcyA9IG9sZEF3YWl0SWRlbnRQb3M7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkQXdhaXRJZGVudFBvcyA9IHRoaXMuYXdhaXRJZGVudFBvcztcblxuICB0aGlzLmVudGVyU2NvcGUoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSkgfCBTQ09QRV9BUlJPVyk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpIHsgbm9kZS5hc3luYyA9ICEhaXNBc3luYzsgfVxuXG4gIHRoaXMueWllbGRQb3MgPSAwO1xuICB0aGlzLmF3YWl0UG9zID0gMDtcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gMDtcblxuICBub2RlLnBhcmFtcyA9IHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRydWUpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGZhbHNlKTtcblxuICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3M7XG4gIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgdGhpcy5hd2FpdElkZW50UG9zID0gb2xkQXdhaXRJZGVudFBvcztcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSBmdW5jdGlvbiBib2R5IGFuZCBjaGVjayBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24obm9kZSwgaXNBcnJvd0Z1bmN0aW9uLCBpc01ldGhvZCkge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmICFpc01ldGhvZCAmJiB0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKGZhbHNlKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUobm9kZS5ib2R5LmJvZHkpO1xuICAgIHRoaXMubGFiZWxzID0gb2xkTGFiZWxzO1xuICB9XG4gIHRoaXMuZXhpdFNjb3BlKCk7XG5cbiAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7IHRoaXMuY2hlY2tMVmFsKG5vZGUuaWQsIEJJTkRfT1VUU0lERSk7IH1cbiAgdGhpcy5zdHJpY3QgPSBvbGRTdHJpY3Q7XG59O1xuXG5wcCQzLmlzU2ltcGxlUGFyYW1MaXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gcGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIGlmIChwYXJhbS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgeyByZXR1cm4gZmFsc2VcbiAgfSB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuLy8gb3IgXCJhcmd1bWVudHNcIiBhbmQgZHVwbGljYXRlIHBhcmFtZXRlcnMuXG5cbnBwJDMuY2hlY2tQYXJhbXMgPSBmdW5jdGlvbihub2RlLCBhbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIG5hbWVIYXNoID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wYXJhbXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgIHtcbiAgICB2YXIgcGFyYW0gPSBsaXN0W2ldO1xuXG4gICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIEJJTkRfVkFSLCBhbGxvd0R1cGxpY2F0ZXMgPyBudWxsIDogbmFtZUhhc2gpO1xuICB9XG59O1xuXG4vLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBleHByZXNzaW9ucywgYW5kIHJldHVybnMgdGhlbSBhc1xuLy8gYW4gYXJyYXkuIGBjbG9zZWAgaXMgdGhlIHRva2VuIHR5cGUgdGhhdCBlbmRzIHRoZSBsaXN0LCBhbmRcbi8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbi8vIG5vdGhpbmcgaW4gYmV0d2VlbiB0aGVtIHRvIGJlIHBhcnNlZCBhcyBgbnVsbGAgKHdoaWNoIGlzIG5lZWRlZFxuLy8gZm9yIGFycmF5IGxpdGVyYWxzKS5cblxucHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgZWx0cyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcy5leHBlY3QodHlwZXMuY29tbWEpO1xuICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKVxuICAgICAgeyBlbHQgPSBudWxsOyB9XG4gICAgZWxzZSBpZiAodGhpcy50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMudHlwZSA9PT0gdHlwZXMuY29tbWEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSB0aGlzLnN0YXJ0OyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3JcIik7IH1cbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gIGlmICh0aGlzLmtleXdvcmRzLnRlc3QobmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlKHN0YXJ0LCAoXCJVbmV4cGVjdGVkIGtleXdvcmQgJ1wiICsgbmFtZSArIFwiJ1wiKSk7IH1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgJiZcbiAgICB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLmluZGV4T2YoXCJcXFxcXCIpICE9PSAtMSkgeyByZXR1cm4gfVxuICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgaWYgKHJlLnRlc3QobmFtZSkpIHtcbiAgICBpZiAoIXRoaXMuaW5Bc3luYyAmJiBuYW1lID09PSBcImF3YWl0XCIpXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIpOyB9XG4gICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCAoXCJUaGUga2V5d29yZCAnXCIgKyBuYW1lICsgXCInIGlzIHJlc2VydmVkXCIpKTtcbiAgfVxufTtcblxuLy8gUGFyc2UgdGhlIG5leHQgdG9rZW4gYXMgYW4gaWRlbnRpZmllci4gSWYgYGxpYmVyYWxgIGlzIHRydWUgKHVzZWRcbi8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuLy8gaWRlbnRpZmllcnMuXG5cbnBwJDMucGFyc2VJZGVudCA9IGZ1bmN0aW9uKGxpYmVyYWwsIGlzQmluZGluZykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50eXBlLmtleXdvcmQ7XG5cbiAgICAvLyBUbyBmaXggaHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7XG4gICAgdGhpcy5jaGVja1VucmVzZXJ2ZWQobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJhd2FpdFwiICYmICF0aGlzLmF3YWl0SWRlbnRQb3MpXG4gICAgICB7IHRoaXMuYXdhaXRJZGVudFBvcyA9IG5vZGUuc3RhcnQ7IH1cbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gUGFyc2VzIHlpZWxkIGV4cHJlc3Npb24gaW5zaWRlIGdlbmVyYXRvci5cblxucHAkMy5wYXJzZVlpZWxkID0gZnVuY3Rpb24obm9Jbikge1xuICBpZiAoIXRoaXMueWllbGRQb3MpIHsgdGhpcy55aWVsZFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPT0gdHlwZXMuc3RhciAmJiAhdGhpcy50eXBlLnN0YXJ0c0V4cHIpKSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGZhbHNlO1xuICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGVsZWdhdGUgPSB0aGlzLmVhdCh0eXBlcy5zdGFyKTtcbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VBd2FpdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuYXdhaXRQb3MpIHsgdGhpcy5hd2FpdFBvcyA9IHRoaXMuc3RhcnQ7IH1cblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIilcbn07XG5cbnZhciBwcCQ0ID0gUGFyc2VyLnByb3RvdHlwZTtcblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbi8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4vLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbi8vIG1lc3NhZ2UuXG5cbnBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gIHRocm93IGVyclxufTtcblxucHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxucHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICB9XG59O1xuXG52YXIgcHAkNSA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBTY29wZSA9IGZ1bmN0aW9uIFNjb3BlKGZsYWdzKSB7XG4gIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgLy8gQSBsaXN0IG9mIHZhci1kZWNsYXJlZCBuYW1lcyBpbiB0aGUgY3VycmVudCBsZXhpY2FsIHNjb3BlXG4gIHRoaXMudmFyID0gW107XG4gIC8vIEEgbGlzdCBvZiBsZXhpY2FsbHktZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICB0aGlzLmxleGljYWwgPSBbXTtcbiAgLy8gQSBsaXN0IG9mIGxleGljYWxseS1kZWNsYXJlZCBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgdGhpcy5mdW5jdGlvbnMgPSBbXTtcbn07XG5cbi8vIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUga2VlcCB0cmFjayBvZiBkZWNsYXJlZCB2YXJpYWJsZXMgaW4gdGhlIGN1cnJlbnQgc2NvcGUgaW4gb3JkZXIgdG8gZGV0ZWN0IGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lcy5cblxucHAkNS5lbnRlclNjb3BlID0gZnVuY3Rpb24oZmxhZ3MpIHtcbiAgdGhpcy5zY29wZVN0YWNrLnB1c2gobmV3IFNjb3BlKGZsYWdzKSk7XG59O1xuXG5wcCQ1LmV4aXRTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG59O1xuXG4vLyBUaGUgc3BlYyBzYXlzOlxuLy8gPiBBdCB0aGUgdG9wIGxldmVsIG9mIGEgZnVuY3Rpb24sIG9yIHNjcmlwdCwgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFyZVxuLy8gPiB0cmVhdGVkIGxpa2UgdmFyIGRlY2xhcmF0aW9ucyByYXRoZXIgdGhhbiBsaWtlIGxleGljYWwgZGVjbGFyYXRpb25zLlxucHAkNS50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSA9IGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHJldHVybiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9GVU5DVElPTikgfHwgIXRoaXMuaW5Nb2R1bGUgJiYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVE9QKVxufTtcblxucHAkNS5kZWNsYXJlTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIGJpbmRpbmdUeXBlLCBwb3MpIHtcbiAgdmFyIHJlZGVjbGFyZWQgPSBmYWxzZTtcbiAgaWYgKGJpbmRpbmdUeXBlID09PSBCSU5EX0xFWElDQUwpIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIHJlZGVjbGFyZWQgPSBzY29wZS5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSB8fCBzY29wZS5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlLnZhci5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgc2NvcGUubGV4aWNhbC5wdXNoKG5hbWUpO1xuICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZS5mbGFncyAmIFNDT1BFX1RPUCkpXG4gICAgICB7IGRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbbmFtZV07IH1cbiAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9TSU1QTEVfQ0FUQ0gpIHtcbiAgICB2YXIgc2NvcGUkMSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgc2NvcGUkMS5sZXhpY2FsLnB1c2gobmFtZSk7XG4gIH0gZWxzZSBpZiAoYmluZGluZ1R5cGUgPT09IEJJTkRfRlVOQ1RJT04pIHtcbiAgICB2YXIgc2NvcGUkMiA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgaWYgKHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhcilcbiAgICAgIHsgcmVkZWNsYXJlZCA9IHNjb3BlJDIubGV4aWNhbC5pbmRleE9mKG5hbWUpID4gLTE7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZGVjbGFyZWQgPSBzY29wZSQyLmxleGljYWwuaW5kZXhPZihuYW1lKSA+IC0xIHx8IHNjb3BlJDIudmFyLmluZGV4T2YobmFtZSkgPiAtMTsgfVxuICAgIHNjb3BlJDIuZnVuY3Rpb25zLnB1c2gobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdmFyIHNjb3BlJDMgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoc2NvcGUkMy5sZXhpY2FsLmluZGV4T2YobmFtZSkgPiAtMSAmJiAhKChzY29wZSQzLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIKSAmJiBzY29wZSQzLmxleGljYWxbMF0gPT09IG5hbWUpIHx8XG4gICAgICAgICAgIXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUkMykgJiYgc2NvcGUkMy5mdW5jdGlvbnMuaW5kZXhPZihuYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlZGVjbGFyZWQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2NvcGUkMy52YXIucHVzaChuYW1lKTtcbiAgICAgIGlmICh0aGlzLmluTW9kdWxlICYmIChzY29wZSQzLmZsYWdzICYgU0NPUEVfVE9QKSlcbiAgICAgICAgeyBkZWxldGUgdGhpcy51bmRlZmluZWRFeHBvcnRzW25hbWVdOyB9XG4gICAgICBpZiAoc2NvcGUkMy5mbGFncyAmIFNDT1BFX1ZBUikgeyBicmVhayB9XG4gICAgfVxuICB9XG4gIGlmIChyZWRlY2xhcmVkKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIChcIklkZW50aWZpZXIgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTsgfVxufTtcblxucHAkNS5jaGVja0xvY2FsRXhwb3J0ID0gZnVuY3Rpb24oaWQpIHtcbiAgLy8gc2NvcGUuZnVuY3Rpb25zIG11c3QgYmUgZW1wdHkgYXMgTW9kdWxlIGNvZGUgaXMgYWx3YXlzIHN0cmljdC5cbiAgaWYgKHRoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoaWQubmFtZSkgPT09IC0xICYmXG4gICAgICB0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoaWQubmFtZSkgPT09IC0xKSB7XG4gICAgdGhpcy51bmRlZmluZWRFeHBvcnRzW2lkLm5hbWVdID0gaWQ7XG4gIH1cbn07XG5cbnBwJDUuY3VycmVudFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdXG59O1xuXG5wcCQ1LmN1cnJlbnRWYXJTY29wZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSB7IHJldHVybiBzY29wZSB9XG4gIH1cbn07XG5cbi8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgYHRoaXNgLCBgbmV3LnRhcmdldGAsIGBzdXBlcigpYCwgYHN1cGVyLnByb3BlcnR5YCwgYW5kIGBzdXBlcltwcm9wZXJ0eV1gLlxucHAkNS5jdXJyZW50VGhpc1Njb3BlID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgIHZhciBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICBpZiAoc2NvcGUuZmxhZ3MgJiBTQ09QRV9WQVIgJiYgIShzY29wZS5mbGFncyAmIFNDT1BFX0FSUk9XKSkgeyByZXR1cm4gc2NvcGUgfVxuICB9XG59O1xuXG52YXIgTm9kZSA9IGZ1bmN0aW9uIE5vZGUocGFyc2VyLCBwb3MsIGxvYykge1xuICB0aGlzLnR5cGUgPSBcIlwiO1xuICB0aGlzLnN0YXJ0ID0gcG9zO1xuICB0aGlzLmVuZCA9IDA7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwYXJzZXIsIGxvYyk7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgeyB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlOyB9XG4gIGlmIChwYXJzZXIub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3BvcywgMF07IH1cbn07XG5cbi8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbnZhciBwcCQ2ID0gUGFyc2VyLnByb3RvdHlwZTtcblxucHAkNi5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhcnQsIHRoaXMuc3RhcnRMb2MpXG59O1xuXG5wcCQ2LnN0YXJ0Tm9kZUF0ID0gZnVuY3Rpb24ocG9zLCBsb2MpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHBvcywgbG9jKVxufTtcblxuLy8gRmluaXNoIGFuIEFTVCBub2RlLCBhZGRpbmcgYHR5cGVgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzLlxuXG5mdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgbm9kZS50eXBlID0gdHlwZTtcbiAgbm9kZS5lbmQgPSBwb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKVxuICAgIHsgbm9kZS5sb2MuZW5kID0gbG9jOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgIHsgbm9kZS5yYW5nZVsxXSA9IHBvczsgfVxuICByZXR1cm4gbm9kZVxufVxuXG5wcCQ2LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCB0aGlzLmxhc3RUb2tFbmQsIHRoaXMubGFzdFRva0VuZExvYylcbn07XG5cbi8vIEZpbmlzaCBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXG5cbnBwJDYuZmluaXNoTm9kZUF0ID0gZnVuY3Rpb24obm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxufTtcblxuLy8gVGhlIGFsZ29yaXRobSB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcmVnZXhwIGNhbiBhcHBlYXIgYXQgYVxuXG52YXIgVG9rQ29udGV4dCA9IGZ1bmN0aW9uIFRva0NvbnRleHQodG9rZW4sIGlzRXhwciwgcHJlc2VydmVTcGFjZSwgb3ZlcnJpZGUsIGdlbmVyYXRvcikge1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHRoaXMuaXNFeHByID0gISFpc0V4cHI7XG4gIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICB0aGlzLmdlbmVyYXRvciA9ICEhZ2VuZXJhdG9yO1xufTtcblxudmFyIHR5cGVzJDEgPSB7XG4gIGJfc3RhdDogbmV3IFRva0NvbnRleHQoXCJ7XCIsIGZhbHNlKSxcbiAgYl9leHByOiBuZXcgVG9rQ29udGV4dChcIntcIiwgdHJ1ZSksXG4gIGJfdG1wbDogbmV3IFRva0NvbnRleHQoXCIke1wiLCBmYWxzZSksXG4gIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgcF9leHByOiBuZXcgVG9rQ29udGV4dChcIihcIiwgdHJ1ZSksXG4gIHFfdG1wbDogbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUsIHRydWUsIGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRyeVJlYWRUZW1wbGF0ZVRva2VuKCk7IH0pLFxuICBmX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgZmFsc2UpLFxuICBmX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSksXG4gIGZfZXhwcl9nZW46IG5ldyBUb2tDb250ZXh0KFwiZnVuY3Rpb25cIiwgdHJ1ZSwgZmFsc2UsIG51bGwsIHRydWUpLFxuICBmX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSwgZmFsc2UsIG51bGwsIHRydWUpXG59O1xuXG52YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnBwJDcuaW5pdGlhbENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0eXBlcyQxLmJfc3RhdF1cbn07XG5cbnBwJDcuYnJhY2VJc0Jsb2NrID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAocGFyZW50ID09PSB0eXBlcyQxLmZfZXhwciB8fCBwYXJlbnQgPT09IHR5cGVzJDEuZl9zdGF0KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLmNvbG9uICYmIChwYXJlbnQgPT09IHR5cGVzJDEuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMkMS5iX2V4cHIpKVxuICAgIHsgcmV0dXJuICFwYXJlbnQuaXNFeHByIH1cblxuICAvLyBUaGUgY2hlY2sgZm9yIGB0dC5uYW1lICYmIGV4cHJBbGxvd2VkYCBkZXRlY3RzIHdoZXRoZXIgd2UgYXJlXG4gIC8vIGFmdGVyIGEgYHlpZWxkYCBvciBgb2ZgIGNvbnN0cnVjdC4gU2VlIHRoZSBgdXBkYXRlQ29udGV4dGAgZm9yXG4gIC8vIGB0dC5uYW1lYC5cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5fcmV0dXJuIHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgeyByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09PSB0eXBlcy5hcnJvdylcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5icmFjZUwpXG4gICAgeyByZXR1cm4gcGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IHByZXZUeXBlID09PSB0eXBlcy5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ3LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHRbaV07XG4gICAgaWYgKGNvbnRleHQudG9rZW4gPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHsgcmV0dXJuIGNvbnRleHQuZ2VuZXJhdG9yIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbnBwJDcudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICh0eXBlLmtleXdvcmQgJiYgcHJldlR5cGUgPT09IHR5cGVzLmRvdClcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZTsgfVxuICBlbHNlIGlmICh1cGRhdGUgPSB0eXBlLnVwZGF0ZUNvbnRleHQpXG4gICAgeyB1cGRhdGUuY2FsbCh0aGlzLCBwcmV2VHlwZSk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5leHByQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjsgfVxufTtcblxuLy8gVG9rZW4tc3BlY2lmaWMgY29udGV4dCB1cGRhdGUgY29kZVxuXG50eXBlcy5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR5cGVzLmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG59O1xuXG50eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbn07XG5cbnR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICEocHJldlR5cGUgPT09IHR5cGVzLl9yZXR1cm4gJiYgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSkgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dC5sZW5ndGggLSAxO1xuICAgIGlmICh0aGlzLmNvbnRleHRbaW5kZXhdID09PSB0eXBlcyQxLmZfZXhwcilcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9leHByX2dlbjsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jb250ZXh0W2luZGV4XSA9IHR5cGVzJDEuZl9nZW47IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLm5hbWUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBhbGxvd2VkID0gZmFsc2U7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuZG90KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IFwib2ZcIiAmJiAhdGhpcy5leHByQWxsb3dlZCB8fFxuICAgICAgICB0aGlzLnZhbHVlID09PSBcInlpZWxkXCIgJiYgdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSlcbiAgICAgIHsgYWxsb3dlZCA9IHRydWU7IH1cbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gYWxsb3dlZDtcbn07XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyBVbmljb2RlIHByb3BlcnRpZXMgZXh0cmFjdGVkIGZyb20gdGhlIEVDTUFTY3JpcHRcbi8vIHNwZWNpZmljYXRpb24uIFRoZSBsaXN0cyBhcmUgZXh0cmFjdGVkIGxpa2Ugc286XG4vLyAkJCgnI3RhYmxlLWJpbmFyeS11bmljb2RlLXByb3BlcnRpZXMgPiBmaWd1cmUgPiB0YWJsZSA+IHRib2R5ID4gdHIgPiB0ZDpudGgtY2hpbGQoMSkgY29kZScpLm1hcChlbCA9PiBlbC5pbm5lclRleHQpXG5cbi8vICN0YWJsZS1iaW5hcnktdW5pY29kZS1wcm9wZXJ0aWVzXG52YXIgZWNtYTlCaW5hcnlQcm9wZXJ0aWVzID0gXCJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFNcIjtcbnZhciBlY21hMTBCaW5hcnlQcm9wZXJ0aWVzID0gZWNtYTlCaW5hcnlQcm9wZXJ0aWVzICsgXCIgRXh0ZW5kZWRfUGljdG9ncmFwaGljXCI7XG52YXIgZWNtYTExQmluYXJ5UHJvcGVydGllcyA9IGVjbWExMEJpbmFyeVByb3BlcnRpZXM7XG52YXIgdW5pY29kZUJpbmFyeVByb3BlcnRpZXMgPSB7XG4gIDk6IGVjbWE5QmluYXJ5UHJvcGVydGllcyxcbiAgMTA6IGVjbWExMEJpbmFyeVByb3BlcnRpZXMsXG4gIDExOiBlY21hMTFCaW5hcnlQcm9wZXJ0aWVzXG59O1xuXG4vLyAjdGFibGUtdW5pY29kZS1nZW5lcmFsLWNhdGVnb3J5LXZhbHVlc1xudmFyIHVuaWNvZGVHZW5lcmFsQ2F0ZWdvcnlWYWx1ZXMgPSBcIkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHVcIjtcblxuLy8gI3RhYmxlLXVuaWNvZGUtc2NyaXB0LXZhbHVlc1xudmFyIGVjbWE5U2NyaXB0VmFsdWVzID0gXCJBZGxhbSBBZGxtIEFob20gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb2RpIE1vbmdvbGlhbiBNb25nIE1ybyBNcm9vIE11bHRhbmkgTXVsdCBNeWFubWFyIE15bXIgTmFiYXRhZWFuIE5iYXQgTmV3X1RhaV9MdWUgVGFsdSBOZXdhIE5ld2EgTmtvIE5rb28gTnVzaHUgTnNodSBPZ2hhbSBPZ2FtIE9sX0NoaWtpIE9sY2sgT2xkX0h1bmdhcmlhbiBIdW5nIE9sZF9JdGFsaWMgSXRhbCBPbGRfTm9ydGhfQXJhYmlhbiBOYXJiIE9sZF9QZXJtaWMgUGVybSBPbGRfUGVyc2lhbiBYcGVvIE9sZF9Tb3V0aF9BcmFiaWFuIFNhcmIgT2xkX1R1cmtpYyBPcmtoIE9yaXlhIE9yeWEgT3NhZ2UgT3NnZSBPc21hbnlhIE9zbWEgUGFoYXdoX0htb25nIEhtbmcgUGFsbXlyZW5lIFBhbG0gUGF1X0Npbl9IYXUgUGF1YyBQaGFnc19QYSBQaGFnIFBob2VuaWNpYW4gUGhueCBQc2FsdGVyX1BhaGxhdmkgUGhscCBSZWphbmcgUmpuZyBSdW5pYyBSdW5yIFNhbWFyaXRhbiBTYW1yIFNhdXJhc2h0cmEgU2F1ciBTaGFyYWRhIFNocmQgU2hhdmlhbiBTaGF3IFNpZGRoYW0gU2lkZCBTaWduV3JpdGluZyBTZ253IFNpbmhhbGEgU2luaCBTb3JhX1NvbXBlbmcgU29yYSBTb3lvbWJvIFNveW8gU3VuZGFuZXNlIFN1bmQgU3lsb3RpX05hZ3JpIFN5bG8gU3lyaWFjIFN5cmMgVGFnYWxvZyBUZ2xnIFRhZ2JhbndhIFRhZ2IgVGFpX0xlIFRhbGUgVGFpX1RoYW0gTGFuYSBUYWlfVmlldCBUYXZ0IFRha3JpIFRha3IgVGFtaWwgVGFtbCBUYW5ndXQgVGFuZyBUZWx1Z3UgVGVsdSBUaGFhbmEgVGhhYSBUaGFpIFRoYWkgVGliZXRhbiBUaWJ0IFRpZmluYWdoIFRmbmcgVGlyaHV0YSBUaXJoIFVnYXJpdGljIFVnYXIgVmFpIFZhaWkgV2FyYW5nX0NpdGkgV2FyYSBZaSBZaWlpIFphbmFiYXphcl9TcXVhcmUgWmFuYlwiO1xudmFyIGVjbWExMFNjcmlwdFZhbHVlcyA9IGVjbWE5U2NyaXB0VmFsdWVzICsgXCIgRG9ncmEgRG9nciBHdW5qYWxhX0dvbmRpIEdvbmcgSGFuaWZpX1JvaGluZ3lhIFJvaGcgTWFrYXNhciBNYWthIE1lZGVmYWlkcmluIE1lZGYgT2xkX1NvZ2RpYW4gU29nbyBTb2dkaWFuIFNvZ2RcIjtcbnZhciBlY21hMTFTY3JpcHRWYWx1ZXMgPSBlY21hMTBTY3JpcHRWYWx1ZXMgKyBcIiBFbHltYWljIEVseW0gTmFuZGluYWdhcmkgTmFuZCBOeWlha2VuZ19QdWFjaHVlX0htb25nIEhtbnAgV2FuY2hvIFdjaG9cIjtcbnZhciB1bmljb2RlU2NyaXB0VmFsdWVzID0ge1xuICA5OiBlY21hOVNjcmlwdFZhbHVlcyxcbiAgMTA6IGVjbWExMFNjcmlwdFZhbHVlcyxcbiAgMTE6IGVjbWExMVNjcmlwdFZhbHVlc1xufTtcblxudmFyIGRhdGEgPSB7fTtcbmZ1bmN0aW9uIGJ1aWxkVW5pY29kZURhdGEoZWNtYVZlcnNpb24pIHtcbiAgdmFyIGQgPSBkYXRhW2VjbWFWZXJzaW9uXSA9IHtcbiAgICBiaW5hcnk6IHdvcmRzUmVnZXhwKHVuaWNvZGVCaW5hcnlQcm9wZXJ0aWVzW2VjbWFWZXJzaW9uXSArIFwiIFwiICsgdW5pY29kZUdlbmVyYWxDYXRlZ29yeVZhbHVlcyksXG4gICAgbm9uQmluYXJ5OiB7XG4gICAgICBHZW5lcmFsX0NhdGVnb3J5OiB3b3Jkc1JlZ2V4cCh1bmljb2RlR2VuZXJhbENhdGVnb3J5VmFsdWVzKSxcbiAgICAgIFNjcmlwdDogd29yZHNSZWdleHAodW5pY29kZVNjcmlwdFZhbHVlc1tlY21hVmVyc2lvbl0pXG4gICAgfVxuICB9O1xuICBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucyA9IGQubm9uQmluYXJ5LlNjcmlwdDtcblxuICBkLm5vbkJpbmFyeS5nYyA9IGQubm9uQmluYXJ5LkdlbmVyYWxfQ2F0ZWdvcnk7XG4gIGQubm9uQmluYXJ5LnNjID0gZC5ub25CaW5hcnkuU2NyaXB0O1xuICBkLm5vbkJpbmFyeS5zY3ggPSBkLm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucztcbn1cbmJ1aWxkVW5pY29kZURhdGEoOSk7XG5idWlsZFVuaWNvZGVEYXRhKDEwKTtcbmJ1aWxkVW5pY29kZURhdGEoMTEpO1xuXG52YXIgcHAkOCA9IFBhcnNlci5wcm90b3R5cGU7XG5cbnZhciBSZWdFeHBWYWxpZGF0aW9uU3RhdGUgPSBmdW5jdGlvbiBSZWdFeHBWYWxpZGF0aW9uU3RhdGUocGFyc2VyKSB7XG4gIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICB0aGlzLnZhbGlkRmxhZ3MgPSBcImdpbVwiICsgKHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyBcInV5XCIgOiBcIlwiKSArIChwYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ID8gXCJzXCIgOiBcIlwiKTtcbiAgdGhpcy51bmljb2RlUHJvcGVydGllcyA9IGRhdGFbcGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTEgPyAxMSA6IHBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uXTtcbiAgdGhpcy5zb3VyY2UgPSBcIlwiO1xuICB0aGlzLmZsYWdzID0gXCJcIjtcbiAgdGhpcy5zdGFydCA9IDA7XG4gIHRoaXMuc3dpdGNoVSA9IGZhbHNlO1xuICB0aGlzLnN3aXRjaE4gPSBmYWxzZTtcbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgdGhpcy5udW1DYXB0dXJpbmdQYXJlbnMgPSAwO1xuICB0aGlzLm1heEJhY2tSZWZlcmVuY2UgPSAwO1xuICB0aGlzLmdyb3VwTmFtZXMgPSBbXTtcbiAgdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXMgPSBbXTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoc3RhcnQsIHBhdHRlcm4sIGZsYWdzKSB7XG4gIHZhciB1bmljb2RlID0gZmxhZ3MuaW5kZXhPZihcInVcIikgIT09IC0xO1xuICB0aGlzLnN0YXJ0ID0gc3RhcnQgfCAwO1xuICB0aGlzLnNvdXJjZSA9IHBhdHRlcm4gKyBcIlwiO1xuICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIHRoaXMuc3dpdGNoVSA9IHVuaWNvZGUgJiYgdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICB0aGlzLnN3aXRjaE4gPSB1bmljb2RlICYmIHRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOTtcbn07XG5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUucmFpc2UgPSBmdW5jdGlvbiByYWlzZSAobWVzc2FnZSkge1xuICB0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIChcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvXCIgKyAodGhpcy5zb3VyY2UpICsgXCIvOiBcIiArIG1lc3NhZ2UpKTtcbn07XG5cbi8vIElmIHUgZmxhZyBpcyBnaXZlbiwgdGhpcyByZXR1cm5zIHRoZSBjb2RlIHBvaW50IGF0IHRoZSBpbmRleCAoaXQgY29tYmluZXMgYSBzdXJyb2dhdGUgcGFpcikuXG4vLyBPdGhlcndpc2UsIHRoaXMgcmV0dXJucyB0aGUgY29kZSB1bml0IG9mIHRoZSBpbmRleCAoY2FuIGJlIGEgcGFydCBvZiBhIHN1cnJvZ2F0ZSBwYWlyKS5cblJlZ0V4cFZhbGlkYXRpb25TdGF0ZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaSkge1xuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gIGlmICghdGhpcy5zd2l0Y2hVIHx8IGMgPD0gMHhEN0ZGIHx8IGMgPj0gMHhFMDAwIHx8IGkgKyAxID49IGwpIHtcbiAgICByZXR1cm4gY1xuICB9XG4gIHJldHVybiAoYyA8PCAxMCkgKyBzLmNoYXJDb2RlQXQoaSArIDEpIC0gMHgzNUZEQzAwXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLm5leHRJbmRleCA9IGZ1bmN0aW9uIG5leHRJbmRleCAoaSkge1xuICB2YXIgcyA9IHRoaXMuc291cmNlO1xuICB2YXIgbCA9IHMubGVuZ3RoO1xuICBpZiAoaSA+PSBsKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgaWYgKCF0aGlzLnN3aXRjaFUgfHwgYyA8PSAweEQ3RkYgfHwgYyA+PSAweEUwMDAgfHwgaSArIDEgPj0gbCkge1xuICAgIHJldHVybiBpICsgMVxuICB9XG4gIHJldHVybiBpICsgMlxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCAoKSB7XG4gIHJldHVybiB0aGlzLmF0KHRoaXMucG9zKVxufTtcblxuUmVnRXhwVmFsaWRhdGlvblN0YXRlLnByb3RvdHlwZS5sb29rYWhlYWQgPSBmdW5jdGlvbiBsb29rYWhlYWQgKCkge1xuICByZXR1cm4gdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcykpXG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbiBhZHZhbmNlICgpIHtcbiAgdGhpcy5wb3MgPSB0aGlzLm5leHRJbmRleCh0aGlzLnBvcyk7XG59O1xuXG5SZWdFeHBWYWxpZGF0aW9uU3RhdGUucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIGVhdCAoY2gpIHtcbiAgaWYgKHRoaXMuY3VycmVudCgpID09PSBjaCkge1xuICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjaCkge1xuICBpZiAoY2ggPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSB9XG4gIGNoIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjaCA+PiAxMCkgKyAweEQ4MDAsIChjaCAmIDB4MDNGRikgKyAweERDMDApXG59XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGZsYWdzIHBhcnQgb2YgYSBnaXZlbiBSZWdFeHBMaXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwVmFsaWRhdGlvblN0YXRlfSBzdGF0ZSBUaGUgc3RhdGUgdG8gdmFsaWRhdGUgUmVnRXhwLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbnBwJDgudmFsaWRhdGVSZWdFeHBGbGFncyA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciB2YWxpZEZsYWdzID0gc3RhdGUudmFsaWRGbGFncztcbiAgdmFyIGZsYWdzID0gc3RhdGUuZmxhZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmbGFnID0gZmxhZ3MuY2hhckF0KGkpO1xuICAgIGlmICh2YWxpZEZsYWdzLmluZGV4T2YoZmxhZykgPT09IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIik7XG4gICAgfVxuICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcsIGkgKyAxKSA+IC0xKSB7XG4gICAgICB0aGlzLnJhaXNlKHN0YXRlLnN0YXJ0LCBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIHBhdHRlcm4gcGFydCBvZiBhIGdpdmVuIFJlZ0V4cExpdGVyYWwuXG4gKlxuICogQHBhcmFtIHtSZWdFeHBWYWxpZGF0aW9uU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB0byB2YWxpZGF0ZSBSZWdFeHAuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xucHAkOC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9wYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBUaGUgZ29hbCBzeW1ib2wgZm9yIHRoZSBwYXJzZSBpcyB8UGF0dGVyblt+VSwgfk5dfC4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLyBwYXJzaW5nIGNvbnRhaW5zIGEgfEdyb3VwTmFtZXwsIHJlcGFyc2Ugd2l0aCB0aGUgZ29hbCBzeW1ib2xcbiAgLy8gfFBhdHRlcm5bflUsICtOXXwgYW5kIHVzZSB0aGlzIHJlc3VsdCBpbnN0ZWFkLiBUaHJvdyBhICpTeW50YXhFcnJvcipcbiAgLy8gZXhjZXB0aW9uIGlmIF9QXyBkaWQgbm90IGNvbmZvcm0gdG8gdGhlIGdyYW1tYXIsIGlmIGFueSBlbGVtZW50cyBvZiBfUF9cbiAgLy8gd2VyZSBub3QgbWF0Y2hlZCBieSB0aGUgcGFyc2UsIG9yIGlmIGFueSBFYXJseSBFcnJvciBjb25kaXRpb25zIGV4aXN0LlxuICBpZiAoIXN0YXRlLnN3aXRjaE4gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkgJiYgc3RhdGUuZ3JvdXBOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgc3RhdGUuc3dpdGNoTiA9IHRydWU7XG4gICAgdGhpcy5yZWdleHBfcGF0dGVybihzdGF0ZSk7XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLVBhdHRlcm5cbnBwJDgucmVnZXhwX3BhdHRlcm4gPSBmdW5jdGlvbihzdGF0ZSkge1xuICBzdGF0ZS5wb3MgPSAwO1xuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgPSBcIlwiO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcbiAgc3RhdGUubnVtQ2FwdHVyaW5nUGFyZW5zID0gMDtcbiAgc3RhdGUubWF4QmFja1JlZmVyZW5jZSA9IDA7XG4gIHN0YXRlLmdyb3VwTmFtZXMubGVuZ3RoID0gMDtcbiAgc3RhdGUuYmFja1JlZmVyZW5jZU5hbWVzLmxlbmd0aCA9IDA7XG5cbiAgdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oc3RhdGUpO1xuXG4gIGlmIChzdGF0ZS5wb3MgIT09IHN0YXRlLnNvdXJjZS5sZW5ndGgpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2VzIGFzIFY4LlxuICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJVbm1hdGNoZWQgJyknXCIpO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4NUQgLyogWyAqLykgfHwgc3RhdGUuZWF0KDB4N0QgLyogfSAqLykpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGUubWF4QmFja1JlZmVyZW5jZSA+IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIG5hbWUgPSBsaXN0W2ldO1xuXG4gICAgaWYgKHN0YXRlLmdyb3VwTmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBuYW1lZCBjYXB0dXJlIHJlZmVyZW5jZWRcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1EaXNqdW5jdGlvblxucHAkOC5yZWdleHBfZGlzanVuY3Rpb24gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB0aGlzLnJlZ2V4cF9hbHRlcm5hdGl2ZShzdGF0ZSk7XG4gIHdoaWxlIChzdGF0ZS5lYXQoMHg3QyAvKiB8ICovKSkge1xuICAgIHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKHN0YXRlKTtcbiAgfVxuXG4gIC8vIE1ha2UgdGhlIHNhbWUgbWVzc2FnZSBhcyBWOC5cbiAgaWYgKHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUsIHRydWUpKSB7XG4gICAgc3RhdGUucmFpc2UoXCJOb3RoaW5nIHRvIHJlcGVhdFwiKTtcbiAgfVxuICBpZiAoc3RhdGUuZWF0KDB4N0IgLyogeyAqLykpIHtcbiAgICBzdGF0ZS5yYWlzZShcIkxvbmUgcXVhbnRpZmllciBicmFja2V0c1wiKTtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQWx0ZXJuYXRpdmVcbnBwJDgucmVnZXhwX2FsdGVybmF0aXZlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHN0YXRlLnBvcyA8IHN0YXRlLnNvdXJjZS5sZW5ndGggJiYgdGhpcy5yZWdleHBfZWF0VGVybShzdGF0ZSkpXG4gICAgeyB9XG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1hbm5leEItVGVybVxucHAkOC5yZWdleHBfZWF0VGVybSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oc3RhdGUpKSB7XG4gICAgLy8gSGFuZGxlIGBRdWFudGlmaWFibGVBc3NlcnRpb24gUXVhbnRpZmllcmAgYWx0ZXJuYXRpdmUuXG4gICAgLy8gYHN0YXRlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZWAgaXMgdHJ1ZSBpZiB0aGUgbGFzdCBlYXRlbiBBc3NlcnRpb25cbiAgICAvLyBpcyBhIFF1YW50aWZpYWJsZUFzc2VydGlvbi5cbiAgICBpZiAoc3RhdGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlICYmIHRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoc3RhdGUpKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgcXVhbnRpZmllclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVID8gdGhpcy5yZWdleHBfZWF0QXRvbShzdGF0ZSkgOiB0aGlzLnJlZ2V4cF9lYXRFeHRlbmRlZEF0b20oc3RhdGUpKSB7XG4gICAgdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUFzc2VydGlvblxucHAkOC5yZWdleHBfZWF0QXNzZXJ0aW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSBmYWxzZTtcblxuICAvLyBeLCAkXG4gIGlmIChzdGF0ZS5lYXQoMHg1RSAvKiBeICovKSB8fCBzdGF0ZS5lYXQoMHgyNCAvKiAkICovKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBcXGIgXFxCXG4gIGlmIChzdGF0ZS5lYXQoMHg1QyAvKiBcXCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4NDIgLyogQiAqLykgfHwgc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG5cbiAgLy8gTG9va2FoZWFkIC8gTG9va2JlaGluZFxuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykgJiYgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykpIHtcbiAgICB2YXIgbG9va2JlaGluZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgICAgbG9va2JlaGluZCA9IHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4M0QgLyogPSAqLykgfHwgc3RhdGUuZWF0KDB4MjEgLyogISAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmICghc3RhdGUuZWF0KDB4MjkgLyogKSAqLykpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUgPSAhbG9va2JlaGluZDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUXVhbnRpZmllclxucHAkOC5yZWdleHBfZWF0UXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIGlmICggbm9FcnJvciA9PT0gdm9pZCAwICkgbm9FcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4KHN0YXRlLCBub0Vycm9yKSkge1xuICAgIHN0YXRlLmVhdCgweDNGIC8qID8gKi8pO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1RdWFudGlmaWVyUHJlZml4XG5wcCQ4LnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4ID0gZnVuY3Rpb24oc3RhdGUsIG5vRXJyb3IpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyQSAvKiAqICovKSB8fFxuICAgIHN0YXRlLmVhdCgweDJCIC8qICsgKi8pIHx8XG4gICAgc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCBub0Vycm9yKVxuICApXG59O1xucHAkOC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlLCBub0Vycm9yKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pKSB7XG4gICAgdmFyIG1pbiA9IDAsIG1heCA9IC0xO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKHN0YXRlKSkge1xuICAgICAgbWluID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLmVhdCgweDJDIC8qICwgKi8pICYmIHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoc3RhdGUpKSB7XG4gICAgICAgIG1heCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKSkge1xuICAgICAgICAvLyBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLXRlcm1cbiAgICAgICAgaWYgKG1heCAhPT0gLTEgJiYgbWF4IDwgbWluICYmICFub0Vycm9yKSB7XG4gICAgICAgICAgc3RhdGUucmFpc2UoXCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVICYmICFub0Vycm9yKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkluY29tcGxldGUgcXVhbnRpZmllclwiKTtcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1BdG9tXG5wcCQ4LnJlZ2V4cF9lYXRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhzdGF0ZSkgfHxcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKVxuICApXG59O1xucHAkOC5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4NUMgLyogXFwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBpZiAoc3RhdGUuZWF0KDB4MjggLyogKCAqLykpIHtcbiAgICBpZiAoc3RhdGUuZWF0KDB4M0YgLyogPyAqLykgJiYgc3RhdGUuZWF0KDB4M0EgLyogOiAqLykpIHtcbiAgICAgIHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5lYXQoMHgyOSAvKiApICovKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgZ3JvdXBcIik7XG4gICAgfVxuICAgIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnBwJDgucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDI4IC8qICggKi8pKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5KSB7XG4gICAgICB0aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5jdXJyZW50KCkgPT09IDB4M0YgLyogPyAqLykge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICAgIH1cbiAgICB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDI5IC8qICkgKi8pKSB7XG4gICAgICBzdGF0ZS5udW1DYXB0dXJpbmdQYXJlbnMgKz0gMTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiVW50ZXJtaW5hdGVkIGdyb3VwXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkQXRvbVxucHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZS5lYXQoMHgyRSAvKiAuICovKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEludmFsaWRCcmFjZWRRdWFudGlmaWVyKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUludmFsaWRCcmFjZWRRdWFudGlmaWVyXG5wcCQ4LnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyKHN0YXRlLCB0cnVlKSkge1xuICAgIHN0YXRlLnJhaXNlKFwiTm90aGluZyB0byByZXBlYXRcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1TeW50YXhDaGFyYWN0ZXJcbnBwJDgucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzU3ludGF4Q2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4MjQgLyogJCAqLyB8fFxuICAgIGNoID49IDB4MjggLyogKCAqLyAmJiBjaCA8PSAweDJCIC8qICsgKi8gfHxcbiAgICBjaCA9PT0gMHgyRSAvKiAuICovIHx8XG4gICAgY2ggPT09IDB4M0YgLyogPyAqLyB8fFxuICAgIGNoID49IDB4NUIgLyogWyAqLyAmJiBjaCA8PSAweDVFIC8qIF4gKi8gfHxcbiAgICBjaCA+PSAweDdCIC8qIHsgKi8gJiYgY2ggPD0gMHg3RCAvKiB9ICovXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUGF0dGVybkNoYXJhY3RlclxuLy8gQnV0IGVhdCBlYWdlci5cbnBwJDgucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSAwO1xuICB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSAhPT0gLTEgJiYgIWlzU3ludGF4Q2hhcmFjdGVyKGNoKSkge1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUV4dGVuZGVkUGF0dGVybkNoYXJhY3RlclxucHAkOC5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoXG4gICAgY2ggIT09IC0xICYmXG4gICAgY2ggIT09IDB4MjQgLyogJCAqLyAmJlxuICAgICEoY2ggPj0gMHgyOCAvKiAoICovICYmIGNoIDw9IDB4MkIgLyogKyAqLykgJiZcbiAgICBjaCAhPT0gMHgyRSAvKiAuICovICYmXG4gICAgY2ggIT09IDB4M0YgLyogPyAqLyAmJlxuICAgIGNoICE9PSAweDVCIC8qIFsgKi8gJiZcbiAgICBjaCAhPT0gMHg1RSAvKiBeICovICYmXG4gICAgY2ggIT09IDB4N0MgLyogfCAqL1xuICApIHtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIEdyb3VwU3BlY2lmaWVyW1VdIDo6XG4vLyAgIFtlbXB0eV1cbi8vICAgYD9gIEdyb3VwTmFtZVs/VV1cbnBwJDgucmVnZXhwX2dyb3VwU3BlY2lmaWVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVhdCgweDNGIC8qID8gKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShzdGF0ZSkpIHtcbiAgICAgIGlmIChzdGF0ZS5ncm91cE5hbWVzLmluZGV4T2Yoc3RhdGUubGFzdFN0cmluZ1ZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgc3RhdGUuZ3JvdXBOYW1lcy5wdXNoKHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGdyb3VwXCIpO1xuICB9XG59O1xuXG4vLyBHcm91cE5hbWVbVV0gOjpcbi8vICAgYDxgIFJlZ0V4cElkZW50aWZpZXJOYW1lWz9VXSBgPmBcbi8vIE5vdGU6IHRoaXMgdXBkYXRlcyBgc3RhdGUubGFzdFN0cmluZ1ZhbHVlYCBwcm9wZXJ0eSB3aXRoIHRoZSBlYXRlbiBuYW1lLlxucHAkOC5yZWdleHBfZWF0R3JvdXBOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgaWYgKHN0YXRlLmVhdCgweDNDIC8qIDwgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRSAvKiA+ICovKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNhcHR1cmUgZ3JvdXAgbmFtZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIFJlZ0V4cElkZW50aWZpZXJOYW1lW1VdIDo6XG4vLyAgIFJlZ0V4cElkZW50aWZpZXJTdGFydFs/VV1cbi8vICAgUmVnRXhwSWRlbnRpZmllck5hbWVbP1VdIFJlZ0V4cElkZW50aWZpZXJQYXJ0Wz9VXVxuLy8gTm90ZTogdGhpcyB1cGRhdGVzIGBzdGF0ZS5sYXN0U3RyaW5nVmFsdWVgIHByb3BlcnR5IHdpdGggdGhlIGVhdGVuIG5hbWUuXG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyU3RhcnQoc3RhdGUpKSB7XG4gICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0KHN0YXRlKSkge1xuICAgICAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlICs9IGNvZGVQb2ludFRvU3RyaW5nKHN0YXRlLmxhc3RJbnRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBSZWdFeHBJZGVudGlmaWVyU3RhcnRbVV0gOjpcbi8vICAgVW5pY29kZUlEU3RhcnRcbi8vICAgYCRgXG4vLyAgIGBfYFxuLy8gICBgXFxgIFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZVs/VV1cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBzdGF0ZS5hZHZhbmNlKCk7XG5cbiAgaWYgKGNoID09PSAweDVDIC8qIFxcICovICYmIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHtcbiAgICBjaCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgfVxuICBpZiAoaXNSZWdFeHBJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gY2g7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0O1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc1JlZ0V4cElkZW50aWZpZXJTdGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyU3RhcnQoY2gsIHRydWUpIHx8IGNoID09PSAweDI0IC8qICQgKi8gfHwgY2ggPT09IDB4NUYgLyogXyAqL1xufVxuXG4vLyBSZWdFeHBJZGVudGlmaWVyUGFydFtVXSA6OlxuLy8gICBVbmljb2RlSURDb250aW51ZVxuLy8gICBgJGBcbi8vICAgYF9gXG4vLyAgIGBcXGAgUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlWz9VXVxuLy8gICA8WldOSj5cbi8vICAgPFpXSj5cbnBwJDgucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJQYXJ0ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG4gIHN0YXRlLmFkdmFuY2UoKTtcblxuICBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8gJiYgdGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKHN0YXRlKSkge1xuICAgIGNoID0gc3RhdGUubGFzdEludFZhbHVlO1xuICB9XG4gIGlmIChpc1JlZ0V4cElkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IGNoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNSZWdFeHBJZGVudGlmaWVyUGFydChjaCkge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihjaCwgdHJ1ZSkgfHwgY2ggPT09IDB4MjQgLyogJCAqLyB8fCBjaCA9PT0gMHg1RiAvKiBfICovIHx8IGNoID09PSAweDIwMEMgLyogPFpXTko+ICovIHx8IGNoID09PSAweDIwMEQgLyogPFpXSj4gKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUF0b21Fc2NhcGVcbnBwJDgucmVnZXhwX2VhdEF0b21Fc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoXG4gICAgdGhpcy5yZWdleHBfZWF0QmFja1JlZmVyZW5jZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoc3RhdGUpIHx8XG4gICAgKHN0YXRlLnN3aXRjaE4gJiYgdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShzdGF0ZSkpXG4gICkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHg2MyAvKiBjICovKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgdW5pY29kZSBlc2NhcGVcIik7XG4gICAgfVxuICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBlc2NhcGVcIik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0QmFja1JlZmVyZW5jZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHRoaXMucmVnZXhwX2VhdERlY2ltYWxFc2NhcGUoc3RhdGUpKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHN0YXRlLnN3aXRjaFUpIHtcbiAgICAgIC8vIEZvciBTeW50YXhFcnJvciBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jc2VjLWF0b21lc2NhcGVcbiAgICAgIGlmIChuID4gc3RhdGUubWF4QmFja1JlZmVyZW5jZSkge1xuICAgICAgICBzdGF0ZS5tYXhCYWNrUmVmZXJlbmNlID0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChuIDw9IHN0YXRlLm51bUNhcHR1cmluZ1BhcmVucykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfZWF0S0dyb3VwTmFtZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lYXQoMHg2QiAvKiBrICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoc3RhdGUpKSB7XG4gICAgICBzdGF0ZS5iYWNrUmVmZXJlbmNlTmFtZXMucHVzaChzdGF0ZS5sYXN0U3RyaW5nVmFsdWUpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZVwiKTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1DaGFyYWN0ZXJFc2NhcGVcbnBwJDgucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgdGhpcy5yZWdleHBfZWF0Q29udHJvbEVzY2FwZShzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRDQ29udHJvbExldHRlcihzdGF0ZSkgfHxcbiAgICB0aGlzLnJlZ2V4cF9lYXRaZXJvKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShzdGF0ZSkgfHxcbiAgICAoIXN0YXRlLnN3aXRjaFUgJiYgdGhpcy5yZWdleHBfZWF0TGVnYWN5T2N0YWxFc2NhcGVTZXF1ZW5jZShzdGF0ZSkpIHx8XG4gICAgdGhpcy5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUoc3RhdGUpXG4gIClcbn07XG5wcCQ4LnJlZ2V4cF9lYXRDQ29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgaWYgKHN0YXRlLmVhdCgweDYzIC8qIGMgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdENvbnRyb2xMZXR0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5wcCQ4LnJlZ2V4cF9lYXRaZXJvID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmN1cnJlbnQoKSA9PT0gMHgzMCAvKiAwICovICYmICFpc0RlY2ltYWxEaWdpdChzdGF0ZS5sb29rYWhlYWQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbEVzY2FwZVxucHAkOC5yZWdleHBfZWF0Q29udHJvbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID09PSAweDc0IC8qIHQgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA5OyAvKiBcXHQgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NkUgLyogbiAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEE7IC8qIFxcbiAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjaCA9PT0gMHg3NiAvKiB2ICovKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgwQjsgLyogXFx2ICovXG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGNoID09PSAweDY2IC8qIGYgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDBDOyAvKiBcXGYgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoY2ggPT09IDB4NzIgLyogciAqLykge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MEQ7IC8qIFxcciAqL1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ29udHJvbExldHRlclxucHAkOC5yZWdleHBfZWF0Q29udHJvbExldHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzQ29udHJvbExldHRlcihjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuZnVuY3Rpb24gaXNDb250cm9sTGV0dGVyKGNoKSB7XG4gIHJldHVybiAoXG4gICAgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDVBIC8qIFogKi8pIHx8XG4gICAgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDdBIC8qIHogKi8pXG4gIClcbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtUmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlXG5wcCQ4LnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDc1IC8qIHUgKi8pKSB7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKHN0YXRlLCA0KSkge1xuICAgICAgdmFyIGxlYWQgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAoc3RhdGUuc3dpdGNoVSAmJiBsZWFkID49IDB4RDgwMCAmJiBsZWFkIDw9IDB4REJGRikge1xuICAgICAgICB2YXIgbGVhZFN1cnJvZ2F0ZUVuZCA9IHN0YXRlLnBvcztcbiAgICAgICAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSAmJiBzdGF0ZS5lYXQoMHg3NSAvKiB1ICovKSAmJiB0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgNCkpIHtcbiAgICAgICAgICB2YXIgdHJhaWwgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICAgICAgaWYgKHRyYWlsID49IDB4REMwMCAmJiB0cmFpbCA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IChsZWFkIC0gMHhEODAwKSAqIDB4NDAwICsgKHRyYWlsIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgPSBsZWFkU3Vycm9nYXRlRW5kO1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBsZWFkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKFxuICAgICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgICAgc3RhdGUuZWF0KDB4N0IgLyogeyAqLykgJiZcbiAgICAgIHRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhzdGF0ZSkgJiZcbiAgICAgIHN0YXRlLmVhdCgweDdEIC8qIH0gKi8pICYmXG4gICAgICBpc1ZhbGlkVW5pY29kZShzdGF0ZS5sYXN0SW50VmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcbmZ1bmN0aW9uIGlzVmFsaWRVbmljb2RlKGNoKSB7XG4gIHJldHVybiBjaCA+PSAwICYmIGNoIDw9IDB4MTBGRkZGXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1JZGVudGl0eUVzY2FwZVxucHAkOC5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuc3dpdGNoVSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRTeW50YXhDaGFyYWN0ZXIoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBpZiAoc3RhdGUuZWF0KDB4MkYgLyogLyAqLykpIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDB4MkY7IC8qIC8gKi9cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoY2ggIT09IDB4NjMgLyogYyAqLyAmJiAoIXN0YXRlLnN3aXRjaE4gfHwgY2ggIT09IDB4NkIgLyogayAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtRGVjaW1hbEVzY2FwZVxucHAkOC5yZWdleHBfZWF0RGVjaW1hbEVzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoID49IDB4MzEgLyogMSAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICBkbyB7XG4gICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgfSB3aGlsZSAoKGNoID0gc3RhdGUuY3VycmVudCgpKSA+PSAweDMwIC8qIDAgKi8gJiYgY2ggPD0gMHgzOSAvKiA5ICovKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc0VzY2FwZVxucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgY2ggPSBzdGF0ZS5jdXJyZW50KCk7XG5cbiAgaWYgKGlzQ2hhcmFjdGVyQ2xhc3NFc2NhcGUoY2gpKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoXG4gICAgc3RhdGUuc3dpdGNoVSAmJlxuICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA5ICYmXG4gICAgKGNoID09PSAweDUwIC8qIFAgKi8gfHwgY2ggPT09IDB4NzAgLyogcCAqLylcbiAgKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gLTE7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlLmVhdCgweDdCIC8qIHsgKi8pICYmXG4gICAgICB0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oc3RhdGUpICYmXG4gICAgICBzdGF0ZS5lYXQoMHg3RCAvKiB9ICovKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWVcIik7XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc0NoYXJhY3RlckNsYXNzRXNjYXBlKGNoKSB7XG4gIHJldHVybiAoXG4gICAgY2ggPT09IDB4NjQgLyogZCAqLyB8fFxuICAgIGNoID09PSAweDQ0IC8qIEQgKi8gfHxcbiAgICBjaCA9PT0gMHg3MyAvKiBzICovIHx8XG4gICAgY2ggPT09IDB4NTMgLyogUyAqLyB8fFxuICAgIGNoID09PSAweDc3IC8qIHcgKi8gfHxcbiAgICBjaCA9PT0gMHg1NyAvKiBXICovXG4gIClcbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4vLyAgIExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZVxucHAkOC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIHN0YXJ0ID0gc3RhdGUucG9zO1xuXG4gIC8vIFVuaWNvZGVQcm9wZXJ0eU5hbWUgYD1gIFVuaWNvZGVQcm9wZXJ0eVZhbHVlXG4gIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKHN0YXRlKSAmJiBzdGF0ZS5lYXQoMHgzRCAvKiA9ICovKSkge1xuICAgIHZhciBuYW1lID0gc3RhdGUubGFzdFN0cmluZ1ZhbHVlO1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZShzdGF0ZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRlLmxhc3RTdHJpbmdWYWx1ZTtcbiAgICAgIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlKHN0YXRlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICBzdGF0ZS5wb3MgPSBzdGFydDtcblxuICAvLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWVcbiAgaWYgKHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSkpIHtcbiAgICB2YXIgbmFtZU9yVmFsdWUgPSBzdGF0ZS5sYXN0U3RyaW5nVmFsdWU7XG4gICAgdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShzdGF0ZSwgbmFtZU9yVmFsdWUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xucHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFoYXMoc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5LCBuYW1lKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG4gIGlmICghc3RhdGUudW5pY29kZVByb3BlcnRpZXMubm9uQmluYXJ5W25hbWVdLnRlc3QodmFsdWUpKVxuICAgIHsgc3RhdGUucmFpc2UoXCJJbnZhbGlkIHByb3BlcnR5IHZhbHVlXCIpOyB9XG59O1xucHAkOC5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lT3JWYWx1ZSkge1xuICBpZiAoIXN0YXRlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeS50ZXN0KG5hbWVPclZhbHVlKSlcbiAgICB7IHN0YXRlLnJhaXNlKFwiSW52YWxpZCBwcm9wZXJ0eSBuYW1lXCIpOyB9XG59O1xuXG4vLyBVbmljb2RlUHJvcGVydHlOYW1lIDo6XG4vLyAgIFVuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gMDtcbiAgc3RhdGUubGFzdFN0cmluZ1ZhbHVlID0gXCJcIjtcbiAgd2hpbGUgKGlzVW5pY29kZVByb3BlcnR5TmFtZUNoYXJhY3RlcihjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgKz0gY29kZVBvaW50VG9TdHJpbmcoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUubGFzdFN0cmluZ1ZhbHVlICE9PSBcIlwiXG59O1xuZnVuY3Rpb24gaXNVbmljb2RlUHJvcGVydHlOYW1lQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc0NvbnRyb2xMZXR0ZXIoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi9cbn1cblxuLy8gVW5pY29kZVByb3BlcnR5VmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSA9IFwiXCI7XG4gIHdoaWxlIChpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RTdHJpbmdWYWx1ZSArPSBjb2RlUG9pbnRUb1N0cmluZyhjaCk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sYXN0U3RyaW5nVmFsdWUgIT09IFwiXCJcbn07XG5mdW5jdGlvbiBpc1VuaWNvZGVQcm9wZXJ0eVZhbHVlQ2hhcmFjdGVyKGNoKSB7XG4gIHJldHVybiBpc1VuaWNvZGVQcm9wZXJ0eU5hbWVDaGFyYWN0ZXIoY2gpIHx8IGlzRGVjaW1hbERpZ2l0KGNoKVxufVxuXG4vLyBMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgOjpcbi8vICAgVW5pY29kZVByb3BlcnR5VmFsdWVDaGFyYWN0ZXJzXG5wcCQ4LnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICByZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoc3RhdGUpXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1DaGFyYWN0ZXJDbGFzc1xucHAkOC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAoc3RhdGUuZWF0KDB4NUIgLyogWyAqLykpIHtcbiAgICBzdGF0ZS5lYXQoMHg1RSAvKiBeICovKTtcbiAgICB0aGlzLnJlZ2V4cF9jbGFzc1JhbmdlcyhzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLmVhdCgweDVEIC8qIFsgKi8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBVbnJlYWNoYWJsZSBzaW5jZSBpdCB0aHJldyBcInVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiBlcnJvciBiZWZvcmUuXG4gICAgc3RhdGUucmFpc2UoXCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzXCIpO1xuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLU5vbmVtcHR5Q2xhc3NSYW5nZXNOb0Rhc2hcbnBwJDgucmVnZXhwX2NsYXNzUmFuZ2VzID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgd2hpbGUgKHRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShzdGF0ZSkpIHtcbiAgICB2YXIgbGVmdCA9IHN0YXRlLmxhc3RJbnRWYWx1ZTtcbiAgICBpZiAoc3RhdGUuZWF0KDB4MkQgLyogLSAqLykgJiYgdGhpcy5yZWdleHBfZWF0Q2xhc3NBdG9tKHN0YXRlKSkge1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgaWYgKHN0YXRlLnN3aXRjaFUgJiYgKGxlZnQgPT09IC0xIHx8IHJpZ2h0ID09PSAtMSkpIHtcbiAgICAgICAgc3RhdGUucmFpc2UoXCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICE9PSAtMSAmJiByaWdodCAhPT0gLTEgJiYgbGVmdCA+IHJpZ2h0KSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLUNsYXNzQXRvbVxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtQ2xhc3NBdG9tTm9EYXNoXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0F0b20gPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLmVhdCgweDVDIC8qIFxcICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShzdGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICAvLyBNYWtlIHRoZSBzYW1lIG1lc3NhZ2UgYXMgVjguXG4gICAgICB2YXIgY2gkMSA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChjaCQxID09PSAweDYzIC8qIGMgKi8gfHwgaXNPY3RhbERpZ2l0KGNoJDEpKSB7XG4gICAgICAgIHN0YXRlLnJhaXNlKFwiSW52YWxpZCBjbGFzcyBlc2NhcGVcIik7XG4gICAgICB9XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuXG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGNoICE9PSAweDVEIC8qIFsgKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaDtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzRXNjYXBlXG5wcCQ4LnJlZ2V4cF9lYXRDbGFzc0VzY2FwZSA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuZWF0KDB4NjIgLyogYiAqLykpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAweDA4OyAvKiA8QlM+ICovXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChzdGF0ZS5zd2l0Y2hVICYmIHN0YXRlLmVhdCgweDJEIC8qIC0gKi8pKSB7XG4gICAgc3RhdGUubGFzdEludFZhbHVlID0gMHgyRDsgLyogLSAqL1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoIXN0YXRlLnN3aXRjaFUgJiYgc3RhdGUuZWF0KDB4NjMgLyogYyAqLykpIHtcbiAgICBpZiAodGhpcy5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyKHN0YXRlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgc3RhdGUucG9zID0gc3RhcnQ7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKHN0YXRlKSB8fFxuICAgIHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShzdGF0ZSlcbiAgKVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtYW5uZXhCLUNsYXNzQ29udHJvbExldHRlclxucHAkOC5yZWdleHBfZWF0Q2xhc3NDb250cm9sTGV0dGVyID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdmFyIGNoID0gc3RhdGUuY3VycmVudCgpO1xuICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpIHx8IGNoID09PSAweDVGIC8qIF8gKi8pIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAlIDB4MjA7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOC5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIGlmIChzdGF0ZS5lYXQoMHg3OCAvKiB4ICovKSkge1xuICAgIGlmICh0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhzdGF0ZSwgMikpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChzdGF0ZS5zd2l0Y2hVKSB7XG4gICAgICBzdGF0ZS5yYWlzZShcIkludmFsaWQgZXNjYXBlXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLURlY2ltYWxEaWdpdHNcbnBwJDgucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0RlY2ltYWxEaWdpdChjaCA9IHN0YXRlLmN1cnJlbnQoKSkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxMCAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIChjaCAtIDB4MzAgLyogMCAqLyk7XG4gICAgc3RhdGUuYWR2YW5jZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5wb3MgIT09IHN0YXJ0XG59O1xuZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM5IC8qIDkgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRzXG5wcCQ4LnJlZ2V4cF9lYXRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICB2YXIgc3RhcnQgPSBzdGF0ZS5wb3M7XG4gIHZhciBjaCA9IDA7XG4gIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDA7XG4gIHdoaWxlIChpc0hleERpZ2l0KGNoID0gc3RhdGUuY3VycmVudCgpKSkge1xuICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IDE2ICogc3RhdGUubGFzdEludFZhbHVlICsgaGV4VG9JbnQoY2gpO1xuICAgIHN0YXRlLmFkdmFuY2UoKTtcbiAgfVxuICByZXR1cm4gc3RhdGUucG9zICE9PSBzdGFydFxufTtcbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuIChcbiAgICAoY2ggPj0gMHgzMCAvKiAwICovICYmIGNoIDw9IDB4MzkgLyogOSAqLykgfHxcbiAgICAoY2ggPj0gMHg0MSAvKiBBICovICYmIGNoIDw9IDB4NDYgLyogRiAqLykgfHxcbiAgICAoY2ggPj0gMHg2MSAvKiBhICovICYmIGNoIDw9IDB4NjYgLyogZiAqLylcbiAgKVxufVxuZnVuY3Rpb24gaGV4VG9JbnQoY2gpIHtcbiAgaWYgKGNoID49IDB4NDEgLyogQSAqLyAmJiBjaCA8PSAweDQ2IC8qIEYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDQxIC8qIEEgKi8pXG4gIH1cbiAgaWYgKGNoID49IDB4NjEgLyogYSAqLyAmJiBjaCA8PSAweDY2IC8qIGYgKi8pIHtcbiAgICByZXR1cm4gMTAgKyAoY2ggLSAweDYxIC8qIGEgKi8pXG4gIH1cbiAgcmV0dXJuIGNoIC0gMHgzMCAvKiAwICovXG59XG5cbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wLyNwcm9kLWFubmV4Qi1MZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlXG4vLyBBbGxvd3Mgb25seSAwLTM3NyhvY3RhbCkgaS5lLiAwLTI1NShkZWNpbWFsKS5cbnBwJDgucmVnZXhwX2VhdExlZ2FjeU9jdGFsRXNjYXBlU2VxdWVuY2UgPSBmdW5jdGlvbihzdGF0ZSkge1xuICBpZiAodGhpcy5yZWdleHBfZWF0T2N0YWxEaWdpdChzdGF0ZSkpIHtcbiAgICB2YXIgbjEgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgaWYgKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoc3RhdGUpKSB7XG4gICAgICB2YXIgbjIgPSBzdGF0ZS5sYXN0SW50VmFsdWU7XG4gICAgICBpZiAobjEgPD0gMyAmJiB0aGlzLnJlZ2V4cF9lYXRPY3RhbERpZ2l0KHN0YXRlKSkge1xuICAgICAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBuMSAqIDY0ICsgbjIgKiA4ICsgc3RhdGUubGFzdEludFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdEludFZhbHVlID0gbjEgKiA4ICsgbjI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmxhc3RJbnRWYWx1ZSA9IG4xO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtT2N0YWxEaWdpdFxucHAkOC5yZWdleHBfZWF0T2N0YWxEaWdpdCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSBjaCAtIDB4MzA7IC8qIDAgKi9cbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAwO1xuICByZXR1cm4gZmFsc2Vcbn07XG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuIGNoID49IDB4MzAgLyogMCAqLyAmJiBjaCA8PSAweDM3IC8qIDcgKi9cbn1cblxuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4NERpZ2l0c1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvI3Byb2QtSGV4RGlnaXRcbi8vIEFuZCBIZXhEaWdpdCBIZXhEaWdpdCBpbiBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzguMC8jcHJvZC1IZXhFc2NhcGVTZXF1ZW5jZVxucHAkOC5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMgPSBmdW5jdGlvbihzdGF0ZSwgbGVuZ3RoKSB7XG4gIHZhciBzdGFydCA9IHN0YXRlLnBvcztcbiAgc3RhdGUubGFzdEludFZhbHVlID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBjaCA9IHN0YXRlLmN1cnJlbnQoKTtcbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBzdGFydDtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0SW50VmFsdWUgPSAxNiAqIHN0YXRlLmxhc3RJbnRWYWx1ZSArIGhleFRvSW50KGNoKTtcbiAgICBzdGF0ZS5hZHZhbmNlKCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbi8vIHNpbXBseSBleGlzdCBhcyBwcm9wZXJ0aWVzIG9uIHRoZSBwYXJzZXIgb2JqZWN0LiBUaGlzIGlzIG9ubHlcbi8vIHVzZWQgZm9yIHRoZSBvblRva2VuIGNhbGxiYWNrIGFuZCB0aGUgZXh0ZXJuYWwgdG9rZW5pemVyLlxuXG52YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gIHRoaXMudHlwZSA9IHAudHlwZTtcbiAgdGhpcy52YWx1ZSA9IHAudmFsdWU7XG4gIHRoaXMuc3RhcnQgPSBwLnN0YXJ0O1xuICB0aGlzLmVuZCA9IHAuZW5kO1xuICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKTsgfVxuICBpZiAocC5vcHRpb25zLnJhbmdlcylcbiAgICB7IHRoaXMucmFuZ2UgPSBbcC5zdGFydCwgcC5lbmRdOyB9XG59O1xuXG4vLyAjIyBUb2tlbml6ZXJcblxudmFyIHBwJDkgPSBQYXJzZXIucHJvdG90eXBlO1xuXG4vLyBNb3ZlIHRvIHRoZSBuZXh0IHRva2VuXG5cbnBwJDkubmV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgeyB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpOyB9XG5cbiAgdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5lbmQ7XG4gIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydDtcbiAgdGhpcy5sYXN0VG9rRW5kTG9jID0gdGhpcy5lbmRMb2M7XG4gIHRoaXMubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdGhpcy5uZXh0VG9rZW4oKTtcbn07XG5cbnBwJDkuZ2V0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiBuZXcgVG9rZW4odGhpcylcbn07XG5cbi8vIElmIHdlJ3JlIGluIGFuIEVTNiBlbnZpcm9ubWVudCwgbWFrZSBwYXJzZXJzIGl0ZXJhYmxlXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgeyBwcCQ5W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRoaXMkMS5nZXRUb2tlbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRvbmU6IHRva2VuLnR5cGUgPT09IHR5cGVzLmVvZixcbiAgICAgICAgICB2YWx1ZTogdG9rZW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgfVxuXG4vLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4vLyBwZWRhbnRpYyB0ZXN0cyAoYFwidXNlIHN0cmljdFwiOyAwMTA7YCBzaG91bGQgZmFpbCkuXG5cbnBwJDkuY3VyQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxufTtcblxuLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4vLyBwcm9wZXJ0aWVzLlxuXG5wcCQ5Lm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICBpZiAoIWN1ckNvbnRleHQgfHwgIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgeyB0aGlzLnNraXBTcGFjZSgpOyB9XG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgeyB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lb2YpIH1cblxuICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgeyByZXR1cm4gY3VyQ29udGV4dC5vdmVycmlkZSh0aGlzKSB9XG4gIGVsc2UgeyB0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpOyB9XG59O1xuXG5wcCQ5LnJlYWRUb2tlbiA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgLy8gSWRlbnRpZmllciBvciBrZXl3b3JkLiAnXFx1WFhYWCcgc2VxdWVuY2VzIGFyZSBhbGxvd2VkIGluXG4gIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHx8IGNvZGUgPT09IDkyIC8qICdcXCcgKi8pXG4gICAgeyByZXR1cm4gdGhpcy5yZWFkV29yZCgpIH1cblxuICByZXR1cm4gdGhpcy5nZXRUb2tlbkZyb21Db2RlKGNvZGUpXG59O1xuXG5wcCQ5LmZ1bGxDaGFyQ29kZUF0UG9zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKGNvZGUgPD0gMHhkN2ZmIHx8IGNvZGUgPj0gMHhlMDAwKSB7IHJldHVybiBjb2RlIH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgcmV0dXJuIChjb2RlIDw8IDEwKSArIG5leHQgLSAweDM1ZmRjMDBcbn07XG5cbnBwJDkuc2tpcEJsb2NrQ29tbWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhcnRMb2MgPSB0aGlzLm9wdGlvbnMub25Db21tZW50ICYmIHRoaXMuY3VyUG9zaXRpb24oKTtcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpO1xuICBpZiAoZW5kID09PSAtMSkgeyB0aGlzLnJhaXNlKHRoaXMucG9zIC0gMiwgXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKTsgfVxuICB0aGlzLnBvcyA9IGVuZCArIDI7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBzdGFydDtcbiAgICB2YXIgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgKyt0aGlzLmN1ckxpbmU7XG4gICAgICB0aGlzLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG5wcCQ5LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgIHsgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydExvYywgdGhpcy5jdXJQb3NpdGlvbigpKTsgfVxufTtcblxuLy8gQ2FsbGVkIGF0IHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgYW5kIGFmdGVyIGV2ZXJ5IHRva2VuLiBTa2lwc1xuLy8gd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGFuZC5cblxucHAkOS5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgbG9vcDogd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICArK3RoaXMucG9zO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICArK3RoaXMucG9zO1xuICAgICAgfVxuICAgIGNhc2UgMTA6IGNhc2UgODIzMjogY2FzZSA4MjMzOlxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHN3aXRjaCAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSkpIHtcbiAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWsgbG9vcFxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID4gOCAmJiBjaCA8IDE0IHx8IGNoID49IDU3NjAgJiYgbm9uQVNDSUl3aGl0ZXNwYWNlLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKSB7XG4gICAgICAgICsrdGhpcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIHJpZ2h0IHBvc2l0aW9uLlxuXG5wcCQ5LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xufTtcblxuLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uIEl0XG4vLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbi8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4vLyBpbnRvIGl0LlxuLy9cbi8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbi8vXG5wcCQ5LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgfSBlbHNlIHtcbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgfVxufTtcblxucHAkOS5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgKytzaXplO1xuICAgIHRva2VudHlwZSA9IHR5cGVzLnN0YXJzdGFyO1xuICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKTtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIHNpemUgKyAxKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHRva2VudHlwZSwgc2l6ZSlcbn07XG5cbnBwJDkucmVhZFRva2VuX3BpcGVfYW1wID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnfCYnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmxvZ2ljYWxPUiA6IHR5cGVzLmxvZ2ljYWxBTkQsIDIpIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSAxMjQgPyB0eXBlcy5iaXR3aXNlT1IgOiB0eXBlcy5iaXR3aXNlQU5ELCAxKVxufTtcblxucHAkOS5yZWFkVG9rZW5fY2FyZXQgPSBmdW5jdGlvbigpIHsgLy8gJ14nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYml0d2lzZVhPUiwgMSlcbn07XG5cbnBwJDkucmVhZFRva2VuX3BsdXNfbWluID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnKy0nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgaWYgKG5leHQgPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICB9XG4gIGlmIChuZXh0ID09PSAzMyAmJiBjb2RlID09PSA2MCAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNDUgJiZcbiAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09PSA0NSkge1xuICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICB0aGlzLnNraXBMaW5lQ29tbWVudCg0KTtcbiAgICB0aGlzLnNraXBTcGFjZSgpO1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gIH1cbiAgaWYgKG5leHQgPT09IDYxKSB7IHNpemUgPSAyOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnJlbGF0aW9uYWwsIHNpemUpXG59O1xuXG5wcCQ5LnJlYWRUb2tlbl9lcV9leGNsID0gZnVuY3Rpb24oY29kZSkgeyAvLyAnPSEnXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpIH1cbiAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICB0aGlzLnBvcyArPSAyO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmFycm93KVxuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYxID8gdHlwZXMuZXEgOiB0eXBlcy5wcmVmaXgsIDEpXG59O1xuXG5wcCQ5LmdldFRva2VuRnJvbUNvZGUgPSBmdW5jdGlvbihjb2RlKSB7XG4gIHN3aXRjaCAoY29kZSkge1xuICAvLyBUaGUgaW50ZXJwcmV0YXRpb24gb2YgYSBkb3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGlzIGZvbGxvd2VkXG4gIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgY2FzZSA0NjogLy8gJy4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgLy8gUHVuY3R1YXRpb24gdG9rZW5zLlxuICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5wYXJlbkwpXG4gIGNhc2UgNDE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuUilcbiAgY2FzZSA1OTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc2VtaSlcbiAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29tbWEpXG4gIGNhc2UgOTE6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRMKVxuICBjYXNlIDkzOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5icmFja2V0UilcbiAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlTClcbiAgY2FzZSAxMjU6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNlUilcbiAgY2FzZSA1ODogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuY29sb24pXG4gIGNhc2UgNjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnF1ZXN0aW9uKVxuXG4gIGNhc2UgOTY6IC8vICdgJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IGJyZWFrIH1cbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJhY2tRdW90ZSlcblxuICBjYXNlIDQ4OiAvLyAnMCdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSB9IC8vICcweCcsICcwWCcgLSBoZXggbnVtYmVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBpZiAobmV4dCA9PT0gMTExIHx8IG5leHQgPT09IDc5KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSB9IC8vICcwbycsICcwTycgLSBvY3RhbCBudW1iZXJcbiAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMikgfSAvLyAnMGInLCAnMEInIC0gYmluYXJ5IG51bWJlclxuICAgIH1cblxuICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgLy8gbnVtYmVyLCBvciBmbG9hdC5cbiAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMS05XG4gICAgcmV0dXJuIHRoaXMucmVhZE51bWJlcihmYWxzZSlcblxuICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAvLyBPcGVyYXRvcnMgYXJlIHBhcnNlZCBpbmxpbmUgaW4gdGlueSBzdGF0ZSBtYWNoaW5lcy4gJz0nICg2MSkgaXNcbiAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgLy8gb2YgdGhlIHR5cGUgZ2l2ZW4gYnkgaXRzIGZpcnN0IGFyZ3VtZW50LlxuXG4gIGNhc2UgNDc6IC8vICcvJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgY2FzZSAzNzogY2FzZSA0MjogLy8gJyUqJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAoY29kZSlcblxuICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKVxuXG4gIGNhc2UgOTQ6IC8vICdeJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgY2FzZSA0MzogY2FzZSA0NTogLy8gJystJ1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKVxuXG4gIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbHRfZ3QoY29kZSlcblxuICBjYXNlIDYxOiBjYXNlIDMzOiAvLyAnPSEnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICBjYXNlIDEyNjogLy8gJ34nXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucHJlZml4LCAxKVxuICB9XG5cbiAgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjb2RlUG9pbnRUb1N0cmluZyQxKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAkOS5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gIHRoaXMucG9zICs9IHNpemU7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbn07XG5cbnBwJDkucmVhZFJlZ2V4cCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7IH1cbiAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJbXCIpIHsgaW5DbGFzcyA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSB7IGluQ2xhc3MgPSBmYWxzZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSB7IGJyZWFrIH1cbiAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCI7XG4gICAgfSBlbHNlIHsgZXNjYXBlZCA9IGZhbHNlOyB9XG4gICAgKyt0aGlzLnBvcztcbiAgfVxuICB2YXIgcGF0dGVybiA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKTtcbiAgKyt0aGlzLnBvcztcbiAgdmFyIGZsYWdzU3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIGZsYWdzID0gdGhpcy5yZWFkV29yZDEoKTtcbiAgaWYgKHRoaXMuY29udGFpbnNFc2MpIHsgdGhpcy51bmV4cGVjdGVkKGZsYWdzU3RhcnQpOyB9XG5cbiAgLy8gVmFsaWRhdGUgcGF0dGVyblxuICB2YXIgc3RhdGUgPSB0aGlzLnJlZ2V4cFN0YXRlIHx8ICh0aGlzLnJlZ2V4cFN0YXRlID0gbmV3IFJlZ0V4cFZhbGlkYXRpb25TdGF0ZSh0aGlzKSk7XG4gIHN0YXRlLnJlc2V0KHN0YXJ0LCBwYXR0ZXJuLCBmbGFncyk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhzdGF0ZSk7XG4gIHRoaXMudmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHN0YXRlKTtcblxuICAvLyBDcmVhdGUgTGl0ZXJhbCN2YWx1ZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gRVNUcmVlIHJlcXVpcmVzIG51bGwgaWYgaXQgZmFpbGVkIHRvIGluc3RhbnRpYXRlIFJlZ0V4cCBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9hMjcwMDNhZGY0ZmQ3YmZhZDQ0ZGU5Y2VmMzcyYTJlYWNkNTI3YjFjL2VzNS5tZCNyZWdleHBsaXRlcmFsXG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBwYXR0ZXJuLCBmbGFnczogZmxhZ3MsIHZhbHVlOiB2YWx1ZX0pXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuLy8gd2VyZSByZWFkLCB0aGUgaW50ZWdlciB2YWx1ZSBvdGhlcndpc2UuIFdoZW4gYGxlbmAgaXMgZ2l2ZW4sIHRoaXNcbi8vIHdpbGwgcmV0dXJuIGBudWxsYCB1bmxlc3MgdGhlIGludGVnZXIgaGFzIGV4YWN0bHkgYGxlbmAgZGlnaXRzLlxuXG5wcCQ5LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuKSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIHZhciBjb2RlID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgdmFsID0gKHZvaWQgMCk7XG4gICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gLy8gYVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgeyB2YWwgPSBjb2RlIC0gNDg7IH0gLy8gMC05XG4gICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgKyt0aGlzLnBvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cbiAgaWYgKHRoaXMucG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiB0aGlzLnBvcyAtIHN0YXJ0ICE9PSBsZW4pIHsgcmV0dXJuIG51bGwgfVxuXG4gIHJldHVybiB0b3RhbFxufTtcblxucHAkOS5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbihyYWRpeCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdGhpcy5wb3MgKz0gMjsgLy8gMHhcbiAgdmFyIHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gIGlmICh2YWwgPT0gbnVsbCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQgKyAyLCBcIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCBcIiArIHJhZGl4KTsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDExICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDExMCkge1xuICAgIHZhbCA9IHR5cGVvZiBCaWdJbnQgIT09IFwidW5kZWZpbmVkXCIgPyBCaWdJbnQodGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpKSA6IG51bGw7XG4gICAgKyt0aGlzLnBvcztcbiAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGFuIGludGVnZXIsIG9jdGFsIGludGVnZXIsIG9yIGZsb2F0aW5nLXBvaW50IG51bWJlci5cblxucHAkOS5yZWFkTnVtYmVyID0gZnVuY3Rpb24oc3RhcnRzV2l0aERvdCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB2YXIgb2N0YWwgPSB0aGlzLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG4gIGlmIChvY3RhbCAmJiB0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIGlmIChvY3RhbCAmJiAvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcykpKSB7IG9jdGFsID0gZmFsc2U7IH1cbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoIW9jdGFsICYmICFzdGFydHNXaXRoRG90ICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSAxMSAmJiBuZXh0ID09PSAxMTApIHtcbiAgICB2YXIgc3RyJDEgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICAgdmFyIHZhbCQxID0gdHlwZW9mIEJpZ0ludCAhPT0gXCJ1bmRlZmluZWRcIiA/IEJpZ0ludChzdHIkMSkgOiBudWxsO1xuICAgICsrdGhpcy5wb3M7XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLm51bSwgdmFsJDEpXG4gIH1cbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpO1xuICB2YXIgdmFsID0gb2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYSBzdHJpbmcgdmFsdWUsIGludGVycHJldGluZyBiYWNrc2xhc2gtZXNjYXBlcy5cblxucHAkOS5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksIGNvZGU7XG5cbiAgaWYgKGNoID09PSAxMjMpIHsgLy8gJ3snXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICB2YXIgY29kZVBvcyA9ICsrdGhpcy5wb3M7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLCB0aGlzLnBvcykgLSB0aGlzLnBvcyk7XG4gICAgKyt0aGlzLnBvcztcbiAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVcbn07XG5cbmZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nJDEoY29kZSkge1xuICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIH1cbiAgY29kZSAtPSAweDEwMDAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDAsIChjb2RlICYgMTAyMykgKyAweERDMDApXG59XG5cbnBwJDkucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHF1b3RlKSB7XG4gIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgaWYgKGNoID09PSBxdW90ZSkgeyBicmVhayB9XG4gICAgaWYgKGNoID09PSA5MikgeyAvLyAnXFwnXG4gICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcy5yZWFkRXNjYXBlZENoYXIoZmFsc2UpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXdMaW5lKGNoLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gMTApKSB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxuICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcysrKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuc3RyaW5nLCBvdXQpXG59O1xuXG4vLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG52YXIgSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IgPSB7fTtcblxucHAkOS50cnlSZWFkVGVtcGxhdGVUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluVGVtcGxhdGVFbGVtZW50ID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICB0aGlzLnJlYWRUbXBsVG9rZW4oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciA9PT0gSU5WQUxJRF9URU1QTEFURV9FU0NBUEVfRVJST1IpIHtcbiAgICAgIHRoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSBmYWxzZTtcbn07XG5cbnBwJDkuaW52YWxpZFN0cmluZ1Rva2VuID0gZnVuY3Rpb24ocG9zaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDkpIHtcbiAgICB0aHJvdyBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUlxuICB9IGVsc2Uge1xuICAgIHRoaXMucmFpc2UocG9zaXRpb24sIG1lc3NhZ2UpO1xuICB9XG59O1xuXG5wcCQ5LnJlYWRUbXBsVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvcztcbiAgZm9yICg7Oykge1xuICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmlucHV0Lmxlbmd0aCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpOyB9XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgICBpZiAoY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgaWYgKHRoaXMucG9zID09PSB0aGlzLnN0YXJ0ICYmICh0aGlzLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSkge1xuICAgICAgICBpZiAoY2ggPT09IDM2KSB7XG4gICAgICAgICAgdGhpcy5wb3MgKz0gMjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5iYWNrUXVvdGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnRlbXBsYXRlLCBvdXQpXG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHsgLy8gJ1xcJ1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgb3V0ICs9IHRoaXMucmVhZEVzY2FwZWRDaGFyKHRydWUpO1xuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICsrdGhpcy5jdXJMaW5lO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMucG9zO1xuICAgICAgfVxuICAgICAgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMucG9zO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xucHAkOS5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMuaW5wdXRbdGhpcy5wb3NdKSB7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICsrdGhpcy5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzLmlucHV0W3RoaXMucG9zICsgMV0gIT09IFwie1wiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSBcImBcIjpcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcykpXG5cbiAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9XG4gIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbnBwJDkucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHN3aXRjaCAoY2gpIHtcbiAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyQxKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgY2FzZSAxMTY6IHJldHVybiBcIlxcdFwiIC8vICd0JyAtPiAnXFx0J1xuICBjYXNlIDk4OiByZXR1cm4gXCJcXGJcIiAvLyAnYicgLT4gJ1xcYidcbiAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gIGNhc2UgMTAyOiByZXR1cm4gXCJcXGZcIiAvLyAnZicgLT4gJ1xcZidcbiAgY2FzZSAxMzogaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykgPT09IDEwKSB7ICsrdGhpcy5wb3M7IH0gLy8gJ1xcclxcbidcbiAgY2FzZSAxMDogLy8gJyBcXG4nXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmU7IH1cbiAgICByZXR1cm4gXCJcIlxuICBkZWZhdWx0OlxuICAgIGlmIChjaCA+PSA0OCAmJiBjaCA8PSA1NSkge1xuICAgICAgdmFyIG9jdGFsU3RyID0gdGhpcy5pbnB1dC5zdWJzdHIodGhpcy5wb3MgLSAxLCAzKS5tYXRjaCgvXlswLTddKy8pWzBdO1xuICAgICAgdmFyIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgICBpZiAoKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBjaCA9PT0gNTYgfHwgY2ggPT09IDU3KSAmJiAodGhpcy5zdHJpY3QgfHwgaW5UZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oXG4gICAgICAgICAgdGhpcy5wb3MgLSAxIC0gb2N0YWxTdHIubGVuZ3RoLFxuICAgICAgICAgIGluVGVtcGxhdGVcbiAgICAgICAgICAgID8gXCJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZ1wiXG4gICAgICAgICAgICA6IFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICB9XG4gICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgIC8vIFVuaWNvZGUgbmV3IGxpbmUgY2hhcmFjdGVycyBhZnRlciBcXCBnZXQgcmVtb3ZlZCBmcm9tIG91dHB1dCBpbiBib3RoXG4gICAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyBhbmQgc3RyaW5nc1xuICAgICAgcmV0dXJuIFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbnBwJDkucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcCQ5LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7XG4gICAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gsIGFzdHJhbCkpIHtcbiAgICAgIHRoaXMucG9zICs9IGNoIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgdGhpcy5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICB3b3JkICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpO1xuICAgICAgdmFyIGVzY1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpICE9PSAxMTcpIC8vIFwidVwiXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKTsgfVxuICAgICAgKyt0aGlzLnBvcztcbiAgICAgIHZhciBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQoKTtcbiAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgIHsgdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4oZXNjU3RhcnQsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTsgfVxuICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyQxKGVzYyk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKVxufTtcblxuLy8gUmVhZCBhbiBpZGVudGlmaWVyIG9yIGtleXdvcmQgdG9rZW4uIFdpbGwgY2hlY2sgZm9yIHJlc2VydmVkXG4vLyB3b3JkcyB3aGVuIG5lY2Vzc2FyeS5cblxucHAkOS5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd29yZCA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0eXBlID0gdHlwZXMubmFtZTtcbiAgaWYgKHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zRXNjKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCBcIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIFwiICsgd29yZCk7IH1cbiAgICB0eXBlID0ga2V5d29yZHMkMVt3b3JkXTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxufTtcblxuLy8gQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cblxudmFyIHZlcnNpb24gPSBcIjYuMy4wXCI7XG5cbi8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4vLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4vLyBBUEldW2FwaV0uXG4vL1xuLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci5wYXJzZShpbnB1dCwgb3B0aW9ucylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBwYXJzZSBhIHNpbmdsZSBleHByZXNzaW9uIGF0IGEgZ2l2ZW5cbi8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbi8vIHRoYXQgZW1iZWQgSmF2YVNjcmlwdCBleHByZXNzaW9ucy5cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uQXQoaW5wdXQsIHBvcywgb3B0aW9ucykge1xuICByZXR1cm4gUGFyc2VyLnBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpXG59XG5cbi8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4vLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG5mdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFBhcnNlci50b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpXG59XG5cbmV4cG9ydCB7IE5vZGUsIFBhcnNlciwgUG9zaXRpb24sIFNvdXJjZUxvY2F0aW9uLCBUb2tDb250ZXh0LCBUb2tlbiwgVG9rZW5UeXBlLCBkZWZhdWx0T3B0aW9ucywgZ2V0TGluZUluZm8sIGlzSWRlbnRpZmllckNoYXIsIGlzSWRlbnRpZmllclN0YXJ0LCBpc05ld0xpbmUsIGtleXdvcmRzJDEgYXMga2V5d29yZFR5cGVzLCBsaW5lQnJlYWssIGxpbmVCcmVha0csIG5vbkFTQ0lJd2hpdGVzcGFjZSwgcGFyc2UsIHBhcnNlRXhwcmVzc2lvbkF0LCB0eXBlcyQxIGFzIHRva0NvbnRleHRzLCB0eXBlcyBhcyB0b2tUeXBlcywgdG9rZW5pemVyLCB2ZXJzaW9uIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qXG4gKiBhbmltZS5qcyB2My4xLjBcbiAqIChjKSAyMDE5IEp1bGlhbiBHYXJuaWVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGFuaW1lanMuY29tXG4gKi9cblxuLy8gRGVmYXVsdHNcblxudmFyIGRlZmF1bHRJbnN0YW5jZVNldHRpbmdzID0ge1xuICB1cGRhdGU6IG51bGwsXG4gIGJlZ2luOiBudWxsLFxuICBsb29wQmVnaW46IG51bGwsXG4gIGNoYW5nZUJlZ2luOiBudWxsLFxuICBjaGFuZ2U6IG51bGwsXG4gIGNoYW5nZUNvbXBsZXRlOiBudWxsLFxuICBsb29wQ29tcGxldGU6IG51bGwsXG4gIGNvbXBsZXRlOiBudWxsLFxuICBsb29wOiAxLFxuICBkaXJlY3Rpb246ICdub3JtYWwnLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgdGltZWxpbmVPZmZzZXQ6IDBcbn07XG5cbnZhciBkZWZhdWx0VHdlZW5TZXR0aW5ncyA9IHtcbiAgZHVyYXRpb246IDEwMDAsXG4gIGRlbGF5OiAwLFxuICBlbmREZWxheTogMCxcbiAgZWFzaW5nOiAnZWFzZU91dEVsYXN0aWMoMSwgLjUpJyxcbiAgcm91bmQ6IDBcbn07XG5cbnZhciB2YWxpZFRyYW5zZm9ybXMgPSBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICd0cmFuc2xhdGVaJywgJ3JvdGF0ZScsICdyb3RhdGVYJywgJ3JvdGF0ZVknLCAncm90YXRlWicsICdzY2FsZScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ3NjYWxlWicsICdza2V3JywgJ3NrZXdYJywgJ3NrZXdZJywgJ3BlcnNwZWN0aXZlJ107XG5cbi8vIENhY2hpbmdcblxudmFyIGNhY2hlID0ge1xuICBDU1M6IHt9LFxuICBzcHJpbmdzOiB7fVxufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gbWluTWF4KHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nQ29udGFpbnMoc3RyLCB0ZXh0KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZih0ZXh0KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBhcHBseUFyZ3VtZW50cyhmdW5jLCBhcmdzKSB7XG4gIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgaXMgPSB7XG4gIGFycjogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoYSk7IH0sXG4gIG9iajogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHN0cmluZ0NvbnRhaW5zKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSwgJ09iamVjdCcpOyB9LFxuICBwdGg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBpcy5vYmooYSkgJiYgYS5oYXNPd25Qcm9wZXJ0eSgndG90YWxMZW5ndGgnKTsgfSxcbiAgc3ZnOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7IH0sXG4gIGlucDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50OyB9LFxuICBkb206IGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLm5vZGVUeXBlIHx8IGlzLnN2ZyhhKTsgfSxcbiAgc3RyOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICdzdHJpbmcnOyB9LFxuICBmbmM6IGZ1bmN0aW9uIChhKSB7IHJldHVybiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJzsgfSxcbiAgdW5kOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnOyB9LFxuICBoZXg6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAvKF4jWzAtOUEtRl17Nn0kKXwoXiNbMC05QS1GXXszfSQpL2kudGVzdChhKTsgfSxcbiAgcmdiOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gL15yZ2IvLnRlc3QoYSk7IH0sXG4gIGhzbDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIC9eaHNsLy50ZXN0KGEpOyB9LFxuICBjb2w6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAoaXMuaGV4KGEpIHx8IGlzLnJnYihhKSB8fCBpcy5oc2woYSkpOyB9LFxuICBrZXk6IGZ1bmN0aW9uIChhKSB7IHJldHVybiAhZGVmYXVsdEluc3RhbmNlU2V0dGluZ3MuaGFzT3duUHJvcGVydHkoYSkgJiYgIWRlZmF1bHRUd2VlblNldHRpbmdzLmhhc093blByb3BlcnR5KGEpICYmIGEgIT09ICd0YXJnZXRzJyAmJiBhICE9PSAna2V5ZnJhbWVzJzsgfVxufTtcblxuLy8gRWFzaW5nc1xuXG5mdW5jdGlvbiBwYXJzZUVhc2luZ1BhcmFtZXRlcnMoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IC9cXCgoW14pXSspXFwpLy5leGVjKHN0cmluZyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXJzZUZsb2F0KHApOyB9KSA6IFtdO1xufVxuXG4vLyBTcHJpbmcgc29sdmVyIGluc3BpcmVkIGJ5IFdlYmtpdCBDb3B5cmlnaHQgwqkgMjAxNiBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIGh0dHBzOi8vd2Via2l0Lm9yZy9kZW1vcy9zcHJpbmcvc3ByaW5nLmpzXG5cbmZ1bmN0aW9uIHNwcmluZyhzdHJpbmcsIGR1cmF0aW9uKSB7XG5cbiAgdmFyIHBhcmFtcyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhzdHJpbmcpO1xuICB2YXIgbWFzcyA9IG1pbk1heChpcy51bmQocGFyYW1zWzBdKSA/IDEgOiBwYXJhbXNbMF0sIC4xLCAxMDApO1xuICB2YXIgc3RpZmZuZXNzID0gbWluTWF4KGlzLnVuZChwYXJhbXNbMV0pID8gMTAwIDogcGFyYW1zWzFdLCAuMSwgMTAwKTtcbiAgdmFyIGRhbXBpbmcgPSBtaW5NYXgoaXMudW5kKHBhcmFtc1syXSkgPyAxMCA6IHBhcmFtc1syXSwgLjEsIDEwMCk7XG4gIHZhciB2ZWxvY2l0eSA9ICBtaW5NYXgoaXMudW5kKHBhcmFtc1szXSkgPyAwIDogcGFyYW1zWzNdLCAuMSwgMTAwKTtcbiAgdmFyIHcwID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpO1xuICB2YXIgemV0YSA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gIHZhciB3ZCA9IHpldGEgPCAxID8gdzAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiB6ZXRhKSA6IDA7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSB6ZXRhIDwgMSA/ICh6ZXRhICogdzAgKyAtdmVsb2NpdHkpIC8gd2QgOiAtdmVsb2NpdHkgKyB3MDtcblxuICBmdW5jdGlvbiBzb2x2ZXIodCkge1xuICAgIHZhciBwcm9ncmVzcyA9IGR1cmF0aW9uID8gKGR1cmF0aW9uICogdCkgLyAxMDAwIDogdDtcbiAgICBpZiAoemV0YSA8IDEpIHtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5leHAoLXByb2dyZXNzICogemV0YSAqIHcwKSAqIChhICogTWF0aC5jb3Mod2QgKiBwcm9ncmVzcykgKyBiICogTWF0aC5zaW4od2QgKiBwcm9ncmVzcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9ncmVzcyA9IChhICsgYiAqIHByb2dyZXNzKSAqIE1hdGguZXhwKC1wcm9ncmVzcyAqIHcwKTtcbiAgICB9XG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkgeyByZXR1cm4gdDsgfVxuICAgIHJldHVybiAxIC0gcHJvZ3Jlc3M7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREdXJhdGlvbigpIHtcbiAgICB2YXIgY2FjaGVkID0gY2FjaGUuc3ByaW5nc1tzdHJpbmddO1xuICAgIGlmIChjYWNoZWQpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICAgIHZhciBmcmFtZSA9IDEvNjtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG4gICAgdmFyIHJlc3QgPSAwO1xuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIGVsYXBzZWQgKz0gZnJhbWU7XG4gICAgICBpZiAoc29sdmVyKGVsYXBzZWQpID09PSAxKSB7XG4gICAgICAgIHJlc3QrKztcbiAgICAgICAgaWYgKHJlc3QgPj0gMTYpIHsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3QgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZHVyYXRpb24gPSBlbGFwc2VkICogZnJhbWUgKiAxMDAwO1xuICAgIGNhY2hlLnNwcmluZ3Nbc3RyaW5nXSA9IGR1cmF0aW9uO1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbiA/IHNvbHZlciA6IGdldER1cmF0aW9uO1xuXG59XG5cbi8vIEJhc2ljIHN0ZXBzIGVhc2luZyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9mci9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cblxuZnVuY3Rpb24gc3RlcHMoc3RlcHMpIHtcbiAgaWYgKCBzdGVwcyA9PT0gdm9pZCAwICkgc3RlcHMgPSAxMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucm91bmQodCAqIHN0ZXBzKSAqICgxIC8gc3RlcHMpOyB9O1xufVxuXG4vLyBCZXppZXJFYXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nXG5cbnZhciBiZXppZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG5cbiAgZnVuY3Rpb24gQShhQTEsIGFBMikgeyByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExIH1cbiAgZnVuY3Rpb24gQihhQTEsIGFBMikgeyByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExIH1cbiAgZnVuY3Rpb24gQyhhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExIH1cblxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSkgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCLCBtWDEsIG1YMikge1xuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7IGFCID0gY3VycmVudFQ7IH0gZWxzZSB7IGFBID0gY3VycmVudFQ7IH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiAwLjAwMDAwMDEgJiYgKytpIDwgMTApO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7IHJldHVybiBhR3Vlc3NUOyB9XG4gICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBiZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cbiAgICBpZiAoISgwIDw9IG1YMSAmJiBtWDEgPD0gMSAmJiAwIDw9IG1YMiAmJiBtWDIgPD0gMSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG5cbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG5cbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSAwLjAwMSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHsgcmV0dXJuIHg7IH1cbiAgICAgIGlmICh4ID09PSAwIHx8IHggPT09IDEpIHsgcmV0dXJuIHg7IH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gYmV6aWVyO1xuXG59KSgpO1xuXG52YXIgcGVubmVyID0gKGZ1bmN0aW9uICgpIHtcblxuICAvLyBCYXNlZCBvbiBqUXVlcnkgVUkncyBpbXBsZW1lbmF0aW9uIG9mIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxuXG4gIHZhciBlYXNlcyA9IHsgbGluZWFyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkgeyByZXR1cm4gdDsgfTsgfSB9O1xuXG4gIHZhciBmdW5jdGlvbkVhc2luZ3MgPSB7XG4gICAgU2luZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpOyB9OyB9LFxuICAgIENpcmM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7IH07IH0sXG4gICAgQmFjazogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgKiB0ICogKDMgKiB0IC0gMik7IH07IH0sXG4gICAgQm91bmNlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHBvdzIsIGIgPSA0O1xuICAgICAgd2hpbGUgKHQgPCAoKCBwb3cyID0gTWF0aC5wb3coMiwgLS1iKSkgLSAxKSAvIDExKSB7fVxuICAgICAgcmV0dXJuIDEgLyBNYXRoLnBvdyg0LCAzIC0gYikgLSA3LjU2MjUgKiBNYXRoLnBvdygoIHBvdzIgKiAzIC0gMiApIC8gMjIgLSB0LCAyKVxuICAgIH07IH0sXG4gICAgRWxhc3RpYzogZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgICBpZiAoIGFtcGxpdHVkZSA9PT0gdm9pZCAwICkgYW1wbGl0dWRlID0gMTtcbiAgICAgIGlmICggcGVyaW9kID09PSB2b2lkIDAgKSBwZXJpb2QgPSAuNTtcblxuICAgICAgdmFyIGEgPSBtaW5NYXgoYW1wbGl0dWRlLCAxLCAxMCk7XG4gICAgICB2YXIgcCA9IG1pbk1heChwZXJpb2QsIC4xLCAyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gKHQgPT09IDAgfHwgdCA9PT0gMSkgPyB0IDogXG4gICAgICAgICAgLWEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICogTWF0aC5zaW4oKCgodCAtIDEpIC0gKHAgLyAoTWF0aC5QSSAqIDIpICogTWF0aC5hc2luKDEgLyBhKSkpICogKE1hdGguUEkgKiAyKSkgLyBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGJhc2VFYXNpbmdzID0gWydRdWFkJywgJ0N1YmljJywgJ1F1YXJ0JywgJ1F1aW50JywgJ0V4cG8nXTtcblxuICBiYXNlRWFzaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgZnVuY3Rpb25FYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKHQpIHsgcmV0dXJuIE1hdGgucG93KHQsIGkgKyAyKTsgfTsgfTtcbiAgfSk7XG5cbiAgT2JqZWN0LmtleXMoZnVuY3Rpb25FYXNpbmdzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGVhc2VJbiA9IGZ1bmN0aW9uRWFzaW5nc1tuYW1lXTtcbiAgICBlYXNlc1snZWFzZUluJyArIG5hbWVdID0gZWFzZUluO1xuICAgIGVhc2VzWydlYXNlT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiAxIC0gZWFzZUluKGEsIGIpKDEgLSB0KTsgfTsgfTtcbiAgICBlYXNlc1snZWFzZUluT3V0JyArIG5hbWVdID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IDwgMC41ID8gZWFzZUluKGEsIGIpKHQgKiAyKSAvIDIgOiBcbiAgICAgIDEgLSBlYXNlSW4oYSwgYikodCAqIC0yICsgMikgLyAyOyB9OyB9O1xuICB9KTtcblxuICByZXR1cm4gZWFzZXM7XG5cbn0pKCk7XG5cbmZ1bmN0aW9uIHBhcnNlRWFzaW5ncyhlYXNpbmcsIGR1cmF0aW9uKSB7XG4gIGlmIChpcy5mbmMoZWFzaW5nKSkgeyByZXR1cm4gZWFzaW5nOyB9XG4gIHZhciBuYW1lID0gZWFzaW5nLnNwbGl0KCcoJylbMF07XG4gIHZhciBlYXNlID0gcGVubmVyW25hbWVdO1xuICB2YXIgYXJncyA9IHBhcnNlRWFzaW5nUGFyYW1ldGVycyhlYXNpbmcpO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzcHJpbmcnIDogcmV0dXJuIHNwcmluZyhlYXNpbmcsIGR1cmF0aW9uKTtcbiAgICBjYXNlICdjdWJpY0JlemllcicgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoYmV6aWVyLCBhcmdzKTtcbiAgICBjYXNlICdzdGVwcycgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoc3RlcHMsIGFyZ3MpO1xuICAgIGRlZmF1bHQgOiByZXR1cm4gYXBwbHlBcmd1bWVudHMoZWFzZSwgYXJncyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nc1xuXG5mdW5jdGlvbiBzZWxlY3RTdHJpbmcoc3RyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzdHIpO1xuICAgIHJldHVybiBub2RlcztcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8vIEFycmF5c1xuXG5mdW5jdGlvbiBmaWx0ZXJBcnJheShhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGkgaW4gYXJyKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsLCBpLCBhcnIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGlzLmFycihiKSA/IGZsYXR0ZW5BcnJheShiKSA6IGIpOyB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobykge1xuICBpZiAoaXMuYXJyKG8pKSB7IHJldHVybiBvOyB9XG4gIGlmIChpcy5zdHIobykpIHsgbyA9IHNlbGVjdFN0cmluZyhvKSB8fCBvOyB9XG4gIGlmIChvIGluc3RhbmNlb2YgTm9kZUxpc3QgfHwgbyBpbnN0YW5jZW9mIEhUTUxDb2xsZWN0aW9uKSB7IHJldHVybiBbXS5zbGljZS5jYWxsKG8pOyB9XG4gIHJldHVybiBbb107XG59XG5cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnMoYXJyLCB2YWwpIHtcbiAgcmV0dXJuIGFyci5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhID09PSB2YWw7IH0pO1xufVxuXG4vLyBPYmplY3RzXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG8pIHtcbiAgdmFyIGNsb25lID0ge307XG4gIGZvciAodmFyIHAgaW4gbykgeyBjbG9uZVtwXSA9IG9bcF07IH1cbiAgcmV0dXJuIGNsb25lO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlT2JqZWN0UHJvcHMobzEsIG8yKSB7XG4gIHZhciBvID0gY2xvbmVPYmplY3QobzEpO1xuICBmb3IgKHZhciBwIGluIG8xKSB7IG9bcF0gPSBvMi5oYXNPd25Qcm9wZXJ0eShwKSA/IG8yW3BdIDogbzFbcF07IH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvMSwgbzIpIHtcbiAgdmFyIG8gPSBjbG9uZU9iamVjdChvMSk7XG4gIGZvciAodmFyIHAgaW4gbzIpIHsgb1twXSA9IGlzLnVuZChvMVtwXSkgPyBvMltwXSA6IG8xW3BdOyB9XG4gIHJldHVybiBvO1xufVxuXG4vLyBDb2xvcnNcblxuZnVuY3Rpb24gcmdiVG9SZ2JhKHJnYlZhbHVlKSB7XG4gIHZhciByZ2IgPSAvcmdiXFwoKFxcZCssXFxzKltcXGRdKyxcXHMqW1xcZF0rKVxcKS9nLmV4ZWMocmdiVmFsdWUpO1xuICByZXR1cm4gcmdiID8gKFwicmdiYShcIiArIChyZ2JbMV0pICsgXCIsMSlcIikgOiByZ2JWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleFZhbHVlKSB7XG4gIHZhciByZ3ggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICB2YXIgaGV4ID0gaGV4VmFsdWUucmVwbGFjZShyZ3gsIGZ1bmN0aW9uIChtLCByLCBnLCBiKSB7IHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7IH0gKTtcbiAgdmFyIHJnYiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2kuZXhlYyhoZXgpO1xuICB2YXIgciA9IHBhcnNlSW50KHJnYlsxXSwgMTYpO1xuICB2YXIgZyA9IHBhcnNlSW50KHJnYlsyXSwgMTYpO1xuICB2YXIgYiA9IHBhcnNlSW50KHJnYlszXSwgMTYpO1xuICByZXR1cm4gKFwicmdiYShcIiArIHIgKyBcIixcIiArIGcgKyBcIixcIiArIGIgKyBcIiwxKVwiKTtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2JhKGhzbFZhbHVlKSB7XG4gIHZhciBoc2wgPSAvaHNsXFwoKFxcZCspLFxccyooW1xcZC5dKyklLFxccyooW1xcZC5dKyklXFwpL2cuZXhlYyhoc2xWYWx1ZSkgfHwgL2hzbGFcXCgoXFxkKyksXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKSUsXFxzKihbXFxkLl0rKVxcKS9nLmV4ZWMoaHNsVmFsdWUpO1xuICB2YXIgaCA9IHBhcnNlSW50KGhzbFsxXSwgMTApIC8gMzYwO1xuICB2YXIgcyA9IHBhcnNlSW50KGhzbFsyXSwgMTApIC8gMTAwO1xuICB2YXIgbCA9IHBhcnNlSW50KGhzbFszXSwgMTApIC8gMTAwO1xuICB2YXIgYSA9IGhzbFs0XSB8fCAxO1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHsgdCArPSAxOyB9XG4gICAgaWYgKHQgPiAxKSB7IHQgLT0gMTsgfVxuICAgIGlmICh0IDwgMS82KSB7IHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0OyB9XG4gICAgaWYgKHQgPCAxLzIpIHsgcmV0dXJuIHE7IH1cbiAgICBpZiAodCA8IDIvMykgeyByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2OyB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgdmFyIHIsIGcsIGI7XG4gIGlmIChzID09IDApIHtcbiAgICByID0gZyA9IGIgPSBsO1xuICB9IGVsc2Uge1xuICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMS8zKTtcbiAgfVxuICByZXR1cm4gKFwicmdiYShcIiArIChyICogMjU1KSArIFwiLFwiICsgKGcgKiAyNTUpICsgXCIsXCIgKyAoYiAqIDI1NSkgKyBcIixcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGNvbG9yVG9SZ2IodmFsKSB7XG4gIGlmIChpcy5yZ2IodmFsKSkgeyByZXR1cm4gcmdiVG9SZ2JhKHZhbCk7IH1cbiAgaWYgKGlzLmhleCh2YWwpKSB7IHJldHVybiBoZXhUb1JnYmEodmFsKTsgfVxuICBpZiAoaXMuaHNsKHZhbCkpIHsgcmV0dXJuIGhzbFRvUmdiYSh2YWwpOyB9XG59XG5cbi8vIFVuaXRzXG5cbmZ1bmN0aW9uIGdldFVuaXQodmFsKSB7XG4gIHZhciBzcGxpdCA9IC9bKy1dP1xcZCpcXC4/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyglfHB4fHB0fGVtfHJlbXxpbnxjbXxtbXxleHxjaHxwY3x2d3x2aHx2bWlufHZtYXh8ZGVnfHJhZHx0dXJuKT8kLy5leGVjKHZhbCk7XG4gIGlmIChzcGxpdCkgeyByZXR1cm4gc3BsaXRbMV07IH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSkge1xuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICd0cmFuc2xhdGUnKSB8fCBwcm9wTmFtZSA9PT0gJ3BlcnNwZWN0aXZlJykgeyByZXR1cm4gJ3B4JzsgfVxuICBpZiAoc3RyaW5nQ29udGFpbnMocHJvcE5hbWUsICdyb3RhdGUnKSB8fCBzdHJpbmdDb250YWlucyhwcm9wTmFtZSwgJ3NrZXcnKSkgeyByZXR1cm4gJ2RlZyc7IH1cbn1cblxuLy8gVmFsdWVzXG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVmFsdWUodmFsLCBhbmltYXRhYmxlKSB7XG4gIGlmICghaXMuZm5jKHZhbCkpIHsgcmV0dXJuIHZhbDsgfVxuICByZXR1cm4gdmFsKGFuaW1hdGFibGUudGFyZ2V0LCBhbmltYXRhYmxlLmlkLCBhbmltYXRhYmxlLnRvdGFsKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBwcm9wKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUocHJvcCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIHZhbHVlVW5pdCA9IGdldFVuaXQodmFsdWUpO1xuICBpZiAoYXJyYXlDb250YWlucyhbdW5pdCwgJ2RlZycsICdyYWQnLCAndHVybiddLCB2YWx1ZVVuaXQpKSB7IHJldHVybiB2YWx1ZTsgfVxuICB2YXIgY2FjaGVkID0gY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF07XG4gIGlmICghaXMudW5kKGNhY2hlZCkpIHsgcmV0dXJuIGNhY2hlZDsgfVxuICB2YXIgYmFzZWxpbmUgPSAxMDA7XG4gIHZhciB0ZW1wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuICB2YXIgcGFyZW50RWwgPSAoZWwucGFyZW50Tm9kZSAmJiAoZWwucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQpKSA/IGVsLnBhcmVudE5vZGUgOiBkb2N1bWVudC5ib2R5O1xuICBwYXJlbnRFbC5hcHBlbmRDaGlsZCh0ZW1wRWwpO1xuICB0ZW1wRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0ZW1wRWwuc3R5bGUud2lkdGggPSBiYXNlbGluZSArIHVuaXQ7XG4gIHZhciBmYWN0b3IgPSBiYXNlbGluZSAvIHRlbXBFbC5vZmZzZXRXaWR0aDtcbiAgcGFyZW50RWwucmVtb3ZlQ2hpbGQodGVtcEVsKTtcbiAgdmFyIGNvbnZlcnRlZFVuaXQgPSBmYWN0b3IgKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgY2FjaGUuQ1NTW3ZhbHVlICsgdW5pdF0gPSBjb252ZXJ0ZWRVbml0O1xuICByZXR1cm4gY29udmVydGVkVW5pdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q1NTVmFsdWUoZWwsIHByb3AsIHVuaXQpIHtcbiAgaWYgKHByb3AgaW4gZWwuc3R5bGUpIHtcbiAgICB2YXIgdXBwZXJjYXNlUHJvcE5hbWUgPSBwcm9wLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gZWwuc3R5bGVbcHJvcF0gfHwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZSh1cHBlcmNhc2VQcm9wTmFtZSkgfHwgJzAnO1xuICAgIHJldHVybiB1bml0ID8gY29udmVydFB4VG9Vbml0KGVsLCB2YWx1ZSwgdW5pdCkgOiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRpb25UeXBlKGVsLCBwcm9wKSB7XG4gIGlmIChpcy5kb20oZWwpICYmICFpcy5pbnAoZWwpICYmIChnZXRBdHRyaWJ1dGUoZWwsIHByb3ApIHx8IChpcy5zdmcoZWwpICYmIGVsW3Byb3BdKSkpIHsgcmV0dXJuICdhdHRyaWJ1dGUnOyB9XG4gIGlmIChpcy5kb20oZWwpICYmIGFycmF5Q29udGFpbnModmFsaWRUcmFuc2Zvcm1zLCBwcm9wKSkgeyByZXR1cm4gJ3RyYW5zZm9ybSc7IH1cbiAgaWYgKGlzLmRvbShlbCkgJiYgKHByb3AgIT09ICd0cmFuc2Zvcm0nICYmIGdldENTU1ZhbHVlKGVsLCBwcm9wKSkpIHsgcmV0dXJuICdjc3MnOyB9XG4gIGlmIChlbFtwcm9wXSAhPSBudWxsKSB7IHJldHVybiAnb2JqZWN0JzsgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50VHJhbnNmb3JtcyhlbCkge1xuICBpZiAoIWlzLmRvbShlbCkpIHsgcmV0dXJuOyB9XG4gIHZhciBzdHIgPSBlbC5zdHlsZS50cmFuc2Zvcm0gfHwgJyc7XG4gIHZhciByZWcgID0gLyhcXHcrKVxcKChbXildKilcXCkvZztcbiAgdmFyIHRyYW5zZm9ybXMgPSBuZXcgTWFwKCk7XG4gIHZhciBtOyB3aGlsZSAobSA9IHJlZy5leGVjKHN0cikpIHsgdHJhbnNmb3Jtcy5zZXQobVsxXSwgbVsyXSk7IH1cbiAgcmV0dXJuIHRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlKGVsLCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCkge1xuICB2YXIgZGVmYXVsdFZhbCA9IHN0cmluZ0NvbnRhaW5zKHByb3BOYW1lLCAnc2NhbGUnKSA/IDEgOiAwICsgZ2V0VHJhbnNmb3JtVW5pdChwcm9wTmFtZSk7XG4gIHZhciB2YWx1ZSA9IGdldEVsZW1lbnRUcmFuc2Zvcm1zKGVsKS5nZXQocHJvcE5hbWUpIHx8IGRlZmF1bHRWYWw7XG4gIGlmIChhbmltYXRhYmxlKSB7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLmxpc3Quc2V0KHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgYW5pbWF0YWJsZS50cmFuc2Zvcm1zWydsYXN0J10gPSBwcm9wTmFtZTtcbiAgfVxuICByZXR1cm4gdW5pdCA/IGNvbnZlcnRQeFRvVW5pdChlbCwgdmFsdWUsIHVuaXQpIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgdW5pdCwgYW5pbWF0YWJsZSkge1xuICBzd2l0Y2ggKGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wTmFtZSkpIHtcbiAgICBjYXNlICd0cmFuc2Zvcm0nOiByZXR1cm4gZ2V0VHJhbnNmb3JtVmFsdWUodGFyZ2V0LCBwcm9wTmFtZSwgYW5pbWF0YWJsZSwgdW5pdCk7XG4gICAgY2FzZSAnY3NzJzogcmV0dXJuIGdldENTU1ZhbHVlKHRhcmdldCwgcHJvcE5hbWUsIHVuaXQpO1xuICAgIGNhc2UgJ2F0dHJpYnV0ZSc6IHJldHVybiBnZXRBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wTmFtZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRhcmdldFtwcm9wTmFtZV0gfHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSB7XG4gIHZhciBvcGVyYXRvciA9IC9eKFxcKj18XFwrPXwtPSkvLmV4ZWModG8pO1xuICBpZiAoIW9wZXJhdG9yKSB7IHJldHVybiB0bzsgfVxuICB2YXIgdSA9IGdldFVuaXQodG8pIHx8IDA7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChmcm9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHRvLnJlcGxhY2Uob3BlcmF0b3JbMF0sICcnKSk7XG4gIHN3aXRjaCAob3BlcmF0b3JbMF1bMF0pIHtcbiAgICBjYXNlICcrJzogcmV0dXJuIHggKyB5ICsgdTtcbiAgICBjYXNlICctJzogcmV0dXJuIHggLSB5ICsgdTtcbiAgICBjYXNlICcqJzogcmV0dXJuIHggKiB5ICsgdTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVZhbHVlKHZhbCwgdW5pdCkge1xuICBpZiAoaXMuY29sKHZhbCkpIHsgcmV0dXJuIGNvbG9yVG9SZ2IodmFsKTsgfVxuICBpZiAoL1xccy9nLnRlc3QodmFsKSkgeyByZXR1cm4gdmFsOyB9XG4gIHZhciBvcmlnaW5hbFVuaXQgPSBnZXRVbml0KHZhbCk7XG4gIHZhciB1bml0TGVzcyA9IG9yaWdpbmFsVW5pdCA/IHZhbC5zdWJzdHIoMCwgdmFsLmxlbmd0aCAtIG9yaWdpbmFsVW5pdC5sZW5ndGgpIDogdmFsO1xuICBpZiAodW5pdCkgeyByZXR1cm4gdW5pdExlc3MgKyB1bml0OyB9XG4gIHJldHVybiB1bml0TGVzcztcbn1cblxuLy8gZ2V0VG90YWxMZW5ndGgoKSBlcXVpdmFsZW50IGZvciBjaXJjbGUsIHJlY3QsIHBvbHlsaW5lLCBwb2x5Z29uIGFuZCBsaW5lIHNoYXBlc1xuLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NlYkxhbWJsYS8zZTA1NTBjNDk2YzIzNjcwOTc0NFxuXG5mdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMi54IC0gcDEueCwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xufVxuXG5mdW5jdGlvbiBnZXRDaXJjbGVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiAyICogZ2V0QXR0cmlidXRlKGVsLCAncicpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0TGVuZ3RoKGVsKSB7XG4gIHJldHVybiAoZ2V0QXR0cmlidXRlKGVsLCAnd2lkdGgnKSAqIDIpICsgKGdldEF0dHJpYnV0ZShlbCwgJ2hlaWdodCcpICogMik7XG59XG5cbmZ1bmN0aW9uIGdldExpbmVMZW5ndGgoZWwpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKFxuICAgIHt4OiBnZXRBdHRyaWJ1dGUoZWwsICd4MScpLCB5OiBnZXRBdHRyaWJ1dGUoZWwsICd5MScpfSwgXG4gICAge3g6IGdldEF0dHJpYnV0ZShlbCwgJ3gyJyksIHk6IGdldEF0dHJpYnV0ZShlbCwgJ3kyJyl9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSB7XG4gIHZhciBwb2ludHMgPSBlbC5wb2ludHM7XG4gIHZhciB0b3RhbExlbmd0aCA9IDA7XG4gIHZhciBwcmV2aW91c1BvcztcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9pbnRzLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIHZhciBjdXJyZW50UG9zID0gcG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgaWYgKGkgPiAwKSB7IHRvdGFsTGVuZ3RoICs9IGdldERpc3RhbmNlKHByZXZpb3VzUG9zLCBjdXJyZW50UG9zKTsgfVxuICAgIHByZXZpb3VzUG9zID0gY3VycmVudFBvcztcbiAgfVxuICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldFBvbHlnb25MZW5ndGgoZWwpIHtcbiAgdmFyIHBvaW50cyA9IGVsLnBvaW50cztcbiAgcmV0dXJuIGdldFBvbHlsaW5lTGVuZ3RoKGVsKSArIGdldERpc3RhbmNlKHBvaW50cy5nZXRJdGVtKHBvaW50cy5udW1iZXJPZkl0ZW1zIC0gMSksIHBvaW50cy5nZXRJdGVtKDApKTtcbn1cblxuLy8gUGF0aCBhbmltYXRpb25cblxuZnVuY3Rpb24gZ2V0VG90YWxMZW5ndGgoZWwpIHtcbiAgaWYgKGVsLmdldFRvdGFsTGVuZ3RoKSB7IHJldHVybiBlbC5nZXRUb3RhbExlbmd0aCgpOyB9XG4gIHN3aXRjaChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdjaXJjbGUnOiByZXR1cm4gZ2V0Q2lyY2xlTGVuZ3RoKGVsKTtcbiAgICBjYXNlICdyZWN0JzogcmV0dXJuIGdldFJlY3RMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ2xpbmUnOiByZXR1cm4gZ2V0TGluZUxlbmd0aChlbCk7XG4gICAgY2FzZSAncG9seWxpbmUnOiByZXR1cm4gZ2V0UG9seWxpbmVMZW5ndGgoZWwpO1xuICAgIGNhc2UgJ3BvbHlnb24nOiByZXR1cm4gZ2V0UG9seWdvbkxlbmd0aChlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RGFzaG9mZnNldChlbCkge1xuICB2YXIgcGF0aExlbmd0aCA9IGdldFRvdGFsTGVuZ3RoKGVsKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgcGF0aExlbmd0aCk7XG4gIHJldHVybiBwYXRoTGVuZ3RoO1xufVxuXG4vLyBNb3Rpb24gcGF0aFxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdmdFbChlbCkge1xuICB2YXIgcGFyZW50RWwgPSBlbC5wYXJlbnROb2RlO1xuICB3aGlsZSAoaXMuc3ZnKHBhcmVudEVsKSkge1xuICAgIGlmICghaXMuc3ZnKHBhcmVudEVsLnBhcmVudE5vZGUpKSB7IGJyZWFrOyB9XG4gICAgcGFyZW50RWwgPSBwYXJlbnRFbC5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBwYXJlbnRFbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3ZnKHBhdGhFbCwgc3ZnRGF0YSkge1xuICB2YXIgc3ZnID0gc3ZnRGF0YSB8fCB7fTtcbiAgdmFyIHBhcmVudFN2Z0VsID0gc3ZnLmVsIHx8IGdldFBhcmVudFN2Z0VsKHBhdGhFbCk7XG4gIHZhciByZWN0ID0gcGFyZW50U3ZnRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciB2aWV3Qm94QXR0ciA9IGdldEF0dHJpYnV0ZShwYXJlbnRTdmdFbCwgJ3ZpZXdCb3gnKTtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB2YXIgdmlld0JveCA9IHN2Zy52aWV3Qm94IHx8ICh2aWV3Qm94QXR0ciA/IHZpZXdCb3hBdHRyLnNwbGl0KCcgJykgOiBbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICByZXR1cm4ge1xuICAgIGVsOiBwYXJlbnRTdmdFbCxcbiAgICB2aWV3Qm94OiB2aWV3Qm94LFxuICAgIHg6IHZpZXdCb3hbMF0gLyAxLFxuICAgIHk6IHZpZXdCb3hbMV0gLyAxLFxuICAgIHc6IHdpZHRoIC8gdmlld0JveFsyXSxcbiAgICBoOiBoZWlnaHQgLyB2aWV3Qm94WzNdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGF0aChwYXRoLCBwZXJjZW50KSB7XG4gIHZhciBwYXRoRWwgPSBpcy5zdHIocGF0aCkgPyBzZWxlY3RTdHJpbmcocGF0aClbMF0gOiBwYXRoO1xuICB2YXIgcCA9IHBlcmNlbnQgfHwgMTAwO1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgZWw6IHBhdGhFbCxcbiAgICAgIHN2ZzogZ2V0UGFyZW50U3ZnKHBhdGhFbCksXG4gICAgICB0b3RhbExlbmd0aDogZ2V0VG90YWxMZW5ndGgocGF0aEVsKSAqIChwIC8gMTAwKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXRoUHJvZ3Jlc3MocGF0aCwgcHJvZ3Jlc3MpIHtcbiAgZnVuY3Rpb24gcG9pbnQob2Zmc2V0KSB7XG4gICAgaWYgKCBvZmZzZXQgPT09IHZvaWQgMCApIG9mZnNldCA9IDA7XG5cbiAgICB2YXIgbCA9IHByb2dyZXNzICsgb2Zmc2V0ID49IDEgPyBwcm9ncmVzcyArIG9mZnNldCA6IDA7XG4gICAgcmV0dXJuIHBhdGguZWwuZ2V0UG9pbnRBdExlbmd0aChsKTtcbiAgfVxuICB2YXIgc3ZnID0gZ2V0UGFyZW50U3ZnKHBhdGguZWwsIHBhdGguc3ZnKTtcbiAgdmFyIHAgPSBwb2ludCgpO1xuICB2YXIgcDAgPSBwb2ludCgtMSk7XG4gIHZhciBwMSA9IHBvaW50KCsxKTtcbiAgc3dpdGNoIChwYXRoLnByb3BlcnR5KSB7XG4gICAgY2FzZSAneCc6IHJldHVybiAocC54IC0gc3ZnLngpICogc3ZnLnc7XG4gICAgY2FzZSAneSc6IHJldHVybiAocC55IC0gc3ZnLnkpICogc3ZnLmg7XG4gICAgY2FzZSAnYW5nbGUnOiByZXR1cm4gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpICogMTgwIC8gTWF0aC5QSTtcbiAgfVxufVxuXG4vLyBEZWNvbXBvc2UgdmFsdWVcblxuZnVuY3Rpb24gZGVjb21wb3NlVmFsdWUodmFsLCB1bml0KSB7XG4gIC8vIGNvbnN0IHJneCA9IC8tP1xcZCpcXC4/XFxkKy9nOyAvLyBoYW5kbGVzIGJhc2ljIG51bWJlcnNcbiAgLy8gY29uc3Qgcmd4ID0gL1srLV0/XFxkKyg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPy9nOyAvLyBoYW5kbGVzIGV4cG9uZW50cyBub3RhdGlvblxuICB2YXIgcmd4ID0gL1srLV0/XFxkKlxcLj9cXGQrKD86XFwuXFxkKyk/KD86W2VFXVsrLV0/XFxkKyk/L2c7IC8vIGhhbmRsZXMgZXhwb25lbnRzIG5vdGF0aW9uXG4gIHZhciB2YWx1ZSA9IHZhbGlkYXRlVmFsdWUoKGlzLnB0aCh2YWwpID8gdmFsLnRvdGFsTGVuZ3RoIDogdmFsKSwgdW5pdCkgKyAnJztcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgbnVtYmVyczogdmFsdWUubWF0Y2gocmd4KSA/IHZhbHVlLm1hdGNoKHJneCkubWFwKE51bWJlcikgOiBbMF0sXG4gICAgc3RyaW5nczogKGlzLnN0cih2YWwpIHx8IHVuaXQpID8gdmFsdWUuc3BsaXQocmd4KSA6IFtdXG4gIH1cbn1cblxuLy8gQW5pbWF0YWJsZXNcblxuZnVuY3Rpb24gcGFyc2VUYXJnZXRzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldHNBcnJheSA9IHRhcmdldHMgPyAoZmxhdHRlbkFycmF5KGlzLmFycih0YXJnZXRzKSA/IHRhcmdldHMubWFwKHRvQXJyYXkpIDogdG9BcnJheSh0YXJnZXRzKSkpIDogW107XG4gIHJldHVybiBmaWx0ZXJBcnJheSh0YXJnZXRzQXJyYXksIGZ1bmN0aW9uIChpdGVtLCBwb3MsIHNlbGYpIHsgcmV0dXJuIHNlbGYuaW5kZXhPZihpdGVtKSA9PT0gcG9zOyB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZXModGFyZ2V0cykge1xuICB2YXIgcGFyc2VkID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICByZXR1cm4gcGFyc2VkLm1hcChmdW5jdGlvbiAodCwgaSkge1xuICAgIHJldHVybiB7dGFyZ2V0OiB0LCBpZDogaSwgdG90YWw6IHBhcnNlZC5sZW5ndGgsIHRyYW5zZm9ybXM6IHsgbGlzdDogZ2V0RWxlbWVudFRyYW5zZm9ybXModCkgfSB9O1xuICB9KTtcbn1cblxuLy8gUHJvcGVydGllc1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwcm9wLCB0d2VlblNldHRpbmdzKSB7XG4gIHZhciBzZXR0aW5ncyA9IGNsb25lT2JqZWN0KHR3ZWVuU2V0dGluZ3MpO1xuICAvLyBPdmVycmlkZSBkdXJhdGlvbiBpZiBlYXNpbmcgaXMgYSBzcHJpbmdcbiAgaWYgKC9ec3ByaW5nLy50ZXN0KHNldHRpbmdzLmVhc2luZykpIHsgc2V0dGluZ3MuZHVyYXRpb24gPSBzcHJpbmcoc2V0dGluZ3MuZWFzaW5nKTsgfVxuICBpZiAoaXMuYXJyKHByb3ApKSB7XG4gICAgdmFyIGwgPSBwcm9wLmxlbmd0aDtcbiAgICB2YXIgaXNGcm9tVG8gPSAobCA9PT0gMiAmJiAhaXMub2JqKHByb3BbMF0pKTtcbiAgICBpZiAoIWlzRnJvbVRvKSB7XG4gICAgICAvLyBEdXJhdGlvbiBkaXZpZGVkIGJ5IHRoZSBudW1iZXIgb2YgdHdlZW5zXG4gICAgICBpZiAoIWlzLmZuYyh0d2VlblNldHRpbmdzLmR1cmF0aW9uKSkgeyBzZXR0aW5ncy5kdXJhdGlvbiA9IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb24gLyBsOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBbZnJvbSwgdG9dIHZhbHVlcyBzaG9ydGhhbmQgdG8gYSB2YWxpZCB0d2VlbiB2YWx1ZVxuICAgICAgcHJvcCA9IHt2YWx1ZTogcHJvcH07XG4gICAgfVxuICB9XG4gIHZhciBwcm9wQXJyYXkgPSBpcy5hcnIocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICByZXR1cm4gcHJvcEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgIHZhciBvYmogPSAoaXMub2JqKHYpICYmICFpcy5wdGgodikpID8gdiA6IHt2YWx1ZTogdn07XG4gICAgLy8gRGVmYXVsdCBkZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBmaXJzdCB0d2VlblxuICAgIGlmIChpcy51bmQob2JqLmRlbGF5KSkgeyBvYmouZGVsYXkgPSAhaSA/IHR3ZWVuU2V0dGluZ3MuZGVsYXkgOiAwOyB9XG4gICAgLy8gRGVmYXVsdCBlbmREZWxheSB2YWx1ZSBzaG91bGQgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBsYXN0IHR3ZWVuXG4gICAgaWYgKGlzLnVuZChvYmouZW5kRGVsYXkpKSB7IG9iai5lbmREZWxheSA9IGkgPT09IHByb3BBcnJheS5sZW5ndGggLSAxID8gdHdlZW5TZXR0aW5ncy5lbmREZWxheSA6IDA7IH1cbiAgICByZXR1cm4gb2JqO1xuICB9KS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIG1lcmdlT2JqZWN0cyhrLCBzZXR0aW5ncyk7IH0pO1xufVxuXG5cbmZ1bmN0aW9uIGZsYXR0ZW5LZXlmcmFtZXMoa2V5ZnJhbWVzKSB7XG4gIHZhciBwcm9wZXJ0eU5hbWVzID0gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gT2JqZWN0LmtleXMoa2V5KTsgfSkpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gaXMua2V5KHApOyB9KVxuICAucmVkdWNlKGZ1bmN0aW9uIChhLGIpIHsgaWYgKGEuaW5kZXhPZihiKSA8IDApIHsgYS5wdXNoKGIpOyB9IHJldHVybiBhOyB9LCBbXSk7XG4gIHZhciBwcm9wZXJ0aWVzID0ge307XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5TmFtZXNbaV07XG4gICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBrZXlmcmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBuZXdLZXkgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4ga2V5KSB7XG4gICAgICAgIGlmIChpcy5rZXkocCkpIHtcbiAgICAgICAgICBpZiAocCA9PSBwcm9wTmFtZSkgeyBuZXdLZXkudmFsdWUgPSBrZXlbcF07IH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdLZXlbcF0gPSBrZXlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0eU5hbWVzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKHR3ZWVuU2V0dGluZ3MsIHBhcmFtcykge1xuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuICB2YXIga2V5ZnJhbWVzID0gcGFyYW1zLmtleWZyYW1lcztcbiAgaWYgKGtleWZyYW1lcykgeyBwYXJhbXMgPSBtZXJnZU9iamVjdHMoZmxhdHRlbktleWZyYW1lcyhrZXlmcmFtZXMpLCBwYXJhbXMpOyB9XG4gIGZvciAodmFyIHAgaW4gcGFyYW1zKSB7XG4gICAgaWYgKGlzLmtleShwKSkge1xuICAgICAgcHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogcCxcbiAgICAgICAgdHdlZW5zOiBub3JtYWxpemVQcm9wZXJ0eVR3ZWVucyhwYXJhbXNbcF0sIHR3ZWVuU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbi8vIFR3ZWVuc1xuXG5mdW5jdGlvbiBub3JtYWxpemVUd2VlblZhbHVlcyh0d2VlbiwgYW5pbWF0YWJsZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHR3ZWVuKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZSh0d2VlbltwXSwgYW5pbWF0YWJsZSk7XG4gICAgaWYgKGlzLmFycih2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBnZXRGdW5jdGlvblZhbHVlKHYsIGFuaW1hdGFibGUpOyB9KTtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHsgdmFsdWUgPSB2YWx1ZVswXTsgfVxuICAgIH1cbiAgICB0W3BdID0gdmFsdWU7XG4gIH1cbiAgdC5kdXJhdGlvbiA9IHBhcnNlRmxvYXQodC5kdXJhdGlvbik7XG4gIHQuZGVsYXkgPSBwYXJzZUZsb2F0KHQuZGVsYXkpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVHdlZW5zKHByb3AsIGFuaW1hdGFibGUpIHtcbiAgdmFyIHByZXZpb3VzVHdlZW47XG4gIHJldHVybiBwcm9wLnR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgdHdlZW4gPSBub3JtYWxpemVUd2VlblZhbHVlcyh0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgdHdlZW5WYWx1ZSA9IHR3ZWVuLnZhbHVlO1xuICAgIHZhciB0byA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMV0gOiB0d2VlblZhbHVlO1xuICAgIHZhciB0b1VuaXQgPSBnZXRVbml0KHRvKTtcbiAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSwgdG9Vbml0LCBhbmltYXRhYmxlKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVHdlZW4gPyBwcmV2aW91c1R3ZWVuLnRvLm9yaWdpbmFsIDogb3JpZ2luYWxWYWx1ZTtcbiAgICB2YXIgZnJvbSA9IGlzLmFycih0d2VlblZhbHVlKSA/IHR3ZWVuVmFsdWVbMF0gOiBwcmV2aW91c1ZhbHVlO1xuICAgIHZhciBmcm9tVW5pdCA9IGdldFVuaXQoZnJvbSkgfHwgZ2V0VW5pdChvcmlnaW5hbFZhbHVlKTtcbiAgICB2YXIgdW5pdCA9IHRvVW5pdCB8fCBmcm9tVW5pdDtcbiAgICBpZiAoaXMudW5kKHRvKSkgeyB0byA9IHByZXZpb3VzVmFsdWU7IH1cbiAgICB0d2Vlbi5mcm9tID0gZGVjb21wb3NlVmFsdWUoZnJvbSwgdW5pdCk7XG4gICAgdHdlZW4udG8gPSBkZWNvbXBvc2VWYWx1ZShnZXRSZWxhdGl2ZVZhbHVlKHRvLCBmcm9tKSwgdW5pdCk7XG4gICAgdHdlZW4uc3RhcnQgPSBwcmV2aW91c1R3ZWVuID8gcHJldmlvdXNUd2Vlbi5lbmQgOiAwO1xuICAgIHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0ICsgdHdlZW4uZGVsYXkgKyB0d2Vlbi5kdXJhdGlvbiArIHR3ZWVuLmVuZERlbGF5O1xuICAgIHR3ZWVuLmVhc2luZyA9IHBhcnNlRWFzaW5ncyh0d2Vlbi5lYXNpbmcsIHR3ZWVuLmR1cmF0aW9uKTtcbiAgICB0d2Vlbi5pc1BhdGggPSBpcy5wdGgodHdlZW5WYWx1ZSk7XG4gICAgdHdlZW4uaXNDb2xvciA9IGlzLmNvbCh0d2Vlbi5mcm9tLm9yaWdpbmFsKTtcbiAgICBpZiAodHdlZW4uaXNDb2xvcikgeyB0d2Vlbi5yb3VuZCA9IDE7IH1cbiAgICBwcmV2aW91c1R3ZWVuID0gdHdlZW47XG4gICAgcmV0dXJuIHR3ZWVuO1xuICB9KTtcbn1cblxuLy8gVHdlZW4gcHJvZ3Jlc3NcblxudmFyIHNldFByb2dyZXNzVmFsdWUgPSB7XG4gIGNzczogZnVuY3Rpb24gKHQsIHAsIHYpIHsgcmV0dXJuIHQuc3R5bGVbcF0gPSB2OyB9LFxuICBhdHRyaWJ1dGU6IGZ1bmN0aW9uICh0LCBwLCB2KSB7IHJldHVybiB0LnNldEF0dHJpYnV0ZShwLCB2KTsgfSxcbiAgb2JqZWN0OiBmdW5jdGlvbiAodCwgcCwgdikgeyByZXR1cm4gdFtwXSA9IHY7IH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHQsIHAsIHYsIHRyYW5zZm9ybXMsIG1hbnVhbCkge1xuICAgIHRyYW5zZm9ybXMubGlzdC5zZXQocCwgdik7XG4gICAgaWYgKHAgPT09IHRyYW5zZm9ybXMubGFzdCB8fCBtYW51YWwpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHRyYW5zZm9ybXMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcHJvcCkgeyBzdHIgKz0gcHJvcCArIFwiKFwiICsgdmFsdWUgKyBcIikgXCI7IH0pO1xuICAgICAgdC5zdHlsZS50cmFuc2Zvcm0gPSBzdHI7XG4gICAgfVxuICB9XG59O1xuXG4vLyBTZXQgVmFsdWUgaGVscGVyXG5cbmZ1bmN0aW9uIHNldFRhcmdldHNWYWx1ZSh0YXJnZXRzLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBhbmltYXRhYmxlcyA9IGdldEFuaW1hdGFibGVzKHRhcmdldHMpO1xuICBhbmltYXRhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRhYmxlKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RnVuY3Rpb25WYWx1ZShwcm9wZXJ0aWVzW3Byb3BlcnR5XSwgYW5pbWF0YWJsZSk7XG4gICAgICB2YXIgdGFyZ2V0ID0gYW5pbWF0YWJsZS50YXJnZXQ7XG4gICAgICB2YXIgdmFsdWVVbml0ID0gZ2V0VW5pdCh2YWx1ZSk7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZSA9IGdldE9yaWdpbmFsVGFyZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWVVbml0LCBhbmltYXRhYmxlKTtcbiAgICAgIHZhciB1bml0ID0gdmFsdWVVbml0IHx8IGdldFVuaXQob3JpZ2luYWxWYWx1ZSk7XG4gICAgICB2YXIgdG8gPSBnZXRSZWxhdGl2ZVZhbHVlKHZhbGlkYXRlVmFsdWUodmFsdWUsIHVuaXQpLCBvcmlnaW5hbFZhbHVlKTtcbiAgICAgIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBzZXRQcm9ncmVzc1ZhbHVlW2FuaW1UeXBlXSh0YXJnZXQsIHByb3BlcnR5LCB0bywgYW5pbWF0YWJsZS50cmFuc2Zvcm1zLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBBbmltYXRpb25zXG5cbmZ1bmN0aW9uIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKSB7XG4gIHZhciBhbmltVHlwZSA9IGdldEFuaW1hdGlvblR5cGUoYW5pbWF0YWJsZS50YXJnZXQsIHByb3AubmFtZSk7XG4gIGlmIChhbmltVHlwZSkge1xuICAgIHZhciB0d2VlbnMgPSBub3JtYWxpemVUd2VlbnMocHJvcCwgYW5pbWF0YWJsZSk7XG4gICAgdmFyIGxhc3RUd2VlbiA9IHR3ZWVuc1t0d2VlbnMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFuaW1UeXBlLFxuICAgICAgcHJvcGVydHk6IHByb3AubmFtZSxcbiAgICAgIGFuaW1hdGFibGU6IGFuaW1hdGFibGUsXG4gICAgICB0d2VlbnM6IHR3ZWVucyxcbiAgICAgIGR1cmF0aW9uOiBsYXN0VHdlZW4uZW5kLFxuICAgICAgZGVsYXk6IHR3ZWVuc1swXS5kZWxheSxcbiAgICAgIGVuZERlbGF5OiBsYXN0VHdlZW4uZW5kRGVsYXlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcykge1xuICByZXR1cm4gZmlsdGVyQXJyYXkoZmxhdHRlbkFycmF5KGFuaW1hdGFibGVzLm1hcChmdW5jdGlvbiAoYW5pbWF0YWJsZSkge1xuICAgIHJldHVybiBwcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUFuaW1hdGlvbihhbmltYXRhYmxlLCBwcm9wKTtcbiAgICB9KTtcbiAgfSkpLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gIWlzLnVuZChhKTsgfSk7XG59XG5cbi8vIENyZWF0ZSBJbnN0YW5jZVxuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZVRpbWluZ3MoYW5pbWF0aW9ucywgdHdlZW5TZXR0aW5ncykge1xuICB2YXIgYW5pbUxlbmd0aCA9IGFuaW1hdGlvbnMubGVuZ3RoO1xuICB2YXIgZ2V0VGxPZmZzZXQgPSBmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS50aW1lbGluZU9mZnNldCA/IGFuaW0udGltZWxpbmVPZmZzZXQgOiAwOyB9O1xuICB2YXIgdGltaW5ncyA9IHt9O1xuICB0aW1pbmdzLmR1cmF0aW9uID0gYW5pbUxlbmd0aCA/IE1hdGgubWF4LmFwcGx5KE1hdGgsIGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmltKSB7IHJldHVybiBnZXRUbE9mZnNldChhbmltKSArIGFuaW0uZHVyYXRpb247IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZHVyYXRpb247XG4gIHRpbWluZ3MuZGVsYXkgPSBhbmltTGVuZ3RoID8gTWF0aC5taW4uYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kZWxheTsgfSkpIDogdHdlZW5TZXR0aW5ncy5kZWxheTtcbiAgdGltaW5ncy5lbmREZWxheSA9IGFuaW1MZW5ndGggPyB0aW1pbmdzLmR1cmF0aW9uIC0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaW0pIHsgcmV0dXJuIGdldFRsT2Zmc2V0KGFuaW0pICsgYW5pbS5kdXJhdGlvbiAtIGFuaW0uZW5kRGVsYXk7IH0pKSA6IHR3ZWVuU2V0dGluZ3MuZW5kRGVsYXk7XG4gIHJldHVybiB0aW1pbmdzO1xufVxuXG52YXIgaW5zdGFuY2VJRCA9IDA7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcykge1xuICB2YXIgaW5zdGFuY2VTZXR0aW5ncyA9IHJlcGxhY2VPYmplY3RQcm9wcyhkZWZhdWx0SW5zdGFuY2VTZXR0aW5ncywgcGFyYW1zKTtcbiAgdmFyIHR3ZWVuU2V0dGluZ3MgPSByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gZ2V0UHJvcGVydGllcyh0d2VlblNldHRpbmdzLCBwYXJhbXMpO1xuICB2YXIgYW5pbWF0YWJsZXMgPSBnZXRBbmltYXRhYmxlcyhwYXJhbXMudGFyZ2V0cyk7XG4gIHZhciBhbmltYXRpb25zID0gZ2V0QW5pbWF0aW9ucyhhbmltYXRhYmxlcywgcHJvcGVydGllcyk7XG4gIHZhciB0aW1pbmdzID0gZ2V0SW5zdGFuY2VUaW1pbmdzKGFuaW1hdGlvbnMsIHR3ZWVuU2V0dGluZ3MpO1xuICB2YXIgaWQgPSBpbnN0YW5jZUlEO1xuICBpbnN0YW5jZUlEKys7XG4gIHJldHVybiBtZXJnZU9iamVjdHMoaW5zdGFuY2VTZXR0aW5ncywge1xuICAgIGlkOiBpZCxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgYW5pbWF0YWJsZXM6IGFuaW1hdGFibGVzLFxuICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sXG4gICAgZGVsYXk6IHRpbWluZ3MuZGVsYXksXG4gICAgZW5kRGVsYXk6IHRpbWluZ3MuZW5kRGVsYXlcbiAgfSk7XG59XG5cbi8vIENvcmVcblxudmFyIGFjdGl2ZUluc3RhbmNlcyA9IFtdO1xudmFyIHBhdXNlZEluc3RhbmNlcyA9IFtdO1xudmFyIHJhZjtcblxudmFyIGVuZ2luZSA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHBsYXkoKSB7IFxuICAgIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgfVxuICBmdW5jdGlvbiBzdGVwKHQpIHtcbiAgICB2YXIgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDtcbiAgICBpZiAoYWN0aXZlSW5zdGFuY2VzTGVuZ3RoKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGFjdGl2ZUluc3RhbmNlc0xlbmd0aCkge1xuICAgICAgICB2YXIgYWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZXNbaV07XG4gICAgICAgIGlmICghYWN0aXZlSW5zdGFuY2UucGF1c2VkKSB7XG4gICAgICAgICAgYWN0aXZlSW5zdGFuY2UudGljayh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2VJbmRleCA9IGFjdGl2ZUluc3RhbmNlcy5pbmRleE9mKGFjdGl2ZUluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2VJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZXMuc3BsaWNlKGluc3RhbmNlSW5kZXgsIDEpO1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VzTGVuZ3RoID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWYgPSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGxheTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICBhY3RpdmVJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zKSB7IHJldHVybiBpbnMucGF1c2UoKTsgfSk7XG4gICAgcGF1c2VkSW5zdGFuY2VzID0gYWN0aXZlSW5zdGFuY2VzLnNsaWNlKDApO1xuICAgIGFuaW1lLnJ1bm5pbmcgPSBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICBwYXVzZWRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zKSB7IHJldHVybiBpbnMucGxheSgpOyB9KTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG59XG5cbi8vIFB1YmxpYyBJbnN0YW5jZVxuXG5mdW5jdGlvbiBhbmltZShwYXJhbXMpIHtcbiAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IDAsIGxhc3RUaW1lID0gMCwgbm93ID0gMDtcbiAgdmFyIGNoaWxkcmVuLCBjaGlsZHJlbkxlbmd0aCA9IDA7XG4gIHZhciByZXNvbHZlID0gbnVsbDtcblxuICBmdW5jdGlvbiBtYWtlUHJvbWlzZShpbnN0YW5jZSkge1xuICAgIHZhciBwcm9taXNlID0gd2luZG93LlByb21pc2UgJiYgbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7IHJldHVybiByZXNvbHZlID0gX3Jlc29sdmU7IH0pO1xuICAgIGluc3RhbmNlLmZpbmlzaGVkID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGNyZWF0ZU5ld0luc3RhbmNlKHBhcmFtcyk7XG4gIHZhciBwcm9taXNlID0gbWFrZVByb21pc2UoaW5zdGFuY2UpO1xuXG4gIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbmNlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSBpbnN0YW5jZS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2FsdGVybmF0ZScpIHtcbiAgICAgIGluc3RhbmNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiAhPT0gJ25vcm1hbCcgPyAnbm9ybWFsJyA6ICdyZXZlcnNlJztcbiAgICB9XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSAhaW5zdGFuY2UucmV2ZXJzZWQ7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnJldmVyc2VkID0gaW5zdGFuY2UucmV2ZXJzZWQ7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0VGltZSh0aW1lKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnJldmVyc2VkID8gaW5zdGFuY2UuZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGltZSgpIHtcbiAgICBzdGFydFRpbWUgPSAwO1xuICAgIGxhc3RUaW1lID0gYWRqdXN0VGltZShpbnN0YW5jZS5jdXJyZW50VGltZSkgKiAoMSAvIGFuaW1lLnNwZWVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlZWtDaGlsZCh0aW1lLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCkgeyBjaGlsZC5zZWVrKHRpbWUgLSBjaGlsZC50aW1lbGluZU9mZnNldCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNJbnN0YW5jZUNoaWxkcmVuKHRpbWUpIHtcbiAgICBpZiAoIWluc3RhbmNlLnJldmVyc2VQbGF5YmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7IHNlZWtDaGlsZCh0aW1lLCBjaGlsZHJlbltpXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hpbGRyZW5MZW5ndGg7IGkkMS0tOykgeyBzZWVrQ2hpbGQodGltZSwgY2hpbGRyZW5baSQxXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zVGltZSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGFuaW1hdGlvbnNMZW5ndGggPSBhbmltYXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGFuaW1hdGlvbnNMZW5ndGgpIHtcbiAgICAgIHZhciBhbmltID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgIHZhciBhbmltYXRhYmxlID0gYW5pbS5hbmltYXRhYmxlO1xuICAgICAgdmFyIHR3ZWVucyA9IGFuaW0udHdlZW5zO1xuICAgICAgdmFyIHR3ZWVuTGVuZ3RoID0gdHdlZW5zLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbdHdlZW5MZW5ndGhdO1xuICAgICAgLy8gT25seSBjaGVjayBmb3Iga2V5ZnJhbWVzIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgdHdlZW5cbiAgICAgIGlmICh0d2Vlbkxlbmd0aCkgeyB0d2VlbiA9IGZpbHRlckFycmF5KHR3ZWVucywgZnVuY3Rpb24gKHQpIHsgcmV0dXJuIChpbnNUaW1lIDwgdC5lbmQpOyB9KVswXSB8fCB0d2VlbjsgfVxuICAgICAgdmFyIGVsYXBzZWQgPSBtaW5NYXgoaW5zVGltZSAtIHR3ZWVuLnN0YXJ0IC0gdHdlZW4uZGVsYXksIDAsIHR3ZWVuLmR1cmF0aW9uKSAvIHR3ZWVuLmR1cmF0aW9uO1xuICAgICAgdmFyIGVhc2VkID0gaXNOYU4oZWxhcHNlZCkgPyAxIDogdHdlZW4uZWFzaW5nKGVsYXBzZWQpO1xuICAgICAgdmFyIHN0cmluZ3MgPSB0d2Vlbi50by5zdHJpbmdzO1xuICAgICAgdmFyIHJvdW5kID0gdHdlZW4ucm91bmQ7XG4gICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgdmFyIHRvTnVtYmVyc0xlbmd0aCA9IHR3ZWVuLnRvLm51bWJlcnMubGVuZ3RoO1xuICAgICAgdmFyIHByb2dyZXNzID0gKHZvaWQgMCk7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHRvTnVtYmVyc0xlbmd0aDsgbisrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgdG9OdW1iZXIgPSB0d2Vlbi50by5udW1iZXJzW25dO1xuICAgICAgICB2YXIgZnJvbU51bWJlciA9IHR3ZWVuLmZyb20ubnVtYmVyc1tuXSB8fCAwO1xuICAgICAgICBpZiAoIXR3ZWVuLmlzUGF0aCkge1xuICAgICAgICAgIHZhbHVlID0gZnJvbU51bWJlciArIChlYXNlZCAqICh0b051bWJlciAtIGZyb21OdW1iZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldFBhdGhQcm9ncmVzcyh0d2Vlbi52YWx1ZSwgZWFzZWQgKiB0b051bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdW5kKSB7XG4gICAgICAgICAgaWYgKCEodHdlZW4uaXNDb2xvciAmJiBuID4gMikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAqIHJvdW5kKSAvIHJvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gTWFudWFsIEFycmF5LnJlZHVjZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlc1xuICAgICAgdmFyIHN0cmluZ3NMZW5ndGggPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgIGlmICghc3RyaW5nc0xlbmd0aCkge1xuICAgICAgICBwcm9ncmVzcyA9IG51bWJlcnNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmVzcyA9IHN0cmluZ3NbMF07XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc3RyaW5nc0xlbmd0aDsgcysrKSB7XG4gICAgICAgICAgdmFyIGEgPSBzdHJpbmdzW3NdO1xuICAgICAgICAgIHZhciBiID0gc3RyaW5nc1tzICsgMV07XG4gICAgICAgICAgdmFyIG4kMSA9IG51bWJlcnNbc107XG4gICAgICAgICAgaWYgKCFpc05hTihuJDEpKSB7XG4gICAgICAgICAgICBpZiAoIWIpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgJyAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MgKz0gbiQxICsgYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNldFByb2dyZXNzVmFsdWVbYW5pbS50eXBlXShhbmltYXRhYmxlLnRhcmdldCwgYW5pbS5wcm9wZXJ0eSwgcHJvZ3Jlc3MsIGFuaW1hdGFibGUudHJhbnNmb3Jtcyk7XG4gICAgICBhbmltLmN1cnJlbnRWYWx1ZSA9IHByb2dyZXNzO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbGxiYWNrKGNiKSB7XG4gICAgaWYgKGluc3RhbmNlW2NiXSAmJiAhaW5zdGFuY2UucGFzc1Rocm91Z2gpIHsgaW5zdGFuY2VbY2JdKGluc3RhbmNlKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY291bnRJdGVyYXRpb24oKSB7XG4gICAgaWYgKGluc3RhbmNlLnJlbWFpbmluZyAmJiBpbnN0YW5jZS5yZW1haW5pbmcgIT09IHRydWUpIHtcbiAgICAgIGluc3RhbmNlLnJlbWFpbmluZy0tO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEluc3RhbmNlUHJvZ3Jlc3MoZW5naW5lVGltZSkge1xuICAgIHZhciBpbnNEdXJhdGlvbiA9IGluc3RhbmNlLmR1cmF0aW9uO1xuICAgIHZhciBpbnNEZWxheSA9IGluc3RhbmNlLmRlbGF5O1xuICAgIHZhciBpbnNFbmREZWxheSA9IGluc0R1cmF0aW9uIC0gaW5zdGFuY2UuZW5kRGVsYXk7XG4gICAgdmFyIGluc1RpbWUgPSBhZGp1c3RUaW1lKGVuZ2luZVRpbWUpO1xuICAgIGluc3RhbmNlLnByb2dyZXNzID0gbWluTWF4KChpbnNUaW1lIC8gaW5zRHVyYXRpb24pICogMTAwLCAwLCAxMDApO1xuICAgIGluc3RhbmNlLnJldmVyc2VQbGF5YmFjayA9IGluc1RpbWUgPCBpbnN0YW5jZS5jdXJyZW50VGltZTtcbiAgICBpZiAoY2hpbGRyZW4pIHsgc3luY0luc3RhbmNlQ2hpbGRyZW4oaW5zVGltZSk7IH1cbiAgICBpZiAoIWluc3RhbmNlLmJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UuYmVnYW4gPSB0cnVlO1xuICAgICAgc2V0Q2FsbGJhY2soJ2JlZ2luJyk7XG4gICAgfVxuICAgIGlmICghaW5zdGFuY2UubG9vcEJlZ2FuICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lID4gMCkge1xuICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gdHJ1ZTtcbiAgICAgIHNldENhbGxiYWNrKCdsb29wQmVnaW4nKTtcbiAgICB9XG4gICAgaWYgKGluc1RpbWUgPD0gaW5zRGVsYXkgJiYgaW5zdGFuY2UuY3VycmVudFRpbWUgIT09IDApIHtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcygwKTtcbiAgICB9XG4gICAgaWYgKChpbnNUaW1lID49IGluc0VuZERlbGF5ICYmIGluc3RhbmNlLmN1cnJlbnRUaW1lICE9PSBpbnNEdXJhdGlvbikgfHwgIWluc0R1cmF0aW9uKSB7XG4gICAgICBzZXRBbmltYXRpb25zUHJvZ3Jlc3MoaW5zRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoaW5zVGltZSA+IGluc0RlbGF5ICYmIGluc1RpbWUgPCBpbnNFbmREZWxheSkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5jaGFuZ2VCZWdhbikge1xuICAgICAgICBpbnN0YW5jZS5jaGFuZ2VCZWdhbiA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICBzZXRDYWxsYmFjaygnY2hhbmdlQmVnaW4nKTtcbiAgICAgIH1cbiAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2UnKTtcbiAgICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnNUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluc3RhbmNlLmNoYW5nZUJlZ2FuKSB7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgICAgIHNldENhbGxiYWNrKCdjaGFuZ2VDb21wbGV0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS5jdXJyZW50VGltZSA9IG1pbk1heChpbnNUaW1lLCAwLCBpbnNEdXJhdGlvbik7XG4gICAgaWYgKGluc3RhbmNlLmJlZ2FuKSB7IHNldENhbGxiYWNrKCd1cGRhdGUnKTsgfVxuICAgIGlmIChlbmdpbmVUaW1lID49IGluc0R1cmF0aW9uKSB7XG4gICAgICBsYXN0VGltZSA9IDA7XG4gICAgICBjb3VudEl0ZXJhdGlvbigpO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZW1haW5pbmcpIHtcbiAgICAgICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICBzZXRDYWxsYmFjaygnY29tcGxldGUnKTtcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLnBhc3NUaHJvdWdoICYmICdQcm9taXNlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHByb21pc2UgPSBtYWtlUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFRpbWUgPSBub3c7XG4gICAgICAgIHNldENhbGxiYWNrKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgaW5zdGFuY2UubG9vcEJlZ2FuID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnN0YW5jZS5kaXJlY3Rpb24gPT09ICdhbHRlcm5hdGUnKSB7XG4gICAgICAgICAgdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGluc3RhbmNlLmRpcmVjdGlvbjtcbiAgICBpbnN0YW5jZS5wYXNzVGhyb3VnaCA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmN1cnJlbnRUaW1lID0gMDtcbiAgICBpbnN0YW5jZS5wcm9ncmVzcyA9IDA7XG4gICAgaW5zdGFuY2UucGF1c2VkID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5iZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmxvb3BCZWdhbiA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmNoYW5nZUJlZ2FuID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UuY2hhbmdlQ29tcGxldGVkID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZVBsYXliYWNrID0gZmFsc2U7XG4gICAgaW5zdGFuY2UucmV2ZXJzZWQgPSBkaXJlY3Rpb24gPT09ICdyZXZlcnNlJztcbiAgICBpbnN0YW5jZS5yZW1haW5pbmcgPSBpbnN0YW5jZS5sb29wO1xuICAgIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcmVuTGVuZ3RoOyBpLS07KSB7IGluc3RhbmNlLmNoaWxkcmVuW2ldLnJlc2V0KCk7IH1cbiAgICBpZiAoaW5zdGFuY2UucmV2ZXJzZWQgJiYgaW5zdGFuY2UubG9vcCAhPT0gdHJ1ZSB8fCAoZGlyZWN0aW9uID09PSAnYWx0ZXJuYXRlJyAmJiBpbnN0YW5jZS5sb29wID09PSAxKSkgeyBpbnN0YW5jZS5yZW1haW5pbmcrKzsgfVxuICAgIHNldEFuaW1hdGlvbnNQcm9ncmVzcyhpbnN0YW5jZS5yZXZlcnNlZCA/IGluc3RhbmNlLmR1cmF0aW9uIDogMCk7XG4gIH07XG5cbiAgLy8gU2V0IFZhbHVlIGhlbHBlclxuXG4gIGluc3RhbmNlLnNldCA9IGZ1bmN0aW9uKHRhcmdldHMsIHByb3BlcnRpZXMpIHtcbiAgICBzZXRUYXJnZXRzVmFsdWUodGFyZ2V0cywgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIGluc3RhbmNlLnRpY2sgPSBmdW5jdGlvbih0KSB7XG4gICAgbm93ID0gdDtcbiAgICBpZiAoIXN0YXJ0VGltZSkgeyBzdGFydFRpbWUgPSBub3c7IH1cbiAgICBzZXRJbnN0YW5jZVByb2dyZXNzKChub3cgKyAobGFzdFRpbWUgLSBzdGFydFRpbWUpKSAqIGFuaW1lLnNwZWVkKTtcbiAgfTtcblxuICBpbnN0YW5jZS5zZWVrID0gZnVuY3Rpb24odGltZSkge1xuICAgIHNldEluc3RhbmNlUHJvZ3Jlc3MoYWRqdXN0VGltZSh0aW1lKSk7XG4gIH07XG5cbiAgaW5zdGFuY2UucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpbnN0YW5jZS5wYXVzZWQgPSB0cnVlO1xuICAgIHJlc2V0VGltZSgpO1xuICB9O1xuXG4gIGluc3RhbmNlLnBsYXkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWluc3RhbmNlLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICBpZiAoaW5zdGFuY2UuY29tcGxldGVkKSB7IGluc3RhbmNlLnJlc2V0KCk7IH1cbiAgICBpbnN0YW5jZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhY3RpdmVJbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgcmVzZXRUaW1lKCk7XG4gICAgaWYgKCFyYWYpIHsgZW5naW5lKCk7IH1cbiAgfTtcblxuICBpbnN0YW5jZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdG9nZ2xlSW5zdGFuY2VEaXJlY3Rpb24oKTtcbiAgICByZXNldFRpbWUoKTtcbiAgfTtcblxuICBpbnN0YW5jZS5yZXN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5zdGFuY2UucmVzZXQoKTtcbiAgICBpbnN0YW5jZS5wbGF5KCk7XG4gIH07XG5cbiAgaW5zdGFuY2UucmVzZXQoKTtcblxuICBpZiAoaW5zdGFuY2UuYXV0b3BsYXkpIHsgaW5zdGFuY2UucGxheSgpOyB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xuXG59XG5cbi8vIFJlbW92ZSB0YXJnZXRzIGZyb20gYW5pbWF0aW9uXG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGFuaW1hdGlvbnMpIHtcbiAgZm9yICh2YXIgYSA9IGFuaW1hdGlvbnMubGVuZ3RoOyBhLS07KSB7XG4gICAgaWYgKGFycmF5Q29udGFpbnModGFyZ2V0c0FycmF5LCBhbmltYXRpb25zW2FdLmFuaW1hdGFibGUudGFyZ2V0KSkge1xuICAgICAgYW5pbWF0aW9ucy5zcGxpY2UoYSwgMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRhcmdldHModGFyZ2V0cykge1xuICB2YXIgdGFyZ2V0c0FycmF5ID0gcGFyc2VUYXJnZXRzKHRhcmdldHMpO1xuICBmb3IgKHZhciBpID0gYWN0aXZlSW5zdGFuY2VzLmxlbmd0aDsgaS0tOykge1xuICAgIHZhciBpbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlc1tpXTtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IGluc3RhbmNlLmFuaW1hdGlvbnM7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW47XG4gICAgcmVtb3ZlVGFyZ2V0c0Zyb21BbmltYXRpb25zKHRhcmdldHNBcnJheSwgYW5pbWF0aW9ucyk7XG4gICAgZm9yICh2YXIgYyA9IGNoaWxkcmVuLmxlbmd0aDsgYy0tOykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bY107XG4gICAgICB2YXIgY2hpbGRBbmltYXRpb25zID0gY2hpbGQuYW5pbWF0aW9ucztcbiAgICAgIHJlbW92ZVRhcmdldHNGcm9tQW5pbWF0aW9ucyh0YXJnZXRzQXJyYXksIGNoaWxkQW5pbWF0aW9ucyk7XG4gICAgICBpZiAoIWNoaWxkQW5pbWF0aW9ucy5sZW5ndGggJiYgIWNoaWxkLmNoaWxkcmVuLmxlbmd0aCkgeyBjaGlsZHJlbi5zcGxpY2UoYywgMSk7IH1cbiAgICB9XG4gICAgaWYgKCFhbmltYXRpb25zLmxlbmd0aCAmJiAhY2hpbGRyZW4ubGVuZ3RoKSB7IGluc3RhbmNlLnBhdXNlKCk7IH1cbiAgfVxufVxuXG4vLyBTdGFnZ2VyIGhlbHBlcnNcblxuZnVuY3Rpb24gc3RhZ2dlcih2YWwsIHBhcmFtcykge1xuICBpZiAoIHBhcmFtcyA9PT0gdm9pZCAwICkgcGFyYW1zID0ge307XG5cbiAgdmFyIGRpcmVjdGlvbiA9IHBhcmFtcy5kaXJlY3Rpb24gfHwgJ25vcm1hbCc7XG4gIHZhciBlYXNpbmcgPSBwYXJhbXMuZWFzaW5nID8gcGFyc2VFYXNpbmdzKHBhcmFtcy5lYXNpbmcpIDogbnVsbDtcbiAgdmFyIGdyaWQgPSBwYXJhbXMuZ3JpZDtcbiAgdmFyIGF4aXMgPSBwYXJhbXMuYXhpcztcbiAgdmFyIGZyb21JbmRleCA9IHBhcmFtcy5mcm9tIHx8IDA7XG4gIHZhciBmcm9tRmlyc3QgPSBmcm9tSW5kZXggPT09ICdmaXJzdCc7XG4gIHZhciBmcm9tQ2VudGVyID0gZnJvbUluZGV4ID09PSAnY2VudGVyJztcbiAgdmFyIGZyb21MYXN0ID0gZnJvbUluZGV4ID09PSAnbGFzdCc7XG4gIHZhciBpc1JhbmdlID0gaXMuYXJyKHZhbCk7XG4gIHZhciB2YWwxID0gaXNSYW5nZSA/IHBhcnNlRmxvYXQodmFsWzBdKSA6IHBhcnNlRmxvYXQodmFsKTtcbiAgdmFyIHZhbDIgPSBpc1JhbmdlID8gcGFyc2VGbG9hdCh2YWxbMV0pIDogMDtcbiAgdmFyIHVuaXQgPSBnZXRVbml0KGlzUmFuZ2UgPyB2YWxbMV0gOiB2YWwpIHx8IDA7XG4gIHZhciBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwICsgKGlzUmFuZ2UgPyB2YWwxIDogMCk7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIG1heFZhbHVlID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbCwgaSwgdCkge1xuICAgIGlmIChmcm9tRmlyc3QpIHsgZnJvbUluZGV4ID0gMDsgfVxuICAgIGlmIChmcm9tQ2VudGVyKSB7IGZyb21JbmRleCA9ICh0IC0gMSkgLyAyOyB9XG4gICAgaWYgKGZyb21MYXN0KSB7IGZyb21JbmRleCA9IHQgLSAxOyB9XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoIWdyaWQpIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaChNYXRoLmFicyhmcm9tSW5kZXggLSBpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmcm9tWCA9ICFmcm9tQ2VudGVyID8gZnJvbUluZGV4JWdyaWRbMF0gOiAoZ3JpZFswXS0xKS8yO1xuICAgICAgICAgIHZhciBmcm9tWSA9ICFmcm9tQ2VudGVyID8gTWF0aC5mbG9vcihmcm9tSW5kZXgvZ3JpZFswXSkgOiAoZ3JpZFsxXS0xKS8yO1xuICAgICAgICAgIHZhciB0b1ggPSBpbmRleCVncmlkWzBdO1xuICAgICAgICAgIHZhciB0b1kgPSBNYXRoLmZsb29yKGluZGV4L2dyaWRbMF0pO1xuICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBmcm9tWCAtIHRvWDtcbiAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gZnJvbVkgLSB0b1k7XG4gICAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5zcXJ0KGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWSk7XG4gICAgICAgICAgaWYgKGF4aXMgPT09ICd4JykgeyB2YWx1ZSA9IC1kaXN0YW5jZVg7IH1cbiAgICAgICAgICBpZiAoYXhpcyA9PT0gJ3knKSB7IHZhbHVlID0gLWRpc3RhbmNlWTsgfVxuICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoZWFzaW5nKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gZWFzaW5nKHZhbCAvIG1heFZhbHVlKSAqIG1heFZhbHVlOyB9KTsgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKSB7IHZhbHVlcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gYXhpcyA/ICh2YWwgPCAwKSA/IHZhbCAqIC0xIDogLXZhbCA6IE1hdGguYWJzKG1heFZhbHVlIC0gdmFsKTsgfSk7IH1cbiAgICB9XG4gICAgdmFyIHNwYWNpbmcgPSBpc1JhbmdlID8gKHZhbDIgLSB2YWwxKSAvIG1heFZhbHVlIDogdmFsMTtcbiAgICByZXR1cm4gc3RhcnQgKyAoc3BhY2luZyAqIChNYXRoLnJvdW5kKHZhbHVlc1tpXSAqIDEwMCkgLyAxMDApKSArIHVuaXQ7XG4gIH1cbn1cblxuLy8gVGltZWxpbmVcblxuZnVuY3Rpb24gdGltZWxpbmUocGFyYW1zKSB7XG4gIGlmICggcGFyYW1zID09PSB2b2lkIDAgKSBwYXJhbXMgPSB7fTtcblxuICB2YXIgdGwgPSBhbmltZShwYXJhbXMpO1xuICB0bC5kdXJhdGlvbiA9IDA7XG4gIHRsLmFkZCA9IGZ1bmN0aW9uKGluc3RhbmNlUGFyYW1zLCB0aW1lbGluZU9mZnNldCkge1xuICAgIHZhciB0bEluZGV4ID0gYWN0aXZlSW5zdGFuY2VzLmluZGV4T2YodGwpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRsLmNoaWxkcmVuO1xuICAgIGlmICh0bEluZGV4ID4gLTEpIHsgYWN0aXZlSW5zdGFuY2VzLnNwbGljZSh0bEluZGV4LCAxKTsgfVxuICAgIGZ1bmN0aW9uIHBhc3NUaHJvdWdoKGlucykgeyBpbnMucGFzc1Rocm91Z2ggPSB0cnVlOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykgeyBwYXNzVGhyb3VnaChjaGlsZHJlbltpXSk7IH1cbiAgICB2YXIgaW5zUGFyYW1zID0gbWVyZ2VPYmplY3RzKGluc3RhbmNlUGFyYW1zLCByZXBsYWNlT2JqZWN0UHJvcHMoZGVmYXVsdFR3ZWVuU2V0dGluZ3MsIHBhcmFtcykpO1xuICAgIGluc1BhcmFtcy50YXJnZXRzID0gaW5zUGFyYW1zLnRhcmdldHMgfHwgcGFyYW1zLnRhcmdldHM7XG4gICAgdmFyIHRsRHVyYXRpb24gPSB0bC5kdXJhdGlvbjtcbiAgICBpbnNQYXJhbXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBpbnNQYXJhbXMuZGlyZWN0aW9uID0gdGwuZGlyZWN0aW9uO1xuICAgIGluc1BhcmFtcy50aW1lbGluZU9mZnNldCA9IGlzLnVuZCh0aW1lbGluZU9mZnNldCkgPyB0bER1cmF0aW9uIDogZ2V0UmVsYXRpdmVWYWx1ZSh0aW1lbGluZU9mZnNldCwgdGxEdXJhdGlvbik7XG4gICAgcGFzc1Rocm91Z2godGwpO1xuICAgIHRsLnNlZWsoaW5zUGFyYW1zLnRpbWVsaW5lT2Zmc2V0KTtcbiAgICB2YXIgaW5zID0gYW5pbWUoaW5zUGFyYW1zKTtcbiAgICBwYXNzVGhyb3VnaChpbnMpO1xuICAgIGNoaWxkcmVuLnB1c2goaW5zKTtcbiAgICB2YXIgdGltaW5ncyA9IGdldEluc3RhbmNlVGltaW5ncyhjaGlsZHJlbiwgcGFyYW1zKTtcbiAgICB0bC5kZWxheSA9IHRpbWluZ3MuZGVsYXk7XG4gICAgdGwuZW5kRGVsYXkgPSB0aW1pbmdzLmVuZERlbGF5O1xuICAgIHRsLmR1cmF0aW9uID0gdGltaW5ncy5kdXJhdGlvbjtcbiAgICB0bC5zZWVrKDApO1xuICAgIHRsLnJlc2V0KCk7XG4gICAgaWYgKHRsLmF1dG9wbGF5KSB7IHRsLnBsYXkoKTsgfVxuICAgIHJldHVybiB0bDtcbiAgfTtcbiAgcmV0dXJuIHRsO1xufVxuXG5hbmltZS52ZXJzaW9uID0gJzMuMS4wJztcbmFuaW1lLnNwZWVkID0gMTtcbmFuaW1lLnJ1bm5pbmcgPSBhY3RpdmVJbnN0YW5jZXM7XG5hbmltZS5yZW1vdmUgPSByZW1vdmVUYXJnZXRzO1xuYW5pbWUuZ2V0ID0gZ2V0T3JpZ2luYWxUYXJnZXRWYWx1ZTtcbmFuaW1lLnNldCA9IHNldFRhcmdldHNWYWx1ZTtcbmFuaW1lLmNvbnZlcnRQeCA9IGNvbnZlcnRQeFRvVW5pdDtcbmFuaW1lLnBhdGggPSBnZXRQYXRoO1xuYW5pbWUuc2V0RGFzaG9mZnNldCA9IHNldERhc2hvZmZzZXQ7XG5hbmltZS5zdGFnZ2VyID0gc3RhZ2dlcjtcbmFuaW1lLnRpbWVsaW5lID0gdGltZWxpbmU7XG5hbmltZS5lYXNpbmcgPSBwYXJzZUVhc2luZ3M7XG5hbmltZS5wZW5uZXIgPSBwZW5uZXI7XG5hbmltZS5yYW5kb20gPSBmdW5jdGlvbiAobWluLCBtYXgpIHsgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47IH07XG5cbmV4cG9ydCBkZWZhdWx0IGFuaW1lO1xuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qKlxyXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxyXG4gKi9cclxuXHJcbnZhciBCbG9iQnVpbGRlciA9IHR5cGVvZiBCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iQnVpbGRlciA6XHJcbiAgdHlwZW9mIFdlYktpdEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IFdlYktpdEJsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTVNCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNU0Jsb2JCdWlsZGVyIDpcclxuICB0eXBlb2YgTW96QmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTW96QmxvYkJ1aWxkZXIgOiBcclxuICBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxyXG4gKi9cclxuXHJcbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHRyeSB7XHJcbiAgICB2YXIgYSA9IG5ldyBCbG9iKFsnaGknXSk7XHJcbiAgICByZXR1cm4gYS5zaXplID09PSAyO1xyXG4gIH0gY2F0Y2goZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIHN1cHBvcnRzIEFycmF5QnVmZmVyVmlld3NcclxuICogRmFpbHMgaW4gU2FmYXJpIDYsIHNvIHdlIG5lZWQgdG8gbWFwIHRvIEFycmF5QnVmZmVycyB0aGVyZS5cclxuICovXHJcblxyXG52YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBiID0gbmV3IEJsb2IoW25ldyBVaW50OEFycmF5KFsxLDJdKV0pO1xyXG4gICAgcmV0dXJuIGIuc2l6ZSA9PT0gMjtcclxuICB9IGNhdGNoKGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXHJcbiAqL1xyXG5cclxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXHJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xyXG4gKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3RcclxuICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cclxuICovXHJcblxyXG5mdW5jdGlvbiBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSkge1xyXG4gIHJldHVybiBhcnkubWFwKGZ1bmN0aW9uKGNodW5rKSB7XHJcbiAgICBpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZiA9IGNodW5rLmJ1ZmZlcjtcclxuXHJcbiAgICAgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxyXG4gICAgICAvLyBpbmNsdWRlIHRoZSBzdWJhcnJheSByZWdpb24gZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXJcclxuICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggIT09IGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgVWludDhBcnJheShjaHVuay5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBidWYgPSBjb3B5LmJ1ZmZlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2h1bms7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xyXG4gIG1hcEFycmF5QnVmZmVyVmlld3MoYXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcclxuICAgIGJiLmFwcGVuZChwYXJ0KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQmxvYkNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQmxvYihtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSksIG9wdGlvbnMgfHwge30pO1xyXG59O1xyXG5cclxuaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJykge1xyXG4gIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IucHJvdG90eXBlID0gQmxvYi5wcm90b3R5cGU7XHJcbiAgQmxvYkNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IEJsb2IucHJvdG90eXBlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IEJsb2IgOiBCbG9iQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG59KSgpO1xyXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nKC4uLmFyZ3MpIHtcblx0Ly8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcblx0Ly8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0cmV0dXJuIHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJlxuXHRcdGNvbnNvbGUubG9nICYmXG5cdFx0Y29uc29sZS5sb2coLi4uYXJncyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0Ly8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5cdFx0Ly8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuXG5cdFx0Ly8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcblx0XHRcdGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMvaW5kZXgnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfSBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGFyc2V1cmkob3B0cy5ob3N0KS5ob3N0O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmVcbiAgICA6ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbi5wb3J0XG4gICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgIDogKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlICE9PSBvcHRzLndpdGhDcmVkZW50aWFscztcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy50cmFuc3BvcnRPcHRpb25zID0gb3B0cy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuICB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlID0gZmFsc2UgIT09IG9wdHMucGVyTWVzc2FnZURlZmxhdGUgPyAob3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSB8fCB7fSkgOiBmYWxzZTtcblxuICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJiBudWxsID09IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQgPSAxMDI0O1xuICB9XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gISFvcHRzLmZvcmNlTm9kZTtcblxuICAvLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJyk7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBvciBSZWFjdE5hdGl2ZSBjbGllbnRcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmlzUmVhY3ROYXRpdmUpIHtcbiAgICBpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMubG9jYWxBZGRyZXNzKSB7XG4gICAgICB0aGlzLmxvY2FsQWRkcmVzcyA9IG9wdHMubG9jYWxBZGRyZXNzO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgdGhpcy5pZCA9IG51bGw7XG4gIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIC8vIHNldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL2luZGV4Jyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gcGVyLXRyYW5zcG9ydCBvcHRpb25zXG4gIHZhciBvcHRpb25zID0gdGhpcy50cmFuc3BvcnRPcHRpb25zW25hbWVdIHx8IHt9O1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgYWdlbnQ6IG9wdGlvbnMuYWdlbnQgfHwgdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogb3B0aW9ucy5ob3N0bmFtZSB8fCB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IG9wdGlvbnMucG9ydCB8fCB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiBvcHRpb25zLnNlY3VyZSB8fCB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoLFxuICAgIGZvcmNlSlNPTlA6IG9wdGlvbnMuZm9yY2VKU09OUCB8fCB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IG9wdGlvbnMuanNvbnAgfHwgdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogb3B0aW9ucy5mb3JjZUJhc2U2NCB8fCB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IG9wdGlvbnMuZW5hYmxlc1hEUiB8fCB0aGlzLmVuYWJsZXNYRFIsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCB0aGlzLndpdGhDcmVkZW50aWFscyxcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogb3B0aW9ucy50aW1lc3RhbXBSZXF1ZXN0cyB8fCB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiBvcHRpb25zLnRpbWVzdGFtcFBhcmFtIHx8IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogb3B0aW9ucy5wb2xpY3lQb3J0IHx8IHRoaXMucG9saWN5UG9ydCxcbiAgICBwZng6IG9wdGlvbnMucGZ4IHx8IHRoaXMucGZ4LFxuICAgIGtleTogb3B0aW9ucy5rZXkgfHwgdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlIHx8IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQgfHwgdGhpcy5jZXJ0LFxuICAgIGNhOiBvcHRpb25zLmNhIHx8IHRoaXMuY2EsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzIHx8IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIHx8IHRoaXMucmVqZWN0VW5hdXRob3JpemVkLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiBvcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlIHx8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgZXh0cmFIZWFkZXJzOiBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCB0aGlzLmV4dHJhSGVhZGVycyxcbiAgICBmb3JjZU5vZGU6IG9wdGlvbnMuZm9yY2VOb2RlIHx8IHRoaXMuZm9yY2VOb2RlLFxuICAgIGxvY2FsQWRkcmVzczogb3B0aW9ucy5sb2NhbEFkZHJlc3MgfHwgdGhpcy5sb2NhbEFkZHJlc3MsXG4gICAgcmVxdWVzdFRpbWVvdXQ6IG9wdGlvbnMucmVxdWVzdFRpbWVvdXQgfHwgdGhpcy5yZXF1ZXN0VGltZW91dCxcbiAgICBwcm90b2NvbHM6IG9wdGlvbnMucHJvdG9jb2xzIHx8IHZvaWQgKDApLFxuICAgIGlzUmVhY3ROYXRpdmU6IHRoaXMuaXNSZWFjdE5hdGl2ZVxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT09IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSk7XG4gIHZhciBmYWlsZWQgPSBmYWxzZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4gKCkge1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0ICgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvciAoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UgKCkge1xuICAgIG9uZXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlICgpIHtcbiAgICBvbmVycm9yKCdzb2NrZXQgY2xvc2VkJyk7XG4gIH1cblxuICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUgKHRvKSB7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9PSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIHRoaXMuZW1pdCgncG9uZycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAoJ2Nsb3NlZCcgPT09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHByaXZhdGVcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbWl0KCdwaW5nJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgb3B0aW9ucywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGF0YSkge1xuICAgIGZuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgZm4gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuXG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBkYXRhOiBkYXRhLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgaWYgKGZuKSB0aGlzLm9uY2UoJ2ZsdXNoJywgZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UgKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgY2xvc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlICgpIHtcbiAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBvcHRzLndpdGhDcmVkZW50aWFscztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG4gIHRoaXMuZm9yY2VOb2RlID0gb3B0cy5mb3JjZU5vZGU7XG5cbiAgLy8gcmVzdWx0cyBvZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBkZXRlY3Rpb25cbiAgdGhpcy5pc1JlYWN0TmF0aXZlID0gb3B0cy5pc1JlYWN0TmF0aXZlO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG4gIHRoaXMubG9jYWxBZGRyZXNzID0gb3B0cy5sb2NhbEFkZHJlc3M7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBhY2tldHMpIHtcbiAgaWYgKCdvcGVuJyA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcgKG9wdHMpIHtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9PSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIFVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWdsb2JhbCBpcyBzaGlwcGVkLlxuICovXG5mdW5jdGlvbiBnbG9iICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGZcbiAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fTtcbn1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICB2YXIgZ2xvYmFsID0gZ2xvYigpO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW8gPSAoZ2xvYmFsLl9fX2VpbyB8fCBbXSk7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLCBlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGlmIChpbnNlcnRBdCkge1xuICAgIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB9IGVsc2Uge1xuICAgIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9PSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInICsgc2VsZi5pZnJhbWVJZCArICdcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiLyogZ2xvYmFsIGF0dGFjaEV2ZW50ICovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9ICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmIG9wdHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uLmhvc3RuYW1lKSB8fFxuICAgICAgcG9ydCAhPT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuICBvcHRzLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcbiAgb3B0cy5yZXF1ZXN0VGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gb3RoZXIgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5leHRyYUhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdHMpIHtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBvcHRzLndpdGhDcmVkZW50aWFscztcbiAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXQ7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayAmJiB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKHRydWUpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICgnUE9TVCcgPT09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICcqLyonKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB4aHIudGltZW91dCA9IHRoaXMucmVxdWVzdFRpbWVvdXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc3VwcG9ydHNCaW5hcnkgJiYgY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtOyBjaGFyc2V0PVVURi04Jykge1xuICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih0eXBlb2YgeGhyLnN0YXR1cyA9PT0gJ251bWJlcicgPyB4aHIuc3RhdHVzIDogMCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKGZyb21FcnJvcikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtOyBjaGFyc2V0PVVURi04Jykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlIHx8IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cblJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG5SZXF1ZXN0LnJlcXVlc3RzID0ge307XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0ZXJtaW5hdGlvbkV2ZW50ID0gJ29ucGFnZWhpZGUnIGluIHNlbGYgPyAncGFnZWhpZGUnIDogJ3VubG9hZCc7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0ZXJtaW5hdGlvbkV2ZW50LCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlciAoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIHllYXN0ID0gcmVxdWlyZSgneWVhc3QnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0LXNzbCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nIChvcHRzKSB7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChvblBhdXNlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UgKCkge1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgKGlwdjYgPyAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nIDogdGhpcy5ob3N0bmFtZSkgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciB5ZWFzdCA9IHJlcXVpcmUoJ3llYXN0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXG52YXIgQnJvd3NlcldlYlNvY2tldCwgTm9kZVdlYlNvY2tldDtcblxuaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXJXZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICBCcm93c2VyV2ViU29ja2V0ID0gc2VsZi5XZWJTb2NrZXQgfHwgc2VsZi5Nb3pXZWJTb2NrZXQ7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICB0cnkge1xuICAgIE5vZGVXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuICB9IGNhdGNoIChlKSB7IH1cbn1cblxuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3NlciBvciB0cnkgdG8gcmVzb2x2ZSBXZWJTb2NrZXQtY29tcGF0aWJsZVxuICogaW50ZXJmYWNlIGV4cG9zZWQgYnkgYHdzYCBmb3IgTm9kZS1saWtlIGVudmlyb25tZW50LlxuICovXG5cbnZhciBXZWJTb2NrZXRJbXBsID0gQnJvd3NlcldlYlNvY2tldCB8fCBOb2RlV2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyAob3B0cykge1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICB0aGlzLnVzaW5nQnJvd3NlcldlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQgJiYgIW9wdHMuZm9yY2VOb2RlO1xuICB0aGlzLnByb3RvY29scyA9IG9wdHMucHJvdG9jb2xzO1xuICBpZiAoIXRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgV2ViU29ja2V0SW1wbCA9IE5vZGVXZWJTb2NrZXQ7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdGhpcy5wcm90b2NvbHM7XG4gIHZhciBvcHRzID0ge1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG4gIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcbiAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLmV4dHJhSGVhZGVycztcbiAgfVxuICBpZiAodGhpcy5sb2NhbEFkZHJlc3MpIHtcbiAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMubG9jYWxBZGRyZXNzO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLndzID1cbiAgICAgIHRoaXMudXNpbmdCcm93c2VyV2ViU29ja2V0ICYmICF0aGlzLmlzUmVhY3ROYXRpdmVcbiAgICAgICAgPyBwcm90b2NvbHNcbiAgICAgICAgICA/IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSwgcHJvdG9jb2xzKVxuICAgICAgICAgIDogbmV3IFdlYlNvY2tldEltcGwodXJpKVxuICAgICAgICA6IG5ldyBXZWJTb2NrZXRJbXBsKHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnbm9kZWJ1ZmZlcic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgfVxuXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChwYWNrZXRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgdmFyIHRvdGFsID0gcGFja2V0cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcbiAgICAoZnVuY3Rpb24gKHBhY2tldCkge1xuICAgICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHNlbGYuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICghc2VsZi51c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAvLyBhbHdheXMgY3JlYXRlIGEgbmV3IG9iamVjdCAoR0gtNDM3KVxuICAgICAgICAgIHZhciBvcHRzID0ge307XG4gICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGYucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSAnc3RyaW5nJyA9PT0gdHlwZW9mIGRhdGEgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAvLyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLnVzaW5nQnJvd3NlcldlYlNvY2tldCkge1xuICAgICAgICAgICAgLy8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcbiAgICAgICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAtLXRvdGFsIHx8IGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pKHBhY2tldHNbaV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgc2VsZi5lbWl0KCdmbHVzaCcpO1xuXG4gICAgLy8gZmFrZSBkcmFpblxuICAgIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgKCd3cycgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5wb3J0KSAhPT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0geWVhc3QoKTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgdmFyIGlwdjYgPSB0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIVdlYlNvY2tldEltcGwgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXRJbXBsICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG5cbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgc2VsZltbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgfVxufTtcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG5cbnZhciBiYXNlNjRlbmNvZGVyO1xuaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHV0ZjhlbmNvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSksIHsgc3RyaWN0OiBmYWxzZSB9KSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldCh7IHR5cGU6IHBhY2tldC50eXBlLCBkYXRhOiBmci5yZXN1bHQgfSwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbmZ1bmN0aW9uIHRyeURlY29kZShkYXRhKSB7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghYmFzZTY0ZW5jb2Rlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKGNociAhPT0gJzonKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cblxuICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoZXJyLnR5cGUgPT09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgaSArPSBuO1xuICAgIGxlbmd0aCA9ICcnO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09PSAyNTUpIGJyZWFrO1xuXG4gICAgICAvLyAzMTAgPSBjaGFyIGxlbmd0aCBvZiBOdW1iZXIuTUFYX1ZBTFVFXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cblxudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHZhciB2YWx1ZTtcblx0dmFyIGV4dHJhO1xuXHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dHB1dDtcbn1cblxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciB2YWx1ZTtcblx0dmFyIG91dHB1dCA9ICcnO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdH1cblx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG5cdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHR9XG5cdHZhciBzeW1ib2wgPSAnJztcblx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdH1cblx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuXHRcdFx0Y29kZVBvaW50ID0gMHhGRkZEO1xuXHRcdH1cblx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHR9XG5cdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdH1cblx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0cmV0dXJuIHN5bWJvbDtcbn1cblxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcblx0b3B0cyA9IG9wdHMgfHwge307XG5cdHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG5cblx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0dmFyIGluZGV4ID0gLTE7XG5cdHZhciBjb2RlUG9pbnQ7XG5cdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuXHR9XG5cdHJldHVybiBieXRlU3RyaW5nO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHR9XG5cblx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdGJ5dGVJbmRleCsrO1xuXG5cdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdH1cblxuXHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVN5bWJvbChzdHJpY3QpIHtcblx0dmFyIGJ5dGUxO1xuXHR2YXIgYnl0ZTI7XG5cdHZhciBieXRlMztcblx0dmFyIGJ5dGU0O1xuXHR2YXIgY29kZVBvaW50O1xuXG5cdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdH1cblxuXHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0Ynl0ZUluZGV4Kys7XG5cblx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0cmV0dXJuIGJ5dGUxO1xuXHR9XG5cblx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cdH1cblxuXHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcbn1cblxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG5cdG9wdHMgPSBvcHRzIHx8IHt9O1xuXHR2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuXG5cdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdGJ5dGVJbmRleCA9IDA7XG5cdHZhciBjb2RlUG9pbnRzID0gW107XG5cdHZhciB0bXA7XG5cdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKHN0cmljdCkpICE9PSBmYWxzZSkge1xuXHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHR9XG5cdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0dmVyc2lvbjogJzIuMS4yJyxcblx0ZW5jb2RlOiB1dGY4ZW5jb2RlLFxuXHRkZWNvZGU6IHV0ZjhkZWNvZGVcbn07XG4iLCIvKiBnbG9iYWwgQmxvYiBGaWxlICovXG5cbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEJsb2IpID09PSAnW29iamVjdCBCbG9iQ29uc3RydWN0b3JdJztcbnZhciB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gJ1tvYmplY3QgRmlsZUNvbnN0cnVjdG9yXSc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBTdXBwb3J0cyBCdWZmZXIsIEFycmF5QnVmZmVyLCBCbG9iIGFuZCBGaWxlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkgKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChoYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIEJ1ZmZlci5pc0J1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAodHlwZW9mIEFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcbiAgaWYgKG9iai50b0pTT04gJiYgdHlwZW9mIG9iai50b0pTT04gPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBoYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjEyLjMgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTksIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHBzOi8vcHVja2V5LnN0dWRpby9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBTYXQgSnVuIDIyIDE0OjE2OjQ5IDIwMTkgKzAyMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxOSBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwczovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cblxudmFyIHBhcGVyID0gZnVuY3Rpb24oc2VsZiwgdW5kZWZpbmVkKSB7XG5cbnNlbGYgPSBzZWxmIHx8IHJlcXVpcmUoJy4vbm9kZS9zZWxmLmpzJyk7XG52YXIgd2luZG93ID0gc2VsZi53aW5kb3csXG5cdGRvY3VtZW50ID0gc2VsZi5kb2N1bWVudDtcblxudmFyIEJhc2UgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBoaWRkZW4gPSAvXihzdGF0aWNzfGVudW1lcmFibGV8YmVhbnN8cHJlc2VydmUpJC8sXG5cdFx0YXJyYXkgPSBbXSxcblx0XHRzbGljZSA9IGFycmF5LnNsaWNlLFxuXHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG5cdFx0ZGVzY3JpYmUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuXHRcdGRlZmluZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcblxuXHRcdGZvckVhY2ggPSBhcnJheS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRmb3JJbiA9IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcykge1xuXHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oZHN0KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHNyYykge1xuXHRcdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRcdFx0XHRcdGRzdFtrZXldID0gc3JjW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkc3Q7XG5cdFx0fSxcblxuXHRcdGVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRcdGlmIChvYmopIHtcblx0XHRcdFx0dmFyIGRlc2MgPSBkZXNjcmliZShvYmosICdsZW5ndGgnKTtcblx0XHRcdFx0KGRlc2MgJiYgdHlwZW9mIGRlc2MudmFsdWUgPT09ICdudW1iZXInID8gZm9yRWFjaCA6IGZvckluKVxuXHRcdFx0XHRcdC5jYWxsKG9iaiwgaXRlciwgYmluZCA9IGJpbmQgfHwgb2JqKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBiaW5kO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG5cdFx0dmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuXHRcdFx0dmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKVxuXHRcdFx0XHRcdCYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJylcblx0XHRcdFx0dmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG5cdFx0XHR2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdFx0cmVzID0gdmFsLFxuXHRcdFx0XHRwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jICYmICF2YWwuYmFzZVxuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpIHtcblx0XHRcdFx0XHRyZXMgPSB7IHZhbHVlOiByZXMsIHdyaXRhYmxlOiB0cnVlIH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKChkZXNjcmliZShkZXN0LCBuYW1lKVxuXHRcdFx0XHRcdFx0fHwgeyBjb25maWd1cmFibGU6IHRydWUgfSkuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0cmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlICE9IG51bGwgPyBlbnVtZXJhYmxlIDogIWJlYW47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gQmFzZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoc3JjKVxuXHRcdFx0XHRzZXQodGhpcywgc3JjKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHRyZXR1cm4gaW5qZWN0KEJhc2UsIHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKHNyYykge1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHR2YXIgc3RhdGljcyA9IHNyYy5zdGF0aWNzID09PSB0cnVlID8gc3JjIDogc3JjLnN0YXRpY3MsXG5cdFx0XHRcdFx0YmVhbnMgPSBzcmMuYmVhbnMsXG5cdFx0XHRcdFx0cHJlc2VydmUgPSBzcmMucHJlc2VydmU7XG5cdFx0XHRcdGlmIChzdGF0aWNzICE9PSBzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMucHJvdG90eXBlLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0XHRpbmplY3QodGhpcywgc3RhdGljcywgbnVsbCwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5pbmplY3QoYXJndW1lbnRzW2ldKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLFxuXHRcdFx0XHRjdG9yLFxuXHRcdFx0XHRwcm90bztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBvYmosIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0XHRcdGkgPCBsICYmICEoY3RvciAmJiBwcm90byk7IGkrKykge1xuXHRcdFx0XHRvYmogPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGN0b3IgPSBjdG9yIHx8IG9iai5pbml0aWFsaXplO1xuXHRcdFx0XHRwcm90byA9IHByb3RvIHx8IG9iai5wcm90b3R5cGU7XG5cdFx0XHR9XG5cdFx0XHRjdG9yID0gY3RvciB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3Rvci5wcm90b3R5cGUgPSBwcm90byB8fCBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0ZGVmaW5lKHByb3RvLCAnY29uc3RydWN0b3InLFxuXHRcdFx0XHRcdHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRpbmplY3QoY3RvciwgdGhpcyk7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5pbmplY3QuYXBwbHkoY3RvciwgYXJndW1lbnRzKTtcblx0XHRcdGN0b3IuYmFzZSA9IGJhc2U7XG5cdFx0XHRyZXR1cm4gY3Rvcjtcblx0XHR9XG5cdH0pLmluamVjdCh7XG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cblx0XHRpbml0aWFsaXplOiBCYXNlLFxuXG5cdFx0c2V0OiBCYXNlLFxuXG5cdFx0aW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMsIHNyYywgc3JjLmVudW1lcmFibGUsIHNyYy5iZWFucywgc3JjLnByZXNlcnZlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRlYWNoOiBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRyZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdGVhY2g6IGVhY2gsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGRlZmluZTogZGVmaW5lLFxuXHRcdFx0ZGVzY3JpYmU6IGRlc2NyaWJlLFxuXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHJldHVybiBzZXQobmV3IG9iai5jb25zdHJ1Y3RvcigpLCBvYmopO1xuXHRcdFx0fSxcblxuXHRcdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdHZhciBjdG9yID0gb2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRyZXR1cm4gY3RvciAmJiAoY3RvciA9PT0gT2JqZWN0IHx8IGN0b3IgPT09IEJhc2Vcblx0XHRcdFx0XHRcdHx8IGN0b3IubmFtZSA9PT0gJ09iamVjdCcpO1xuXHRcdFx0fSxcblxuXHRcdFx0cGljazogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYSAhPT0gdW5kZWZpbmVkID8gYSA6IGI7XG5cdFx0XHR9LFxuXG5cdFx0XHRzbGljZTogZnVuY3Rpb24obGlzdCwgYmVnaW4sIGVuZCkge1xuXHRcdFx0XHRyZXR1cm4gc2xpY2UuY2FsbChsaXN0LCBiZWdpbiwgZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKVxuXHRtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cbkJhc2UuaW5qZWN0KHtcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZCAhPSBudWxsXG5cdFx0XHQ/ICAodGhpcy5fY2xhc3MgfHwgJ09iamVjdCcpICsgKHRoaXMuX25hbWVcblx0XHRcdFx0PyBcIiAnXCIgKyB0aGlzLl9uYW1lICsgXCInXCJcblx0XHRcdFx0OiAnIEAnICsgdGhpcy5faWQpXG5cdFx0XHQ6ICd7ICcgKyBCYXNlLmVhY2godGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wdXNoKGtleSArICc6ICcgKyAodHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdFx0PyBGb3JtYXR0ZXIuaW5zdGFuY2UubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdzdHJpbmcnID8gXCInXCIgKyB2YWx1ZSArIFwiJ1wiIDogdmFsdWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgW10pLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsYXNzIHx8ICcnO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHRyZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuXHR9LFxuXG5cdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5leHBvcnRKU09OKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUpIHtcblx0XHRpZiAocHJvcHMpXG5cdFx0XHRCYXNlLmZpbHRlcih0aGlzLCBwcm9wcywgZXhjbHVkZSwgdGhpcy5fcHJpb3JpdGl6ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIHtcblxuYmVhbnM6IGZhbHNlLFxuc3RhdGljczoge1xuXHRleHBvcnRzOiB7fSxcblxuXHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHR2YXIgcmVzID0gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcblx0XHRcdG5hbWUgPSByZXMucHJvdG90eXBlLl9jbGFzcztcblx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0QmFzZS5leHBvcnRzW25hbWVdID0gcmVzO1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihvYmoxLCBvYmoyKSB7XG5cdFx0aWYgKG9iajEgPT09IG9iajIpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAob2JqMSAmJiBvYmoxLmVxdWFscylcblx0XHRcdHJldHVybiBvYmoxLmVxdWFscyhvYmoyKTtcblx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdHJldHVybiBvYmoyLmVxdWFscyhvYmoxKTtcblx0XHRpZiAob2JqMSAmJiBvYmoyXG5cdFx0XHRcdCYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iajEpICYmIEFycmF5LmlzQXJyYXkob2JqMikpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IG9iajEubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtsZW5ndGhdLCBvYmoyW2xlbmd0aF0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iajEpLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tsZW5ndGhdO1xuXHRcdFx0XHRcdGlmICghKG9iajIuaGFzT3duUHJvcGVydHkoa2V5KVxuXHRcdFx0XHRcdFx0XHQmJiBCYXNlLmVxdWFscyhvYmoxW2tleV0sIG9iajJba2V5XSkpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHJlYWQ6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBhbW91bnQpIHtcblx0XHRpZiAodGhpcyA9PT0gQmFzZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcblx0XHRcdGxpc3QuX19pbmRleCsrO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHR2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZSxcblx0XHRcdHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG5cdFx0XHRiZWdpbiA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMCxcblx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoLFxuXHRcdFx0b2JqID0gbGlzdFtiZWdpbl07XG5cdFx0YW1vdW50ID0gYW1vdW50IHx8IGxlbmd0aCAtIGJlZ2luO1xuXHRcdGlmIChvYmogaW5zdGFuY2VvZiB0aGlzXG5cdFx0XHR8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgYW1vdW50IDw9IDEpIHtcblx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdGxpc3QuX19pbmRleCA9IGJlZ2luICsgMTtcblx0XHRcdHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG5cdFx0fVxuXHRcdG9iaiA9IEJhc2UuY3JlYXRlKHByb3RvKTtcblx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0b2JqLl9fcmVhZCA9IHRydWU7XG5cdFx0b2JqID0gb2JqLmluaXRpYWxpemUuYXBwbHkob2JqLCBiZWdpbiA+IDAgfHwgYmVnaW4gKyBhbW91bnQgPCBsZW5ndGhcblx0XHRcdFx0PyBCYXNlLnNsaWNlKGxpc3QsIGJlZ2luLCBiZWdpbiArIGFtb3VudClcblx0XHRcdFx0OiBsaXN0KSB8fCBvYmo7XG5cdFx0aWYgKHJlYWRJbmRleCkge1xuXHRcdFx0bGlzdC5fX2luZGV4ID0gYmVnaW4gKyBvYmouX19yZWFkO1xuXHRcdFx0dmFyIGZpbHRlcmVkID0gb2JqLl9fZmlsdGVyZWQ7XG5cdFx0XHRpZiAoZmlsdGVyZWQpIHtcblx0XHRcdFx0bGlzdC5fX2ZpbHRlcmVkID0gZmlsdGVyZWQ7XG5cdFx0XHRcdG9iai5fX2ZpbHRlcmVkID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0b2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHRwZWVrOiBmdW5jdGlvbihsaXN0LCBzdGFydCkge1xuXHRcdHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcblx0fSxcblxuXHRyZW1haW46IGZ1bmN0aW9uKGxpc3QpIHtcblx0XHRyZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuXHR9LFxuXG5cdHJlYWRMaXN0OiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG5cdFx0dmFyIHJlcyA9IFtdLFxuXHRcdFx0ZW50cnksXG5cdFx0XHRiZWdpbiA9IHN0YXJ0IHx8IDAsXG5cdFx0XHRlbmQgPSBhbW91bnQgPyBiZWdpbiArIGFtb3VudCA6IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRyZXMucHVzaChBcnJheS5pc0FycmF5KGVudHJ5ID0gbGlzdFtpXSlcblx0XHRcdFx0XHQ/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcblx0XHRcdFx0XHQ6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0cmVhZE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lLCBzdGFydCwgb3B0aW9ucywgYW1vdW50KSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcblx0XHRcdGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0aWYgKGhhc09iamVjdCkge1xuXHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fX2ZpbHRlcmVkO1xuXHRcdFx0aWYgKCFmaWx0ZXJlZCkge1xuXHRcdFx0XHRmaWx0ZXJlZCA9IGxpc3QuX19maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKGxpc3RbMF0pO1xuXHRcdFx0XHRmaWx0ZXJlZC5fX3VuZmlsdGVyZWQgPSBsaXN0WzBdO1xuXHRcdFx0fVxuXHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHZhciBsID0gaGFzT2JqZWN0ID8gW3ZhbHVlXSA6IGxpc3QsXG5cdFx0XHRyZXMgPSB0aGlzLnJlYWQobCwgc3RhcnQsIG9wdGlvbnMsIGFtb3VudCk7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRnZXROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdHZhciBhcmcgPSBsaXN0WzBdO1xuXHRcdGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcblx0XHRcdGxpc3QuX2hhc09iamVjdCA9IGxpc3QubGVuZ3RoID09PSAxICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpO1xuXHRcdGlmIChsaXN0Ll9oYXNPYmplY3QpXG5cdFx0XHRyZXR1cm4gbmFtZSA/IGFyZ1tuYW1lXSA6IGxpc3QuX19maWx0ZXJlZCB8fCBhcmc7XG5cdH0sXG5cblx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24oZGVzdCwgc291cmNlLCBleGNsdWRlLCBwcmlvcml0aXplKSB7XG5cdFx0dmFyIHByb2Nlc3NlZDtcblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUtleShrZXkpIHtcblx0XHRcdGlmICghKGV4Y2x1ZGUgJiYga2V5IGluIGV4Y2x1ZGUpICYmXG5cdFx0XHRcdCEocHJvY2Vzc2VkICYmIGtleSBpbiBwcm9jZXNzZWQpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRkZXN0W2tleV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocHJpb3JpdGl6ZSkge1xuXHRcdFx0dmFyIGtleXMgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBrZXksIGwgPSBwcmlvcml0aXplLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoKGtleSA9IHByaW9yaXRpemVbaV0pIGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdGhhbmRsZUtleShrZXkpO1xuXHRcdFx0XHRcdGtleXNba2V5XSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByb2Nlc3NlZCA9IGtleXM7XG5cdFx0fVxuXG5cdFx0T2JqZWN0LmtleXMoc291cmNlLl9fdW5maWx0ZXJlZCB8fCBzb3VyY2UpLmZvckVhY2goaGFuZGxlS2V5KTtcblx0XHRyZXR1cm4gZGVzdDtcblx0fSxcblxuXHRpc1BsYWluVmFsdWU6IGZ1bmN0aW9uKG9iaiwgYXNTdHJpbmcpIHtcblx0XHRyZXR1cm4gQmFzZS5pc1BsYWluT2JqZWN0KG9iaikgfHwgQXJyYXkuaXNBcnJheShvYmopXG5cdFx0XHRcdHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgaXNSb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRyZXM7XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdGxlbmd0aDogMCxcblx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0YWRkOiBmdW5jdGlvbihpdGVtLCBjcmVhdGUpIHtcblx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0aWYgKCFyZWYpIHtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBpdGVtLl9jbGFzcztcblx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHR0aGlzLmRlZmluaXRpb25zW2lkXSA9IHJlcztcblx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdHZhciBuYW1lID0gb2JqLl9jbGFzcztcblx0XHRcdGlmIChuYW1lICYmICFvYmouX2NvbXBhY3RTZXJpYWxpemUgJiYgKGlzUm9vdCB8fCAhY29tcGFjdClcblx0XHRcdFx0XHQmJiByZXNbMF0gIT09IG5hbWUpIHtcblx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpO1xuXHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpba2V5XSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzID0gb2JqO1xuXHRcdH1cblx0XHRyZXR1cm4gaXNSb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHQ/IFtbJ2RpY3Rpb25hcnknLCBkaWN0aW9uYXJ5LmRlZmluaXRpb25zXSwgcmVzXVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRkZXNlcmlhbGl6ZTogZnVuY3Rpb24oanNvbiwgY3JlYXRlLCBfZGF0YSwgX3NldERpY3Rpb25hcnksIF9pc1Jvb3QpIHtcblx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdGlzRmlyc3QgPSAhX2RhdGEsXG5cdFx0XHRoYXNEaWN0aW9uYXJ5ID0gaXNGaXJzdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoXG5cdFx0XHRcdCYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHR2YXIgdHlwZSA9IGpzb25bMF0sXG5cdFx0XHRcdGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRcdGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSkge1xuXHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdH1cblx0XHRcdHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG5cdFx0XHRyZXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsXG5cdFx0XHRcdFx0XHRpc0RpY3Rpb25hcnksIGhhc0RpY3Rpb25hcnkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0cmVzID0gY3JlYXRlKHR5cGUsIGFyZ3MsIGlzRmlyc3QgfHwgX2lzUm9vdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzID0gbmV3IHR5cGUoYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChqc29uKSkge1xuXHRcdFx0cmVzID0ge307XG5cdFx0XHRpZiAoX3NldERpY3Rpb25hcnkpXG5cdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4ganNvbilcblx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBoYXNEaWN0aW9uYXJ5ID8gcmVzWzFdIDogcmVzO1xuXHR9LFxuXG5cdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdHZhciBqc29uID0gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zKTtcblx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09IGZhbHNlXG5cdFx0XHRcdD8ganNvblxuXHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24sIHRhcmdldCkge1xuXHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHR0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbixcblx0XHRcdFx0ZnVuY3Rpb24oY3RvciwgYXJncywgaXNSb290KSB7XG5cdFx0XHRcdFx0dmFyIHVzZVRhcmdldCA9IGlzUm9vdCAmJiB0YXJnZXRcblx0XHRcdFx0XHRcdFx0JiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSBjdG9yLFxuXHRcdFx0XHRcdFx0b2JqID0gdXNlVGFyZ2V0ID8gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdDogQmFzZS5jcmVhdGUoY3Rvci5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdCYmICh1c2VUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSkge1xuXHRcdFx0XHRcdFx0XHRhcmcuaW5zZXJ0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGlmICh1c2VUYXJnZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJncy5jb25jYXQoW3sgaW5zZXJ0OiB0cnVlIH1dKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQodXNlVGFyZ2V0ID8gb2JqLnNldCA6IGN0b3IpLmFwcGx5KG9iaiwgYXJncyk7XG5cdFx0XHRcdFx0aWYgKHVzZVRhcmdldClcblx0XHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fSk7XG5cdH0sXG5cblx0cHVzaDogZnVuY3Rpb24obGlzdCwgaXRlbXMpIHtcblx0XHR2YXIgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG5cdFx0aWYgKGl0ZW1zTGVuZ3RoIDwgNDA5Nikge1xuXHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHN0YXJ0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRsaXN0Lmxlbmd0aCArPSBpdGVtc0xlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsaXN0W3N0YXJ0TGVuZ3RoICsgaV0gPSBpdGVtc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH0sXG5cblx0c3BsaWNlOiBmdW5jdGlvbihsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuXHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PT0gdW5kZWZpbmVkO1xuXHRcdGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcblx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdGluZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcblx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRCYXNlLnB1c2gobGlzdCwgaXRlbXMpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcblx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0QmFzZS5wdXNoKGFyZ3MsIGl0ZW1zKTtcblx0XHRcdHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRyZW1vdmVkW2ldLl9pbmRleCA9IHVuZGVmaW5lZDtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHR9XG5cdH0sXG5cblx0Y2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihtYXRjaCwgY2hyKSB7XG5cdFx0XHRyZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0aHlwaGVuYXRlOiBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdH1cbn19KTtcblxudmFyIEVtaXR0ZXIgPSB7XG5cdG9uOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vbihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdGlmIChoYW5kbGVycy5pbmRleE9mKGZ1bmMpID09PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvZmY6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9mZihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSxcblx0XHRcdGluZGV4O1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0aWYgKCFmdW5jIHx8IChpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YoZnVuYykpICE9PSAtMVxuXHRcdFx0XHRcdCYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkgJiYgZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fY2FsbGJhY2tzW3R5cGVdO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b25jZTogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZih0eXBlLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fSxcblxuXHRlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IEJhc2Uuc2xpY2UoYXJndW1lbnRzLCAxKSxcblx0XHRcdHNldFRhcmdldCA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiAhZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKCk7XG5cdFx0aWYgKHNldFRhcmdldClcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT0gZmFsc2UpIHtcblx0XHRcdFx0aWYgKGV2ZW50ICYmIGV2ZW50LnN0b3ApXG5cdFx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHQgICB9XG5cdFx0fVxuXHRcdGlmIChzZXRUYXJnZXQpXG5cdFx0XHRkZWxldGUgZXZlbnQuY3VycmVudFRhcmdldDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZXNwb25kczogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiAhISh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdKTtcblx0fSxcblxuXHRhdHRhY2g6ICcjb24nLFxuXHRkZXRhY2g6ICcjb2ZmJyxcblx0ZmlyZTogJyNlbWl0JyxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24oaW5zdGFsbCkge1xuXHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyxcblx0XHRcdGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblx0XHRpZiAodHlwZXMpIHtcblx0XHRcdGZvciAodmFyIHR5cGUgaW4gaGFuZGxlcnMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgZW50cnkgPSB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRcdGZ1bmMgPSBlbnRyeSAmJiBlbnRyeVtrZXldO1xuXHRcdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdFx0ZnVuYy5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChzcmMpIHtcblx0XHRcdHZhciBldmVudHMgPSBzcmMuX2V2ZW50cztcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0dmFyIHR5cGVzID0ge307XG5cdFx0XHRcdEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0XHRcdFx0XHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnLFxuXHRcdFx0XHRcdFx0bmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRcdFx0dHlwZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG5cdFx0XHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0XHRcdFx0c3JjWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0c3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJldiA9IHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0XHRpZiAocHJldilcblx0XHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgcHJldik7XG5cdFx0XHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRcdFx0dGhpcy5vbih0eXBlLCBmdW5jKTtcblx0XHRcdFx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBuZXcgQmFzZSh7XG5cdFx0XHRhcHBseU1hdHJpeDogdHJ1ZSxcblx0XHRcdGluc2VydEl0ZW1zOiB0cnVlLFxuXHRcdFx0aGFuZGxlU2l6ZTogNCxcblx0XHRcdGhpdFRvbGVyYW5jZTogMFxuXHRcdH0pO1xuXHRcdHRoaXMucHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5wcm9qZWN0cyA9IFtdO1xuXHRcdHRoaXMudG9vbHMgPSBbXTtcblx0XHR0aGlzLl9pZCA9IFBhcGVyU2NvcGUuX2lkKys7XG5cdFx0UGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dmFyIHByb3RvID0gUGFwZXJTY29wZS5wcm90b3R5cGU7XG5cdFx0aWYgKCF0aGlzLnN1cHBvcnQpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpIHx8IHt9O1xuXHRcdFx0cHJvdG8uc3VwcG9ydCA9IHtcblx0XHRcdFx0bmF0aXZlRGFzaDogJ3NldExpbmVEYXNoJyBpbiBjdHggfHwgJ21vekRhc2gnIGluIGN0eCxcblx0XHRcdFx0bmF0aXZlQmxlbmRNb2RlczogQmxlbmRNb2RlLm5hdGl2ZU1vZGVzXG5cdFx0XHR9O1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuYWdlbnQpIHtcblx0XHRcdHZhciB1c2VyID0gc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdG9zID0gKC8oZGFyd2lufHdpbnxtYWN8bGludXh8ZnJlZWJzZHxzdW5vcykvLmV4ZWModXNlcil8fFtdKVswXSxcblx0XHRcdFx0cGxhdGZvcm0gPSBvcyA9PT0gJ2RhcndpbicgPyAnbWFjJyA6IG9zLFxuXHRcdFx0XHRhZ2VudCA9IHByb3RvLmFnZW50ID0gcHJvdG8uYnJvd3NlciA9IHsgcGxhdGZvcm06IHBsYXRmb3JtIH07XG5cdFx0XHRpZiAocGxhdGZvcm0pXG5cdFx0XHRcdGFnZW50W3BsYXRmb3JtXSA9IHRydWU7XG5cdFx0XHR1c2VyLnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbXxub2RlfGpzZG9tKVxcLz9cXHMqKFsuXFxkXSspKD86Lip2ZXJzaW9uXFwvKFsuXFxkXSspKT8oPzouKnJ2XFw6dj8oWy5cXGRdKykpPy9nLFxuXHRcdFx0XHRmdW5jdGlvbihtYXRjaCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYWdlbnQuY2hyb21lKSB7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IG4gPT09ICdvcGVyYScgPyB2MiA6XG5cdFx0XHRcdFx0XHRcdFx0L14obm9kZXx0cmlkZW50KSQvLnRlc3QobikgPyBydiA6IHYxO1xuXHRcdFx0XHRcdFx0YWdlbnQudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRhZ2VudC52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcblx0XHRcdFx0XHRcdG4gPSB7IHRyaWRlbnQ6ICdtc2llJywganNkb206ICdub2RlJyB9W25dIHx8IG47XG5cdFx0XHRcdFx0XHRhZ2VudC5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGFnZW50W25dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRpZiAoYWdlbnQuY2hyb21lKVxuXHRcdFx0XHRkZWxldGUgYWdlbnQud2Via2l0O1xuXHRcdFx0aWYgKGFnZW50LmF0b20pXG5cdFx0XHRcdGRlbGV0ZSBhZ2VudC5jaHJvbWU7XG5cdFx0fVxuXHR9LFxuXG5cdHZlcnNpb246IFwiMC4xMi4zXCIsXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3QgPSB0aGlzLnByb2plY3Q7XG5cdFx0cmV0dXJuIHByb2plY3QgJiYgcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRnZXRQYXBlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhlY3V0ZTogZnVuY3Rpb24oY29kZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGV4cG9ydHMgPSBwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydHM7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNyZWF0ZUNhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHJldHVybiBDYW52YXNQcm92aWRlci5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByb2plY3RzID0gdGhpcy5wcm9qZWN0cyxcblx0XHRcdHRvb2xzID0gdGhpcy50b29scztcblx0XHRmb3IgKHZhciBpID0gcHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHRwcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdG9vbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0b29sc1tpXS5yZW1vdmUoKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHRkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcblx0fSxcblxuXHRzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRcdG5hbWUgKz0gJ0F0dHJpYnV0ZSc7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWwsIGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIGVsW25hbWVdKGF0dHIpIHx8IGVsW25hbWVdKCdkYXRhLXBhcGVyLScgKyBhdHRyKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9zY29wZXM6IHt9LFxuXHRcdFx0X2lkOiAwLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zY29wZXNbaWRdIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnZ2V0JyksXG5cdFx0XHRoYXNBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnaGFzJylcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFBhcGVyU2NvcGVJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG5cdFx0dGhpcy5fc2NvcGUgPSBwYXBlcjtcblx0XHR0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuXHRcdGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSlcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9zY29wZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcylcblx0XHRcdHByZXYuZW1pdCgnZGVhY3RpdmF0ZScpO1xuXHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuXHRcdHRoaXMuZW1pdCgnYWN0aXZhdGUnLCBwcmV2KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5faW5kZXggPT0gbnVsbClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpXG5cdFx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLmdldFZpZXcoKTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gQmFzZS5waWNrKHByZWNpc2lvbiwgNSk7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnByZWNpc2lvbiA8IDE2XG5cdFx0XHRcdD8gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyIDogdmFsO1xuXHR9LFxuXG5cdHBhaXI6IGZ1bmN0aW9uKHZhbDEsIHZhbDIsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwxKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbDIpO1xuXHR9LFxuXG5cdHBvaW50OiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwueCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwueSk7XG5cdH0sXG5cblx0c2l6ZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMubnVtYmVyKHZhbC5oZWlnaHQpO1xuXHR9LFxuXG5cdHJlY3RhbmdsZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludCh2YWwsIHNlcGFyYXRvcikgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuXHR9XG59KTtcblxuRm9ybWF0dGVyLmluc3RhbmNlID0gbmV3IEZvcm1hdHRlcigpO1xuXG52YXIgTnVtZXJpY2FsID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBhYnNjaXNzYXMgPSBbXG5cdFx0WyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcblx0XHRbMCwwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLFxuXHRcdFsgIDAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLFxuXHRcdFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxuXHRcdFsgIDAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSxcblx0XHRbMCwwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sXG5cdFx0WyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcblx0XHRbMCwwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLFxuXHRcdFsgIDAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLFxuXHRcdFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxuXHRcdFsgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSxcblx0XHRbMCwwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sXG5cdFx0WyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcblx0XHRbMCwwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLFxuXHRcdFsgIDAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXG5cdF07XG5cblx0dmFyIHdlaWdodHMgPSBbXG5cdFx0WzFdLFxuXHRcdFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcblx0XHRbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sXG5cdFx0WzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSxcblx0XHRbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxuXHRcdFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLFxuXHRcdFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLFxuXHRcdFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcblx0XHRbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sXG5cdFx0WzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSxcblx0XHRbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxuXHRcdFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLFxuXHRcdFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLFxuXHRcdFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcblx0XHRbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1cblx0XTtcblxuXHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRwb3cgPSBNYXRoLnBvdyxcblx0XHRsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMkU7XG5cdFx0fSxcblx0XHRFUFNJTE9OID0gMWUtMTIsXG5cdFx0TUFDSElORV9FUFNJTE9OID0gMS4xMmUtMTY7XG5cblx0ZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG5cdFx0cmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldERpc2NyaW1pbmFudChhLCBiLCBjKSB7XG5cdFx0ZnVuY3Rpb24gc3BsaXQodikge1xuXHRcdFx0dmFyIHggPSB2ICogMTM0MjE3NzI5LFxuXHRcdFx0XHR5ID0gdiAtIHgsXG5cdFx0XHRcdGhpID0geSArIHgsXG5cdFx0XHRcdGxvID0gdiAtIGhpO1xuXHRcdFx0cmV0dXJuIFtoaSwgbG9dO1xuXHRcdH1cblxuXHRcdHZhciBEID0gYiAqIGIgLSBhICogYyxcblx0XHRcdEUgPSBiICogYiArIGEgKiBjO1xuXHRcdGlmIChhYnMoRCkgKiAzIDwgRSkge1xuXHRcdFx0dmFyIGFkID0gc3BsaXQoYSksXG5cdFx0XHRcdGJkID0gc3BsaXQoYiksXG5cdFx0XHRcdGNkID0gc3BsaXQoYyksXG5cdFx0XHRcdHAgPSBiICogYixcblx0XHRcdFx0ZHAgPSAoYmRbMF0gKiBiZFswXSAtIHAgKyAyICogYmRbMF0gKiBiZFsxXSkgKyBiZFsxXSAqIGJkWzFdLFxuXHRcdFx0XHRxID0gYSAqIGMsXG5cdFx0XHRcdGRxID0gKGFkWzBdICogY2RbMF0gLSBxICsgYWRbMF0gKiBjZFsxXSArIGFkWzFdICogY2RbMF0pXG5cdFx0XHRcdFx0XHQrIGFkWzFdICogY2RbMV07XG5cdFx0XHREID0gKHAgLSBxKSArIChkcCAtIGRxKTtcblx0XHR9XG5cdFx0cmV0dXJuIEQ7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uRmFjdG9yKCkge1xuXHRcdHZhciBub3JtID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbm9ybSAmJiAobm9ybSA8IDFlLTggfHwgbm9ybSA+IDFlOClcblx0XHRcdFx0PyBwb3coMiwgLU1hdGgucm91bmQobG9nMihub3JtKSkpXG5cdFx0XHRcdDogMDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRNQUNISU5FX0VQU0lMT046IE1BQ0hJTkVfRVBTSUxPTixcblx0XHRDVVJWRVRJTUVfRVBTSUxPTjogMWUtOCxcblx0XHRHRU9NRVRSSUNfRVBTSUxPTjogMWUtNyxcblx0XHRUUklHT05PTUVUUklDX0VQU0lMT046IDFlLTgsXG5cdFx0S0FQUEE6IDQgKiAoc3FydCgyKSAtIDEpIC8gMyxcblxuXHRcdGlzWmVybzogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRyZXR1cm4gdmFsID49IC1FUFNJTE9OICYmIHZhbCA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRjbGFtcDogY2xhbXAsXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gKGIgLSBhKSAqIDAuNSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gbng7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGZ4ID4gMCkge1xuXHRcdFx0XHRcdGIgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA8PSBhID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA+PSBiID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2xhbXAoeCwgYSwgYik7XG5cdFx0fSxcblxuXHRcdHNvbHZlUXVhZHJhdGljOiBmdW5jdGlvbihhLCBiLCBjLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciB4MSwgeDIgPSBJbmZpbml0eTtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGlmIChhYnMoYikgPCBFUFNJTE9OKVxuXHRcdFx0XHRcdHJldHVybiBhYnMoYykgPCBFUFNJTE9OID8gLTEgOiAwO1xuXHRcdFx0XHR4MSA9IC1jIC8gYjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGIgKj0gLTAuNTtcblx0XHRcdFx0dmFyIEQgPSBnZXREaXNjcmltaW5hbnQoYSwgYiwgYyk7XG5cdFx0XHRcdGlmIChEICYmIGFicyhEKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRcdHZhciBmID0gZ2V0Tm9ybWFsaXphdGlvbkZhY3RvcihhYnMoYSksIGFicyhiKSwgYWJzKGMpKTtcblx0XHRcdFx0XHRpZiAoZikge1xuXHRcdFx0XHRcdFx0YSAqPSBmO1xuXHRcdFx0XHRcdFx0YiAqPSBmO1xuXHRcdFx0XHRcdFx0YyAqPSBmO1xuXHRcdFx0XHRcdFx0RCA9IGdldERpc2NyaW1pbmFudChhLCBiLCBjKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRcdHZhciBRID0gRCA8IDAgPyAwIDogc3FydChEKSxcblx0XHRcdFx0XHRcdFIgPSBiICsgKGIgPCAwID8gLVEgOiBRKTtcblx0XHRcdFx0XHRpZiAoUiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0eDEgPSBjIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gLXgxO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4MSA9IFIgLyBhO1xuXHRcdFx0XHRcdFx0eDIgPSBjIC8gUjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdGJvdW5kbGVzcyA9IG1pbiA9PSBudWxsLFxuXHRcdFx0XHRtaW5CID0gbWluIC0gRVBTSUxPTixcblx0XHRcdFx0bWF4QiA9IG1heCArIEVQU0lMT047XG5cdFx0XHRpZiAoaXNGaW5pdGUoeDEpICYmIChib3VuZGxlc3MgfHwgeDEgPiBtaW5CICYmIHgxIDwgbWF4QikpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geDEgOiBjbGFtcCh4MSwgbWluLCBtYXgpO1xuXHRcdFx0aWYgKHgyICE9PSB4MVxuXHRcdFx0XHRcdCYmIGlzRmluaXRlKHgyKSAmJiAoYm91bmRsZXNzIHx8IHgyID4gbWluQiAmJiB4MiA8IG1heEIpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IGJvdW5kbGVzcyA/IHgyIDogY2xhbXAoeDIsIG1pbiwgbWF4KTtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0c29sdmVDdWJpYzogZnVuY3Rpb24oYSwgYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgZiA9IGdldE5vcm1hbGl6YXRpb25GYWN0b3IoYWJzKGEpLCBhYnMoYiksIGFicyhjKSwgYWJzKGQpKSxcblx0XHRcdFx0eCwgYjEsIGMyLCBxZCwgcTtcblx0XHRcdGlmIChmKSB7XG5cdFx0XHRcdGEgKj0gZjtcblx0XHRcdFx0YiAqPSBmO1xuXHRcdFx0XHRjICo9IGY7XG5cdFx0XHRcdGQgKj0gZjtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZXZhbHVhdGUoeDApIHtcblx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHR2YXIgdG1wID0gYSAqIHg7XG5cdFx0XHRcdGIxID0gdG1wICsgYjtcblx0XHRcdFx0YzIgPSBiMSAqIHggKyBjO1xuXHRcdFx0XHRxZCA9ICh0bXAgKyBiMSkgKiB4ICsgYzI7XG5cdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRhID0gYjtcblx0XHRcdFx0YjEgPSBjO1xuXHRcdFx0XHRjMiA9IGQ7XG5cdFx0XHRcdHggPSBJbmZpbml0eTtcblx0XHRcdH0gZWxzZSBpZiAoYWJzKGQpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRiMSA9IGI7XG5cdFx0XHRcdGMyID0gYztcblx0XHRcdFx0eCA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRldmFsdWF0ZSgtKGIgLyBhKSAvIDMpO1xuXHRcdFx0XHR2YXIgdCA9IHEgLyBhLFxuXHRcdFx0XHRcdHIgPSBwb3coYWJzKHQpLCAxLzMpLFxuXHRcdFx0XHRcdHMgPSB0IDwgMCA/IC0xIDogMSxcblx0XHRcdFx0XHR0ZCA9IC1xZCAvIGEsXG5cdFx0XHRcdFx0cmQgPSB0ZCA+IDAgPyAxLjMyNDcxNzk1NzI0NDc0NiAqIE1hdGgubWF4KHIsIHNxcnQodGQpKSA6IHIsXG5cdFx0XHRcdFx0eDAgPSB4IC0gcyAqIHJkO1xuXHRcdFx0XHRpZiAoeDAgIT09IHgpIHtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRldmFsdWF0ZSh4MCk7XG5cdFx0XHRcdFx0XHR4MCA9IHFkID09PSAwID8geCA6IHggLSBxIC8gcWQgLyAoMSArIE1BQ0hJTkVfRVBTSUxPTik7XG5cdFx0XHRcdFx0fSB3aGlsZSAocyAqIHgwID4gcyAqIHgpO1xuXHRcdFx0XHRcdGlmIChhYnMoYSkgKiB4ICogeCA+IGFicyhkIC8geCkpIHtcblx0XHRcdFx0XHRcdGMyID0gLWQgLyB4O1xuXHRcdFx0XHRcdFx0YjEgPSAoYzIgLSBjKSAvIHg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYjEsIGMyLCByb290cywgbWluLCBtYXgpLFxuXHRcdFx0XHRib3VuZGxlc3MgPSBtaW4gPT0gbnVsbDtcblx0XHRcdGlmIChpc0Zpbml0ZSh4KSAmJiAoY291bnQgPT09IDBcblx0XHRcdFx0XHR8fCBjb3VudCA+IDAgJiYgeCAhPT0gcm9vdHNbMF0gJiYgeCAhPT0gcm9vdHNbMV0pXG5cdFx0XHRcdFx0JiYgKGJvdW5kbGVzcyB8fCB4ID4gbWluIC0gRVBTSUxPTiAmJiB4IDwgbWF4ICsgRVBTSUxPTikpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gYm91bmRsZXNzID8geCA6IGNsYW1wKHgsIG1pbiwgbWF4KTtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgVUlEID0ge1xuXHRfaWQ6IDEsXG5cdF9wb29sczoge30sXG5cblx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0aWYgKG5hbWUpIHtcblx0XHRcdHZhciBwb29sID0gdGhpcy5fcG9vbHNbbmFtZV07XG5cdFx0XHRpZiAoIXBvb2wpXG5cdFx0XHRcdHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXSA9IHsgX2lkOiAxIH07XG5cdFx0XHRyZXR1cm4gcG9vbC5faWQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2lkKys7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgUG9pbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50Jyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludChhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLl9zZXQoYXJnMCwgaGFzWSA/IGFyZzEgOiBhcmcwKTtcblx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRyZWFkID0gaGFzWSA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fc2V0KDAsIDApO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvYmogPSB0eXBlID09PSAnc3RyaW5nJyA/IGFyZzAuc3BsaXQoL1tcXHMsXSsvKSB8fCBbXSA6IGFyZzA7XG5cdFx0XHRyZWFkID0gMTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0dGhpcy5fc2V0KCtvYmpbMF0sICsob2JqLmxlbmd0aCA+IDEgPyBvYmpbMV0gOiBvYmpbMF0pKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3gnIGluIG9iaikge1xuXHRcdFx0XHR0aGlzLl9zZXQob2JqLnggfHwgMCwgb2JqLnkgfHwgMCk7XG5cdFx0XHR9IGVsc2UgaWYgKCd3aWR0aCcgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoud2lkdGggfHwgMCwgb2JqLmhlaWdodCB8fCAwKTtcblx0XHRcdH0gZWxzZSBpZiAoJ2FuZ2xlJyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai5sZW5ndGggfHwgMCwgMCk7XG5cdFx0XHRcdHRoaXMuc2V0QW5nbGUob2JqLmFuZ2xlIHx8IDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2V0KDAsIDApO1xuXHRcdFx0XHRyZWFkID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0OiAnI2luaXRpYWxpemUnLFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuXHRcdFx0XHQmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueVxuXHRcdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblx0XHRcdHRoaXMuX3NldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IGxlbmd0aCAvIHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhzY2FsZSkpXG5cdFx0XHRcdHRoaXMuZ2V0QW5nbGUoKTtcblx0XHRcdHRoaXMuX3NldChcblx0XHRcdFx0dGhpcy54ICogc2NhbGUsXG5cdFx0XHRcdHRoaXMueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblx0Z2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXHR9LFxuXG5cdGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcblx0c2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuXG5cdGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9hbmdsZSB8fCAwXG5cdFx0XHRcdFx0OiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuX3NldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZClcblx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuXHRcdFx0c2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG5cdFx0XHRwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuXHRcdGlmIChzY2FsZSA+PSAwKVxuXHRcdFx0cG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuXHRcdGlmIChhbmdsZSA9PT0gMClcblx0XHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdFx0YW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRwb2ludCA9IG5ldyBQb2ludChcblx0XHRcdHBvaW50LnggKiBjb3MgLSBwb2ludC55ICogc2luLFxuXHRcdFx0cG9pbnQueCAqIHNpbiArIHBvaW50LnkgKiBjb3Ncblx0XHQpO1xuXHRcdHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR0b2xlcmFuY2UgPSBCYXNlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPD0gdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRpc0NvbGluZWFyOiAnI2lzQ29sbGluZWFyJyxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMueCwgdGhpcy55LCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiBpc1plcm8odGhpcy54KSAmJiBpc1plcm8odGhpcy55KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMueCkgfHwgaXNOYU4odGhpcy55KTtcblx0fSxcblxuXHRpc0luUXVhZHJhbnQ6IGZ1bmN0aW9uKHEpIHtcblx0XHRyZXR1cm4gdGhpcy54ICogKHEgPiAxICYmIHEgPCA0ID8gLTEgOiAxKSA+PSAwXG5cdFx0XHQmJiB0aGlzLnkgKiAocSA+IDIgPyAtMSA6IDEpID49IDA7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHNjYWxlID0gcG9pbnQuaXNaZXJvKCkgPyAwIDogdGhpcy5kb3QocG9pbnQpIC8gcG9pbnQuZG90KHBvaW50KTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIHNjYWxlLFxuXHRcdFx0cG9pbnQueSAqIHNjYWxlXG5cdFx0KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9LFxuXG5cdFx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB5MiAtIHkxICogeDIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS04O1xuXHRcdH0sXG5cblx0XHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB4MiArIHkxICogeTIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS04O1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBvcCA9IE1hdGhba2V5XTtcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldFk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl95O1xuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhISh0aGlzLl9vd25lci5fc2VsZWN0aW9uICYgdGhpcy5fZ2V0U2VsZWN0aW9uKCkpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VTZWxlY3Rpb24odGhpcy5fZ2V0U2VsZWN0aW9uKCksIHNlbGVjdGVkKTtcblx0fSxcblxuXHRfZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0dGVyID09PSAnc2V0UG9zaXRpb24nID8gNCA6IDA7XG5cdH1cbn0pO1xuXG52YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2l6ZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWRpbmcgPSB0aGlzLl9fcmVhZCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMuX3NldChhcmcwLCBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMCk7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0cmVhZCA9IGhhc0hlaWdodCA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fc2V0KDAsIDApO1xuXHRcdFx0aWYgKHJlYWRpbmcpXG5cdFx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBvYmogPSB0eXBlID09PSAnc3RyaW5nJyA/IGFyZzAuc3BsaXQoL1tcXHMsXSsvKSB8fCBbXSA6IGFyZzA7XG5cdFx0XHRyZWFkID0gMTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0dGhpcy5fc2V0KCtvYmpbMF0sICsob2JqLmxlbmd0aCA+IDEgPyBvYmpbMV0gOiBvYmpbMF0pKTtcblx0XHRcdH0gZWxzZSBpZiAoJ3dpZHRoJyBpbiBvYmopIHtcblx0XHRcdFx0dGhpcy5fc2V0KG9iai53aWR0aCB8fCAwLCBvYmouaGVpZ2h0IHx8IDApO1xuXHRcdFx0fSBlbHNlIGlmICgneCcgaW4gb2JqKSB7XG5cdFx0XHRcdHRoaXMuX3NldChvYmoueCB8fCAwLCBvYmoueSB8fCAwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NldCgwLCAwKTtcblx0XHRcdFx0cmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0cmV0dXJuIGlzWmVybyh0aGlzLndpZHRoKSAmJiBpc1plcm8odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciBvcCA9IE1hdGhba2V5XTtcblx0dGhpc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl93aWR0aDtcblx0fSxcblxuXHRzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgUmVjdGFuZ2xlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSZWN0YW5nbGUnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSZWN0YW5nbGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzAsXG5cdFx0XHRyZWFkO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy5fc2V0KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9zZXQoMCwgMCwgMCwgMCk7XG5cdFx0XHRyZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy5fc2V0LmFwcGx5KHRoaXMsIGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9PSB1bmRlZmluZWQgfHwgYXJnMC53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3NldChhcmcwLnggfHwgMCwgYXJnMC55IHx8IDAsXG5cdFx0XHRcdFx0XHRhcmcwLndpZHRoIHx8IDAsIGFyZzAuaGVpZ2h0IHx8IDApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5mcm9tID09PSB1bmRlZmluZWQgJiYgYXJnMC50byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX3NldCgwLCAwLCAwLCAwKTtcblx0XHRcdFx0QmFzZS5maWx0ZXIodGhpcywgYXJnMCk7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAocmVhZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgZnJtID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0bmV4dCA9IEJhc2UucGVlayhhcmd1bWVudHMpLFxuXHRcdFx0XHR4ID0gZnJtLngsXG5cdFx0XHRcdHkgPSBmcm0ueSxcblx0XHRcdFx0d2lkdGgsXG5cdFx0XHRcdGhlaWdodDtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgQmFzZS5oYXNOYW1lZChhcmd1bWVudHMsICd0bycpKSB7XG5cdFx0XHRcdHZhciB0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpO1xuXHRcdFx0XHR3aWR0aCA9IHRvLnggLSB4O1xuXHRcdFx0XHRoZWlnaHQgPSB0by55IC0geTtcblx0XHRcdFx0aWYgKHdpZHRoIDwgMCkge1xuXHRcdFx0XHRcdHggPSB0by54O1xuXHRcdFx0XHRcdHdpZHRoID0gLXdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0eSA9IHRvLnk7XG5cdFx0XHRcdFx0aGVpZ2h0ID0gLWhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHJlYWQgPSBhcmd1bWVudHMuX19pbmRleDtcblx0XHRcdHZhciBmaWx0ZXJlZCA9IGFyZ3VtZW50cy5fX2ZpbHRlcmVkO1xuXHRcdFx0aWYgKGZpbHRlcmVkKVxuXHRcdFx0XHR0aGlzLl9fZmlsdGVyZWQgPSBmaWx0ZXJlZDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuXHRcdFx0XHQ/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0OiByZWN0O1xuXHRcdHJldHVybiBydCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55XG5cdFx0XHRcdFx0JiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpXG5cdFx0XHRcdCsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcblx0XHRcdFx0KyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpXG5cdFx0XHRcdCsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMueSksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRfZnc6IDEsXG5cdF9maDogMSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0c3ggPSB0aGlzLl9zeCxcblx0XHRcdHN5ID0gdGhpcy5fc3ksXG5cdFx0XHR3ID0gc2l6ZS53aWR0aCxcblx0XHRcdGggPSBzaXplLmhlaWdodDtcblx0XHRpZiAoc3gpIHtcblx0XHRcdHRoaXMueCArPSAodGhpcy53aWR0aCAtIHcpICogc3g7XG5cdFx0fVxuXHRcdGlmIChzeSkge1xuXHRcdFx0dGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIGgpICogc3k7XG5cdFx0fVxuXHRcdHRoaXMud2lkdGggPSB3O1xuXHRcdHRoaXMuaGVpZ2h0ID0gaDtcblx0XHR0aGlzLl9mdyA9IHRoaXMuX2ZoID0gMTtcblx0fSxcblxuXHRnZXRMZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9LFxuXG5cdHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcblx0XHRpZiAoIXRoaXMuX2Z3KSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gbGVmdCAtIHRoaXMueDtcblx0XHRcdHRoaXMud2lkdGggLT0gdGhpcy5fc3ggPT09IDAuNSA/IGFtb3VudCAqIDIgOiBhbW91bnQ7XG5cdFx0fVxuXHRcdHRoaXMueCA9IGxlZnQ7XG5cdFx0dGhpcy5fc3ggPSB0aGlzLl9mdyA9IDA7XG5cdH0sXG5cblx0Z2V0VG9wOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55O1xuXHR9LFxuXG5cdHNldFRvcDogZnVuY3Rpb24odG9wKSB7XG5cdFx0aWYgKCF0aGlzLl9maCkge1xuXHRcdFx0dmFyIGFtb3VudCA9IHRvcCAtIHRoaXMueTtcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRoaXMuX3N5ID09PSAwLjUgPyBhbW91bnQgKiAyIDogYW1vdW50O1xuXHRcdH1cblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fc3kgPSB0aGlzLl9maCA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICghdGhpcy5fZncpIHtcblx0XHRcdHZhciBhbW91bnQgPSByaWdodCAtIHRoaXMueDtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLl9zeCA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdHRoaXMuX3N4ID0gMTtcblx0XHR0aGlzLl9mdyA9IDA7XG5cdH0sXG5cblx0Z2V0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0c2V0Qm90dG9tOiBmdW5jdGlvbihib3R0b20pIHtcblx0XHRpZiAoIXRoaXMuX2ZoKSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gYm90dG9tIC0gdGhpcy55O1xuXHRcdFx0dGhpcy5oZWlnaHQgPSB0aGlzLl9zeSA9PT0gMC41ID8gYW1vdW50ICogMiA6IGFtb3VudDtcblx0XHR9XG5cdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0dGhpcy5fc3kgPSAxO1xuXHRcdHRoaXMuX2ZoID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXJYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdGlmICh0aGlzLl9mdyB8fCB0aGlzLl9zeCA9PT0gMC41KSB7XG5cdFx0XHR0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLl9zeCkge1xuXHRcdFx0XHR0aGlzLnggKz0gKHggLSB0aGlzLngpICogMiAqIHRoaXMuX3N4O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy53aWR0aCA9ICh4IC0gdGhpcy54KSAqIDI7XG5cdFx0fVxuXHRcdHRoaXMuX3N4ID0gMC41O1xuXHRcdHRoaXMuX2Z3ID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXJZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHRpZiAodGhpcy5fZmggfHwgdGhpcy5fc3kgPT09IDAuNSkge1xuXHRcdFx0dGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuX3N5KSB7XG5cdFx0XHRcdHRoaXMueSArPSAoeSAtIHRoaXMueSkgKiAyICogdGhpcy5fc3k7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmhlaWdodCA9ICh5IC0gdGhpcy55KSAqIDI7XG5cdFx0fVxuXHRcdHRoaXMuX3N5ID0gMC41O1xuXHRcdHRoaXMuX2ZoID0gMDtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQ/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHRcdDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeCA9IHJlY3QueCxcblx0XHRcdHkgPSByZWN0Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGVwc2lsb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSB8fCAwO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54IC0gZXBzaWxvblxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueSAtIGVwc2lsb25cblx0XHRcdFx0JiYgcmVjdC54IDwgdGhpcy54ICsgdGhpcy53aWR0aCArIGVwc2lsb25cblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQgKyBlcHNpbG9uO1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyksXG5cdFx0XHR4Rmlyc3QgPSAvXltSTF0vLnRlc3QocGFydCk7XG5cdFx0aWYgKGluZGV4ID49IDQpXG5cdFx0XHRwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG5cdFx0dmFyIHggPSBwYXJ0c1t4Rmlyc3QgPyAwIDogMV0sXG5cdFx0XHR5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuXHRcdFx0Z2V0WCA9ICdnZXQnICsgeCxcblx0XHRcdGdldFkgPSAnZ2V0JyArIHksXG5cdFx0XHRzZXRYID0gJ3NldCcgKyB4LFxuXHRcdFx0c2V0WSA9ICdzZXQnICsgeSxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydCxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydDtcblx0XHR0aGlzW2dldF0gPSBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcblx0XHR9O1xuXHRcdHRoaXNbc2V0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpc1tzZXRYXShwb2ludC54KTtcblx0XHRcdHRoaXNbc2V0WV0ocG9pbnQueSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH1cbikpO1xuXG52YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGludGVybmFsID0gJ18nICsga2V5O1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuXHRcdH07XG5cblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpc1tpbnRlcm5hbF0gPSB2YWx1ZTtcblx0XHRcdGlmICghdGhpcy5fZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHR9O1xuXHR9LCBCYXNlLmVhY2goWydQb2ludCcsICdTaXplJywgJ0NlbnRlcicsXG5cdFx0XHQnTGVmdCcsICdUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0NlbnRlclgnLCAnQ2VudGVyWScsXG5cdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXSxcblx0XHRmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciBuYW1lID0gJ3NldCcgKyBrZXk7XG5cdFx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSB0cnVlO1xuXHRcdFx0XHRwcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIDIpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdFx0XHRpZiAob3duZXIuX2NoYW5nZVNlbGVjdGlvbikge1xuXHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VTZWxlY3Rpb24oMiwgc2VsZWN0ZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0KTtcbn0pO1xuXG52YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdNYXRyaXgnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdG9rID0gdHJ1ZTtcblx0XHRpZiAoY291bnQgPj0gNikge1xuXHRcdFx0dGhpcy5fc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSB8fCBjb3VudCA9PT0gMikge1xuXHRcdFx0aWYgKGFyZyBpbnN0YW5jZW9mIE1hdHJpeCkge1xuXHRcdFx0XHR0aGlzLl9zZXQoYXJnLl9hLCBhcmcuX2IsIGFyZy5fYywgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5LFxuXHRcdFx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0dGhpcy5fc2V0LmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRfZG9udE5vdGlmeSA/IGFyZy5jb25jYXQoW19kb250Tm90aWZ5XSkgOiBhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFjb3VudCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIW9rKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRfc2V0OiBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fYyA9IGM7XG5cdFx0dGhpcy5fZCA9IGQ7XG5cdFx0dGhpcy5fdHggPSB0eDtcblx0XHR0aGlzLl90eSA9IHR5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG93bmVyLl9jaGFuZ2VkKDI1KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsXG5cdFx0XHRcdHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYlxuXHRcdFx0XHQmJiB0aGlzLl9jID09PSBteC5fYyAmJiB0aGlzLl9kID09PSBteC5fZFxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gbXguX3R4ICYmIHRoaXMuX3R5ID09PSBteC5fdHk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9jKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eCldLmpvaW4oJywgJykgKyAnXSwgWydcblx0XHRcdFx0KyBbZi5udW1iZXIodGhpcy5fYiksIGYubnVtYmVyKHRoaXMuX2QpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R5KV0uam9pbignLCAnKSArICddXSc7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuXHRcdHRoaXMuX2IgPSB0aGlzLl9jID0gdGhpcy5fdHggPSB0aGlzLl90eSA9IDA7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBseTogZnVuY3Rpb24ocmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUsIEJhc2UucGljayhyZWN1cnNpdmVseSwgdHJ1ZSksXG5cdFx0XHRcdFx0X3NldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9iICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYztcblx0XHR0aGlzLl9iID0gY29zICogYiArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fYyA9IC1zaW4gKiBhICsgY29zICogYztcblx0XHR0aGlzLl9kID0gLXNpbiAqIGIgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYztcblx0XHR0aGlzLl90eSArPSB0eCAqIGIgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYjtcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9jO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYyArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBiO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2tldyA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24obXgsIF9kb250Tm90aWZ5KSB7XG5cdFx0aWYgKG14KSB7XG5cdFx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0XHRiMiA9IG14Ll9jLFxuXHRcdFx0XHRjMiA9IG14Ll9iLFxuXHRcdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBjMTtcblx0XHRcdHRoaXMuX2MgPSBiMiAqIGExICsgZDIgKiBjMTtcblx0XHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYzIgKiBkMTtcblx0XHRcdHRoaXMuX2QgPSBiMiAqIGIxICsgZDIgKiBkMTtcblx0XHRcdHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYzE7XG5cdFx0XHR0aGlzLl90eSArPSB0eDIgKiBiMSArIHR5MiAqIGQxO1xuXHRcdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbihteCwgX2RvbnROb3RpZnkpIHtcblx0XHRpZiAobXgpIHtcblx0XHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdFx0YjIgPSBteC5fYyxcblx0XHRcdFx0YzIgPSBteC5fYixcblx0XHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYjE7XG5cdFx0XHR0aGlzLl9jID0gYTIgKiBjMSArIGIyICogZDE7XG5cdFx0XHR0aGlzLl9iID0gYzIgKiBhMSArIGQyICogYjE7XG5cdFx0XHR0aGlzLl9kID0gYzIgKiBjMSArIGQyICogZDE7XG5cdFx0XHR0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG5cdFx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGVuZGVkOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuYXBwZW5kKG14KTtcblx0fSxcblxuXHRwcmVwZW5kZWQ6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5wcmVwZW5kKG14KTtcblx0fSxcblxuXHRpbnZlcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZCxcblx0XHRcdHR4ID0gdGhpcy5fdHgsXG5cdFx0XHR0eSA9IHRoaXMuX3R5LFxuXHRcdFx0ZGV0ID0gYSAqIGQgLSBiICogYyxcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0eCkgJiYgaXNGaW5pdGUodHkpKSB7XG5cdFx0XHR0aGlzLl9hID0gZCAvIGRldDtcblx0XHRcdHRoaXMuX2IgPSAtYiAvIGRldDtcblx0XHRcdHRoaXMuX2MgPSAtYyAvIGRldDtcblx0XHRcdHRoaXMuX2QgPSBhIC8gZGV0O1xuXHRcdFx0dGhpcy5fdHggPSAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldDtcblx0XHRcdHRoaXMuX3R5ID0gKGIgKiB0eCAtIGEgKiB0eSkgLyBkZXQ7XG5cdFx0XHRyZXMgPSB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmludmVydCgpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiAnI2FwcGVuZCcsXG5cdHByZUNvbmNhdGVuYXRlOiAnI3ByZXBlbmQnLFxuXHRjaGFpbjogJyNhcHBlbmRlZCcsXG5cblx0X3NoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0X29yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYyAqIHRoaXMuX2I7XG5cdFx0cmV0dXJuIGRldCAmJiAhaXNOYU4oZGV0KSAmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5pc0ludmVydGlibGUoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIGRzdCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQoXG5cdFx0XHRcdHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eCxcblx0XHRcdFx0eCAqIHRoaXMuX2IgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbWF4ID0gMiAqIGNvdW50OyBpIDwgbWF4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gc3JjW2ldLFxuXHRcdFx0XHR5ID0gc3JjW2kgKyAxXTtcblx0XHRcdGRzdFtpXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2MgKyB0aGlzLl90eDtcblx0XHRcdGRzdFtpICsgMV0gPSB4ICogdGhpcy5fYiArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pIHtcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwgPiBtYXhbal0pIHtcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0Ll9zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0aW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kLFxuXHRcdFx0dHggPSB0aGlzLl90eCxcblx0XHRcdHR5ID0gdGhpcy5fdHksXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAoZGV0ICYmICFpc05hTihkZXQpICYmIGlzRmluaXRlKHR4KSAmJiBpc0Zpbml0ZSh0eSkpIHtcblx0XHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuXHRcdFx0aWYgKCFkZXN0KVxuXHRcdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0XHRyZXMgPSBkZXN0Ll9zZXQoXG5cdFx0XHRcdFx0KHggKiBkIC0geSAqIGMpIC8gZGV0LFxuXHRcdFx0XHRcdCh5ICogYSAtIHggKiBiKSAvIGRldCxcblx0XHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2QsXG5cdFx0XHRkZXQgPSBhICogZCAtIGIgKiBjLFxuXHRcdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRcdGF0YW4yID0gTWF0aC5hdGFuMixcblx0XHRcdGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJLFxuXHRcdFx0cm90YXRlLFxuXHRcdFx0c2NhbGUsXG5cdFx0XHRza2V3O1xuXHRcdGlmIChhICE9PSAwIHx8IGIgIT09IDApIHtcblx0XHRcdHZhciByID0gc3FydChhICogYSArIGIgKiBiKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYWNvcyhhIC8gcikgKiAoYiA+IDAgPyAxIDogLTEpO1xuXHRcdFx0c2NhbGUgPSBbciwgZGV0IC8gcl07XG5cdFx0XHRza2V3ID0gW2F0YW4yKGEgKiBjICsgYiAqIGQsIHIgKiByKSwgMF07XG5cdFx0fSBlbHNlIGlmIChjICE9PSAwIHx8IGQgIT09IDApIHtcblx0XHRcdHZhciBzID0gc3FydChjICogYyArIGQgKiBkKTtcblx0XHRcdHJvdGF0ZSA9IE1hdGguYXNpbihjIC8gcykgICogKGQgPiAwID8gMSA6IC0xKTtcblx0XHRcdHNjYWxlID0gW2RldCAvIHMsIHNdO1xuXHRcdFx0c2tldyA9IFswLCBhdGFuMihhICogYyArIGIgKiBkLCBzICogcyldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyb3RhdGUgPSAwO1xuXHRcdFx0c2tldyA9IHNjYWxlID0gWzAsIDBdO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHJhbnNsYXRpb246IHRoaXMuZ2V0VHJhbnNsYXRpb24oKSxcblx0XHRcdHJvdGF0aW9uOiByb3RhdGUgKiBkZWdyZWVzLFxuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlKSxcblx0XHRcdHNrZXdpbmc6IG5ldyBQb2ludChza2V3WzBdICogZGVncmVlcywgc2tld1sxXSAqIGRlZ3JlZXMpXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2IsIHRoaXMuX2MsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkuc2NhbGluZztcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkucm90YXRpb247XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5pc0lkZW50aXR5KCkpIHtcblx0XHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYiwgdGhpcy5fYywgdGhpcy5fZCxcblx0XHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdiJywgJ2MnLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRwcm9wID0gJ18nICsga2V5O1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuZ2V0U2lnbmVkRGlzdGFuY2UocG9pbnQpKTtcblx0fSxcblxuXHRnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWduZWREaXN0YW5jZSh0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24obGluZSkge1xuXHRcdHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy5fdngsIHRoaXMuX3Z5LCBsaW5lLl92eCwgbGluZS5fdnkpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHAxeCwgcDF5LCB2MXgsIHYxeSwgcDJ4LCBwMnksIHYyeCwgdjJ5LCBhc1ZlY3Rvcixcblx0XHRcdFx0aXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2MXggLT0gcDF4O1xuXHRcdFx0XHR2MXkgLT0gcDF5O1xuXHRcdFx0XHR2MnggLT0gcDJ4O1xuXHRcdFx0XHR2MnkgLT0gcDJ5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGNyb3NzID0gdjF4ICogdjJ5IC0gdjF5ICogdjJ4O1xuXHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKGNyb3NzKSkge1xuXHRcdFx0XHR2YXIgZHggPSBwMXggLSBwMngsXG5cdFx0XHRcdFx0ZHkgPSBwMXkgLSBwMnksXG5cdFx0XHRcdFx0dTEgPSAodjJ4ICogZHkgLSB2MnkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHR1MiA9ICh2MXggKiBkeSAtIHYxeSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0XHR1TWluID0gLWVwc2lsb24sXG5cdFx0XHRcdFx0dU1heCA9IDEgKyBlcHNpbG9uO1xuXHRcdFx0XHRpZiAoaXNJbmZpbml0ZVxuXHRcdFx0XHRcdFx0fHwgdU1pbiA8IHUxICYmIHUxIDwgdU1heCAmJiB1TWluIDwgdTIgJiYgdTIgPCB1TWF4KSB7XG5cdFx0XHRcdFx0aWYgKCFpc0luZmluaXRlKSB7XG5cdFx0XHRcdFx0XHR1MSA9IHUxIDw9IDAgPyAwIDogdTEgPj0gMSA/IDEgOiB1MTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0cDF4ICsgdTEgKiB2MXgsXG5cdFx0XHRcdFx0XHRcdHAxeSArIHUxICogdjF5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTaWRlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IsIGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHYyeCA9IHggLSBweCxcblx0XHRcdFx0djJ5ID0geSAtIHB5LFxuXHRcdFx0XHRjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4O1xuXHRcdFx0aWYgKCFpc0luZmluaXRlICYmIE51bWVyaWNhbC5pc1plcm8oY2N3KSkge1xuXHRcdFx0XHRjY3cgPSAodjJ4ICogdnggKyB2MnggKiB2eCkgLyAodnggKiB2eCArIHZ5ICogdnkpO1xuXHRcdFx0XHRpZiAoY2N3ID49IDAgJiYgY2N3IDw9IDEpXG5cdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjY3cgPCAwID8gLTEgOiBjY3cgPiAwID8gMSA6IDA7XG5cdFx0fSxcblxuXHRcdGdldFNpZ25lZERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZ4ID09PSAwID8gdnkgPiAwID8geCAtIHB4IDogcHggLSB4XG5cdFx0XHRcdCA6IHZ5ID09PSAwID8gdnggPCAwID8geSAtIHB5IDogcHkgLSB5XG5cdFx0XHRcdCA6ICgoeC1weCkgKiB2eSAtICh5LXB5KSAqIHZ4KSAvIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0fSxcblxuXHRcdGdldERpc3RhbmNlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyhcblx0XHRcdFx0XHRMaW5lLmdldFNpZ25lZERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvcikpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBQcm9qZWN0ID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUHJvamVjdCcsXG5cdF9saXN0OiAncHJvamVjdHMnLFxuXHRfcmVmZXJlbmNlOiAncHJvamVjdCcsXG5cdF9jb21wYWN0U2VyaWFsaXplOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFByb2plY3QoZWxlbWVudCkge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGlvbkl0ZW1zID0ge307XG5cdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQgPSAwO1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSAwO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5fY2hpbGRyZW4sIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncywgaXRlbSkge1xuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHZhciB2aWV3ID0gdGhpcy5fdmlldztcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHZpZXcuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCF2aWV3Ll9yZXF1ZXN0ZWQgJiYgdmlldy5fYXV0b1VwZGF0ZSlcblx0XHRcdFx0XHR2aWV3LnJlcXVlc3RVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzO1xuXHRcdGlmIChjaGFuZ2VzICYmIGl0ZW0pIHtcblx0XHRcdHZhciBjaGFuZ2VzQnlJZCA9IHRoaXMuX2NoYW5nZXNCeUlkLFxuXHRcdFx0XHRpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0XHRlbnRyeSA9IGNoYW5nZXNCeUlkW2lkXTtcblx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYW5nZXMucHVzaChjaGFuZ2VzQnlJZFtpZF0gPSB7IGl0ZW06IGl0ZW0sIGZsYWdzOiBmbGFncyB9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdGNoaWxkcmVuW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdGlmICghcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5fdmlldylcblx0XHRcdHRoaXMuX3ZpZXcucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudFN0eWxlO1xuXHR9LFxuXG5cdHNldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR0aGlzLl9jdXJyZW50U3R5bGUuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMsIGluc2VydDogdHJ1ZSB9KTtcblx0fSxcblxuXHRnZXRTeW1ib2xEZWZpbml0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlZmluaXRpb25zID0gW10sXG5cdFx0XHRpZHMgPSB7fTtcblx0XHR0aGlzLmdldEl0ZW1zKHtcblx0XHRcdGNsYXNzOiBTeW1ib2xJdGVtLFxuXHRcdFx0bWF0Y2g6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdFx0dmFyIGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuXHRcdFx0XHRcdGlkID0gZGVmaW5pdGlvbi5faWQ7XG5cdFx0XHRcdGlmICghaWRzW2lkXSkge1xuXHRcdFx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0XHRcdGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBkZWZpbml0aW9ucztcblx0fSxcblxuXHRnZXRTeW1ib2xzOiAnZ2V0U3ltYm9sRGVmaW5pdGlvbnMnLFxuXG5cdGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zLFxuXHRcdFx0aXRlbXMgPSBbXTtcblx0XHRmb3IgKHZhciBpZCBpbiBzZWxlY3Rpb25JdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzZWxlY3Rpb25JdGVtc1tpZF0sXG5cdFx0XHRcdHNlbGVjdGlvbiA9IGl0ZW0uX3NlbGVjdGlvbjtcblx0XHRcdGlmICgoc2VsZWN0aW9uICYgMSkgJiYgaXRlbS5pc0luc2VydGVkKCkpIHtcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoIXNlbGVjdGlvbikge1xuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3Rpb25JdGVtcyA9IHRoaXMuX3NlbGVjdGlvbkl0ZW1zO1xuXHRcdGlmIChpdGVtLl9zZWxlY3Rpb24pIHtcblx0XHRcdGlmIChzZWxlY3Rpb25JdGVtc1tpZF0gIT09IGl0ZW0pIHtcblx0XHRcdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQrKztcblx0XHRcdFx0c2VsZWN0aW9uSXRlbXNbaWRdID0gaXRlbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGlvbkl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3Rpb25JdGVtc1tpZF07XG5cdFx0fVxuXHR9LFxuXG5cdHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGRlc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0aW9uSXRlbXMgPSB0aGlzLl9zZWxlY3Rpb25JdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGlvbkl0ZW1zKVxuXHRcdFx0c2VsZWN0aW9uSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG5cdH0sXG5cblx0YWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0TGF5ZXIodW5kZWZpbmVkLCBsYXllcik7XG5cdH0sXG5cblx0aW5zZXJ0TGF5ZXI6IGZ1bmN0aW9uKGluZGV4LCBsYXllcikge1xuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIExheWVyKSB7XG5cdFx0XHRsYXllci5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBbbGF5ZXJdLCBpbmRleCwgMCk7XG5cdFx0XHRsYXllci5fc2V0UHJvamVjdCh0aGlzLCB0cnVlKTtcblx0XHRcdHZhciBuYW1lID0gbGF5ZXIuX25hbWU7XG5cdFx0XHRpZiAobmFtZSlcblx0XHRcdFx0bGF5ZXIuc2V0TmFtZShuYW1lKTtcblx0XHRcdGlmICh0aGlzLl9jaGFuZ2VzKVxuXHRcdFx0XHRsYXllci5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gbGF5ZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGxheWVyO1xuXHR9LFxuXG5cdF9pbnNlcnRJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX2NyZWF0ZWQpIHtcblx0XHRpdGVtID0gdGhpcy5pbnNlcnRMYXllcihpbmRleCwgaXRlbSlcblx0XHRcdFx0fHwgKHRoaXMuX2FjdGl2ZUxheWVyIHx8IHRoaXMuX2luc2VydEl0ZW0odW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0bmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSwgdHJ1ZSkpXG5cdFx0XHRcdFx0XHQuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0pO1xuXHRcdGlmIChfY3JlYXRlZCAmJiBpdGVtLmFjdGl2YXRlKVxuXHRcdFx0aXRlbS5hY3RpdmF0ZSgpO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcywgb3B0aW9ucywgbnVsbCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2FjdGl2ZUxheWVyO1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgbGF5ZXIgJiYgbGF5ZXIuaXNFbXB0eSgpICYmIGxheWVyKTtcblx0fSxcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24odHlwZSkge1xuXHRcdHZhciBzZXRzID0gdGhpcy5fcmVtb3ZlU2V0cztcblx0XHRpZiAoc2V0cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXVwJylcblx0XHRcdFx0c2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuXHRcdFx0dmFyIHNldCA9IHNldHNbdHlwZV07XG5cdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHNldCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gc2V0W2lkXTtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyID0gc2V0c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyICYmIG90aGVyICE9IHNldClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRzW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uKys7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0XHRvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcblx0XHRcdFx0cGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcblx0XHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRcdG1hdHJpY2VzOiBbbmV3IE1hdHJpeCgpXSxcblx0XHRcdFx0dXBkYXRlTWF0cml4OiB0cnVlXG5cdFx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHR9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3Rpb25Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0aW9uSXRlbXMsXG5cdFx0XHRcdHNpemUgPSB0aGlzLl9zY29wZS5zZXR0aW5ncy5oYW5kbGVTaXplLFxuXHRcdFx0XHR2ZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbjtcblx0XHRcdGZvciAodmFyIGlkIGluIGl0ZW1zKSB7XG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0c3RhdGljczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuXHRcdFx0aWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKVxuXHRcdFx0XHRzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IEJhc2Uuc2V0KHt9LFxuXHRcdFx0XHRcdHRoaXMucHJvdG90eXBlLl9zZXJpYWxpemVGaWVsZHMsIHNyYy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRcdHJldHVybiBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHROT19JTlNFUlQ6IHsgaW5zZXJ0OiBmYWxzZSB9XG5cdH0sXG5cblx0X2NsYXNzOiAnSXRlbScsXG5cdF9uYW1lOiBudWxsLFxuXHRfYXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcblx0X2NhblNjYWxlU3Ryb2tlOiBmYWxzZSxcblx0X3Bpdm90OiBudWxsLFxuXHRfdmlzaWJsZTogdHJ1ZSxcblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cdF9vcGFjaXR5OiAxLFxuXHRfbG9ja2VkOiBmYWxzZSxcblx0X2d1aWRlOiBmYWxzZSxcblx0X2NsaXBNYXNrOiBmYWxzZSxcblx0X3NlbGVjdGlvbjogMCxcblx0X3NlbGVjdEJvdW5kczogdHJ1ZSxcblx0X3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdG5hbWU6IG51bGwsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0bWF0cml4OiBuZXcgTWF0cml4KCksXG5cdFx0cGl2b3Q6IG51bGwsXG5cdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0bG9ja2VkOiBmYWxzZSxcblx0XHRndWlkZTogZmFsc2UsXG5cdFx0Y2xpcE1hc2s6IGZhbHNlLFxuXHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRkYXRhOiB7fVxuXHR9LFxuXHRfcHJpb3JpdGl6ZTogWydhcHBseU1hdHJpeCddXG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGFuZGxlcnMgPSBbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChoYW5kbGVycyxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0gPSB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fY291bnRJdGVtRXZlbnQodHlwZSwgMSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2NvdW50SXRlbUV2ZW50KHR5cGUsIC0xKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRfZXZlbnRzOiB7XG5cdFx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9hbmltYXRlSXRlbSh0aGlzLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uTG9hZDoge30sXG5cdFx0XHRcdG9uRXJyb3I6IHt9XG5cdFx0XHR9LFxuXHRcdFx0c3RhdGljczoge1xuXHRcdFx0XHRfaXRlbUhhbmRsZXJzOiBoYW5kbGVyc1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sIHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSXRlbSgpIHtcblx0fSxcblxuXHRfaW5pdGlhbGl6ZTogZnVuY3Rpb24ocHJvcHMsIHBvaW50KSB7XG5cdFx0dmFyIGhhc1Byb3BzID0gcHJvcHMgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSxcblx0XHRcdGludGVybmFsID0gaGFzUHJvcHMgJiYgcHJvcHMuaW50ZXJuYWwgPT09IHRydWUsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRwcm9qZWN0ID0gaGFzUHJvcHMgJiYgcHJvcHMucHJvamVjdCB8fCBwYXBlci5wcm9qZWN0LFxuXHRcdFx0c2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncztcblx0XHR0aGlzLl9pZCA9IGludGVybmFsID8gbnVsbCA6IFVJRC5nZXQoKTtcblx0XHR0aGlzLl9wYXJlbnQgPSB0aGlzLl9pbmRleCA9IG51bGw7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmIChpbnRlcm5hbCB8fCBoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT0gZmFsc2Vcblx0XHRcdHx8ICFzZXR0aW5ncy5pbnNlcnRJdGVtcyAmJiAhKGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gdHJ1ZSkpIHtcblx0XHRcdHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdChoYXNQcm9wcyAmJiBwcm9wcy5wYXJlbnQgfHwgcHJvamVjdClcblx0XHRcdFx0XHQuX2luc2VydEl0ZW0odW5kZWZpbmVkLCB0aGlzLCB0cnVlKTtcblx0XHR9XG5cdFx0aWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVCkge1xuXHRcdFx0dGhpcy5zZXQocHJvcHMsIHtcblx0XHRcdFx0aW50ZXJuYWw6IHRydWUsIGluc2VydDogdHJ1ZSwgcHJvamVjdDogdHJ1ZSwgcGFyZW50OiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc1Byb3BzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9zeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDE2KSB7XG5cdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjYWNoZVBhcmVudFxuXHRcdFx0XHQmJiAoZmxhZ3MgJiA3MikpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAyKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAocHJvamVjdClcblx0XHRcdHByb2plY3QuX2NoYW5nZWQoZmxhZ3MsIHRoaXMpO1xuXHRcdGlmIChzeW1ib2wpXG5cdFx0XHRzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdGdldElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdH0sXG5cblx0c2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0aWYgKG5hbWUgJiYgb3duZXIpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IG93bmVyLl9uYW1lZENoaWxkcmVuO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0aWYgKCEobmFtZSBpbiBjaGlsZHJlbikpXG5cdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjU2KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRrZXkgPSAnXycgKyBuYW1lLFxuXHRcdFx0ZmxhZ3MgPSB7XG5cdFx0XHRcdGxvY2tlZDogMjU2LFxuXHRcdFx0XHR2aXNpYmxlOiAyNjVcblx0XHRcdH07XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1trZXldO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW2tleV0pIHtcblx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoZmxhZ3NbbmFtZV0gfHwgMjU3KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGlvbjtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXHRcdGlmIChzZWxlY3Rpb24gIT09IHRoaXMuX3NlbGVjdGlvbikge1xuXHRcdFx0dGhpcy5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdFx0cHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDI1Nyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VTZWxlY3Rpb246IGZ1bmN0aW9uKGZsYWcsIHNlbGVjdGVkKSB7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcblx0XHR0aGlzLnNldFNlbGVjdGlvbihzZWxlY3RlZCA/IHNlbGVjdGlvbiB8IGZsYWcgOiBzZWxlY3Rpb24gJiB+ZmxhZyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHNlbGVjdGVkID0gISEodGhpcy5fc2VsZWN0aW9uICYgMSk7XG5cdFx0aWYgKGNoaWxkcmVuICYmIHNlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZVNlbGVjdGlvbigxLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMjU3KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgyMDQ4KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uIHx8XG5cdFx0XHQodGhpcy5fcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbkZyb21Cb3VuZHMoKSk7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHRoaXMsICdzZXRQb3NpdGlvbicpO1xuXHR9LFxuXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykuc3VidHJhY3QodGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9LFxuXG5cdF9nZXRQb3NpdGlvbkZyb21Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcykge1xuXHRcdHJldHVybiB0aGlzLl9waXZvdFxuXHRcdFx0XHQ/IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcy5fcGl2b3QpXG5cdFx0XHRcdDogKGJvdW5kcyB8fCB0aGlzLmdldEJvdW5kcygpKS5nZXRDZW50ZXIodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdHJldHVybiBwaXZvdFxuXHRcdFx0XHQ/IG5ldyBMaW5rZWRQb2ludChwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUsIHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9XG59LCBCYXNlLmVhY2goe1xuXHRcdGdldFN0cm9rZUJvdW5kczogeyBzdHJva2U6IHRydWUgfSxcblx0XHRnZXRIYW5kbGVCb3VuZHM6IHsgaGFuZGxlOiB0cnVlIH0sXG5cdFx0Z2V0SW50ZXJuYWxCb3VuZHM6IHsgaW50ZXJuYWw6IHRydWUgfVxuXHR9LFxuXHRmdW5jdGlvbihvcHRpb25zLCBrZXkpIHtcblx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIGhhc01hdHJpeCA9IG9wdGlvbnMgfHwgbWF0cml4IGluc3RhbmNlb2YgTWF0cml4LFxuXHRcdFx0b3B0cyA9IEJhc2Uuc2V0KHt9LCBoYXNNYXRyaXggPyBvcHRpb25zIDogbWF0cml4LFxuXHRcdFx0XHRcdHRoaXMuX2JvdW5kc09wdGlvbnMpO1xuXHRcdGlmICghb3B0cy5zdHJva2UgfHwgdGhpcy5nZXRTdHJva2VTY2FsaW5nKCkpXG5cdFx0XHRvcHRzLmNhY2hlSXRlbSA9IHRoaXM7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLl9nZXRDYWNoZWRCb3VuZHMoaGFzTWF0cml4ICYmIG1hdHJpeCwgb3B0cykucmVjdDtcblx0XHRyZXR1cm4gIWFyZ3VtZW50cy5sZW5ndGhcblx0XHRcdFx0PyBuZXcgTGlua2VkUmVjdGFuZ2xlKHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCxcblx0XHRcdFx0XHR0aGlzLCAnc2V0Qm91bmRzJylcblx0XHRcdFx0OiByZWN0O1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0aWYgKCFfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG5cdFx0XHRcdF9tYXRyaXguc2V0KF9tYXRyaXguX2JhY2t1cFxuXHRcdFx0XHRcdFx0fHwgbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShfbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHRcdH1cblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT09IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMCxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9PSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMCk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcywgb3B0aW9ucy5jYWNoZUl0ZW0pO1xuXHRcdHJldHVybiBJdGVtLl9nZXRCb3VuZHMoY2hpbGRyZW4sIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2dldEJvdW5kc0NhY2hlS2V5OiBmdW5jdGlvbihvcHRpb25zLCBpbnRlcm5hbCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHRvcHRpb25zLnN0cm9rZSA/IDEgOiAwLFxuXHRcdFx0b3B0aW9ucy5oYW5kbGUgPyAxIDogMCxcblx0XHRcdGludGVybmFsID8gMSA6IDBcblx0XHRdLmpvaW4oJycpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKG1hdHJpeCwgb3B0aW9ucywgbm9JbnRlcm5hbCkge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguX29yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgaW50ZXJuYWwgPSBvcHRpb25zLmludGVybmFsICYmICFub0ludGVybmFsLFxuXHRcdFx0Y2FjaGVJdGVtID0gb3B0aW9ucy5jYWNoZUl0ZW0sXG5cdFx0XHRfbWF0cml4ID0gaW50ZXJuYWwgPyBudWxsIDogdGhpcy5fbWF0cml4Ll9vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZUtleSA9IGNhY2hlSXRlbSAmJiAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKVxuXHRcdFx0XHQmJiB0aGlzLl9nZXRCb3VuZHNDYWNoZUtleShvcHRpb25zLCBpbnRlcm5hbCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3N5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGVLZXkgJiYgYm91bmRzICYmIGNhY2hlS2V5IGluIGJvdW5kcykge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGJvdW5kc1tjYWNoZUtleV07XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZWN0OiBjYWNoZWQucmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBjYWNoZWQubm9uc2NhbGluZ1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0dmFyIHJlcyA9IHRoaXMuX2dldEJvdW5kcyhtYXRyaXggfHwgX21hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRyZWN0ID0gcmVzLnJlY3QgfHwgcmVzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdG5vbnNjYWxpbmcgPSByZXMubm9uc2NhbGluZyB8fCBzdHlsZS5oYXNTdHJva2UoKVxuXHRcdFx0XHQmJiAhc3R5bGUuZ2V0U3Ryb2tlU2NhbGluZygpO1xuXHRcdGlmIChjYWNoZUtleSkge1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fYm91bmRzID0gYm91bmRzID0ge307XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW2NhY2hlS2V5XSA9IHtcblx0XHRcdFx0cmVjdDogcmVjdC5jbG9uZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nLFxuXHRcdFx0XHRpbnRlcm5hbDogaW50ZXJuYWxcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0bm9uc2NhbGluZzogbm9uc2NhbGluZ1xuXHRcdH07XG5cdH0sXG5cblx0X2dldFN0cm9rZU1hdHJpeDogZnVuY3Rpb24obWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbFxuXHRcdFx0XHQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnRlcm5hbCA/IHRoaXNcblx0XHRcdFx0XHQ6IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9zeW1ib2wgJiYgdGhpcy5fc3ltYm9sLl9pdGVtLFxuXHRcdFx0bXggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Vmlld01hdHJpeCgpLmludmVydCgpIDogbWF0cml4O1xuXHRcdHJldHVybiBteCAmJiBteC5fc2hpZnRsZXNzKCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF91cGRhdGVCb3VuZHNDYWNoZTogZnVuY3Rpb24ocGFyZW50LCBpdGVtKSB7XG5cdFx0XHRpZiAocGFyZW50ICYmIGl0ZW0pIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2dldEJvdW5kczogZnVuY3Rpb24oaXRlbXMsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHgxID0gSW5maW5pdHksXG5cdFx0XHRcdHgyID0gLXgxLFxuXHRcdFx0XHR5MSA9IHgxLFxuXHRcdFx0XHR5MiA9IHgyLFxuXHRcdFx0XHRub25zY2FsaW5nID0gZmFsc2U7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGlmIChpdGVtLl92aXNpYmxlICYmICFpdGVtLmlzRW1wdHkodHJ1ZSkpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gaXRlbS5fZ2V0Q2FjaGVkQm91bmRzKFxuXHRcdFx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChpdGVtLl9tYXRyaXgpLCBvcHRpb25zLCB0cnVlKSxcblx0XHRcdFx0XHRcdHJlY3QgPSBib3VuZHMucmVjdDtcblx0XHRcdFx0XHR4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuXHRcdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdFx0eDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG5cdFx0XHRcdFx0eTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuXHRcdFx0XHRcdGlmIChib3VuZHMubm9uc2NhbGluZylcblx0XHRcdFx0XHRcdG5vbnNjYWxpbmcgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRyZWN0OiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXHRcdFx0XHRcdDogbmV3IFJlY3RhbmdsZSgpLFxuXHRcdFx0XHRub25zY2FsaW5nOiBub25zY2FsaW5nXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG59KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXhcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCA/IGRlY29tcG9zZWQucm90YXRpb24gOiAwO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlKCksXG5cdFx0XHRzID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChzID8gcy54IDogMSwgcyA/IHMueSA6IDEsIHRoaXMsICdzZXRTY2FsaW5nJyk7XG5cdH0sXG5cblx0c2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKSxcblx0XHRcdHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSwgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGN1cnJlbnQgJiYgc2NhbGluZyAmJiAhY3VycmVudC5lcXVhbHMoc2NhbGluZykpIHtcblx0XHRcdHZhciByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQsXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdFx0Y2VudGVyID0gdGhpcy5nZXRQb3NpdGlvbih0cnVlKTtcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdGlmIChyb3RhdGlvbilcblx0XHRcdFx0bWF0cml4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRtYXRyaXguc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuXHRcdFx0aWYgKHJvdGF0aW9uKVxuXHRcdFx0XHRtYXRyaXgucm90YXRlKC1yb3RhdGlvbik7XG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQpIHtcblx0XHRcdFx0ZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcblx0XHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fSxcblxuXHRzZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cdFx0bWF0cml4LmluaXRpYWxpemUuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGdldEdsb2JhbE1hdHJpeDogZnVuY3Rpb24oX2RvbnRDbG9uZSkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXg7XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdHZhciBwYXJlbnRzID0gW107XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGlmICghcGFyZW50Ll9nbG9iYWxNYXRyaXgpIHtcblx0XHRcdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdHBhcmVudHNbaV0uX2dsb2JhbE1hdHJpeCA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudHMucHVzaChwYXJlbnQpO1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFtYXRyaXgpIHtcblx0XHRcdG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdGlmIChwYXJlbnQpXG5cdFx0XHRcdG1hdHJpeC5wcmVwZW5kKHBhcmVudC5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldFZpZXdNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZXBlbmQodGhpcy5nZXRWaWV3KCkuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcblx0fSxcblxuXHRzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oYXBwbHkpIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIWFwcGx5KVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5fdmlldztcblx0fSxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24gX2luc3RhbGxFdmVudHMoaW5zdGFsbCkge1xuXHRcdF9pbnN0YWxsRXZlbnRzLmJhc2UuY2FsbCh0aGlzLCBpbnN0YWxsKTtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLl9pbnN0YWxsRXZlbnRzKGluc3RhbGwpO1xuXHR9LFxuXG5cdGdldExheWVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBMYXllcilcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50O1xuXHR9LFxuXG5cdHNldFBhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdF9nZXRPd25lcjogJyNnZXRQYXJlbnQnLFxuXG5cdGdldENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW47XG5cdH0sXG5cblx0c2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdHRoaXMuYWRkQ2hpbGRyZW4oaXRlbXMpO1xuXHR9LFxuXG5cdGdldEZpcnN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldExhc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuW3RoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX2dldE93bmVyKCk7XG5cdFx0cmV0dXJuIG93bmVyICYmIG93bmVyLl9jaGlsZHJlblt0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciAmJiBvd25lci5fY2hpbGRyZW5bdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPT09IHRoaXMgfHwgaXRlbSAmJiB0aGlzLl9jbGFzcyA9PT0gaXRlbS5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3R5bGUuZXF1YWxzKGl0ZW0uX3N0eWxlKVxuXHRcdFx0XHQmJiB0aGlzLl9tYXRyaXguZXF1YWxzKGl0ZW0uX21hdHJpeClcblx0XHRcdFx0JiYgdGhpcy5fbG9ja2VkID09PSBpdGVtLl9sb2NrZWRcblx0XHRcdFx0JiYgdGhpcy5fdmlzaWJsZSA9PT0gaXRlbS5fdmlzaWJsZVxuXHRcdFx0XHQmJiB0aGlzLl9ibGVuZE1vZGUgPT09IGl0ZW0uX2JsZW5kTW9kZVxuXHRcdFx0XHQmJiB0aGlzLl9vcGFjaXR5ID09PSBpdGVtLl9vcGFjaXR5XG5cdFx0XHRcdCYmIHRoaXMuX2NsaXBNYXNrID09PSBpdGVtLl9jbGlwTWFza1xuXHRcdFx0XHQmJiB0aGlzLl9ndWlkZSA9PT0gaXRlbS5fZ3VpZGVcblx0XHRcdFx0JiYgdGhpcy5fZXF1YWxzKGl0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fY2hpbGRyZW4sIGl0ZW0uX2NoaWxkcmVuKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0Y2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGluc2VydCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5pbnNlcnQgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0b3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IHRydWUpLFxuXHRcdFx0ZGVlcCA9IEJhc2UucGljayhvcHRpb25zID8gb3B0aW9ucy5kZWVwIDogdW5kZWZpbmVkLCB0cnVlKTtcblx0XHRpZiAoY2hpbGRyZW4pXG5cdFx0XHRjb3B5LmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgZGVlcClcblx0XHRcdGNvcHkuY29weUNvbnRlbnQodGhpcyk7XG5cdFx0aWYgKCFjaGlsZHJlbilcblx0XHRcdGNvcHkuY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0aWYgKGluc2VydClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0cGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0aWYgKG5hbWUgIT09IG9yaWcpXG5cdFx0XHRcdGNvcHkuc2V0TmFtZShuYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHNvdXJjZS5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuYWRkQ2hpbGQoY2hpbGRyZW5baV0uY2xvbmUoZmFsc2UpLCB0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Y29weUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZXhjbHVkZU1hdHJpeCkge1xuXHRcdHRoaXMuc2V0U3R5bGUoc291cmNlLl9zdHlsZSk7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdHRoaXNba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdH1cblx0XHRpZiAoIWV4Y2x1ZGVNYXRyaXgpXG5cdFx0XHR0aGlzLl9tYXRyaXguc2V0KHNvdXJjZS5fbWF0cml4LCB0cnVlKTtcblx0XHR0aGlzLnNldEFwcGx5TWF0cml4KHNvdXJjZS5fYXBwbHlNYXRyaXgpO1xuXHRcdHRoaXMuc2V0UGl2b3Qoc291cmNlLl9waXZvdCk7XG5cdFx0dGhpcy5zZXRTZWxlY3Rpb24oc291cmNlLl9zZWxlY3Rpb24pO1xuXHRcdHZhciBkYXRhID0gc291cmNlLl9kYXRhLFxuXHRcdFx0bmFtZSA9IHNvdXJjZS5fbmFtZTtcblx0XHR0aGlzLl9kYXRhID0gZGF0YSA/IEJhc2UuY2xvbmUoZGF0YSkgOiBudWxsO1xuXHRcdGlmIChuYW1lKVxuXHRcdFx0dGhpcy5zZXROYW1lKG5hbWUpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbiwgaW5zZXJ0KSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG5cdFx0XHRzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3Mixcblx0XHRcdHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG5cdFx0XHRib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRpZiAoIXNpemUuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuXHRcdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0XHR0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7IG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdH1cblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0aWYgKGluc2VydCA9PT0gdW5kZWZpbmVkIHx8IGluc2VydClcblx0XHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdHJldHVybiAoXG5cdFx0XHRtYXRyaXguaXNJbnZlcnRpYmxlKCkgJiZcblx0XHRcdCEhdGhpcy5fY29udGFpbnMobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpXG5cdFx0KTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMuZ2V0Qm91bmRzKCkpO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuXHRcdFx0bWF0cml4OiB0aGlzLl9tYXRyaXgsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKGl0ZW0sIF9tYXRyaXgpIHtcblx0XHRpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2FzUGF0aEl0ZW0oKS5nZXRJbnRlcnNlY3Rpb25zKGl0ZW0uX2FzUGF0aEl0ZW0oKSwgbnVsbCxcblx0XHRcdFx0X21hdHJpeCwgdHJ1ZSkubGVuZ3RoID4gMDtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGl0VGVzdCgpIHtcblx0XHRyZXR1cm4gdGhpcy5faGl0VGVzdChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRIaXRSZXN1bHQuZ2V0T3B0aW9ucyhhcmd1bWVudHMpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhpdFRlc3RBbGwoKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKGFyZ3VtZW50cyksXG5cdFx0XHRhbGwgPSBbXTtcblx0XHR0aGlzLl9oaXRUZXN0KHBvaW50LCBCYXNlLnNldCh7IGFsbDogYWxsIH0sIG9wdGlvbnMpKTtcblx0XHRyZXR1cm4gYWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGl0VGVzdENoaWxkcmVuKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBfZXhjbHVkZSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHR2YXIgcmVzID0gY2hpbGQgIT09IF9leGNsdWRlICYmIGNoaWxkLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zLFxuXHRcdFx0XHRcdFx0dmlld01hdHJpeCk7XG5cdFx0XHRcdGlmIChyZXMgJiYgIW9wdGlvbnMuYWxsKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGhpdFRlc3Q6IGhpdFRlc3QsXG5cdFx0aGl0VGVzdEFsbDogaGl0VGVzdEFsbCxcblx0XHRfaGl0VGVzdDogaGl0VGVzdENoaWxkcmVuXG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0aGl0VGVzdDogaGl0VGVzdCxcblx0XHRoaXRUZXN0QWxsOiBoaXRUZXN0QWxsLFxuXHRcdF9oaXRUZXN0Q2hpbGRyZW46IGhpdFRlc3RDaGlsZHJlbixcblx0fTtcbn0sIHtcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMsIHBhcmVudFZpZXdNYXRyaXgpIHtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJlbnRWaWV3TWF0cml4XG5cdFx0XHRcdFx0PyBwYXJlbnRWaWV3TWF0cml4LmFwcGVuZGVkKG1hdHJpeClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlcGVuZCh0aGlzLmdldFZpZXcoKS5fbWF0cml4KSxcblx0XHRcdHRvbGVyYW5jZSA9IE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAxZS0xMiksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFBhdGguX2dldFN0cm9rZVBhZGRpbmcodG9sZXJhbmNlLFxuXHRcdFx0XHRcdFx0bWF0cml4Ll9zaGlmdGxlc3MoKS5pbnZlcnQoKSkpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblx0XHRpZiAoIXBvaW50IHx8ICF0aGlzLl9jaGlsZHJlbiAmJlxuXHRcdFx0IXRoaXMuZ2V0Qm91bmRzKHsgaW50ZXJuYWw6IHRydWUsIHN0cm9rZTogdHJ1ZSwgaGFuZGxlOiB0cnVlIH0pXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgY2hlY2tTZWxmID0gIShvcHRpb25zLmd1aWRlcyAmJiAhdGhpcy5fZ3VpZGVcblx0XHRcdFx0fHwgb3B0aW9ucy5zZWxlY3RlZCAmJiAhdGhpcy5pc1NlbGVjdGVkKClcblx0XHRcdFx0fHwgb3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdHx8IG9wdGlvbnMuY2xhc3MgJiYgISh0aGlzIGluc3RhbmNlb2Ygb3B0aW9ucy5jbGFzcykpLFxuXHRcdFx0bWF0Y2ggPSBvcHRpb25zLm1hdGNoLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRib3VuZHMsXG5cdFx0XHRyZXM7XG5cblx0XHRmdW5jdGlvbiBmaWx0ZXIoaGl0KSB7XG5cdFx0XHRpZiAoaGl0ICYmIG1hdGNoICYmICFtYXRjaChoaXQpKVxuXHRcdFx0XHRoaXQgPSBudWxsO1xuXHRcdFx0aWYgKGhpdCAmJiBvcHRpb25zLmFsbClcblx0XHRcdFx0b3B0aW9ucy5hbGwucHVzaChoaXQpO1xuXHRcdFx0cmV0dXJuIGhpdDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1BvaW50KHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IHBhcnQgPyBib3VuZHNbJ2dldCcgKyBwYXJ0XSgpIDogdGhhdC5nZXRQb3NpdGlvbigpO1xuXHRcdFx0aWYgKHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUodG9sZXJhbmNlUGFkZGluZykubGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCwge1xuXHRcdFx0XHRcdG5hbWU6IHBhcnQgPyBCYXNlLmh5cGhlbmF0ZShwYXJ0KSA6IHR5cGUsXG5cdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGVja1Bvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbixcblx0XHRcdGNoZWNrQ2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG5cdFx0XHRjaGVja0JvdW5kcyA9IG9wdGlvbnMuYm91bmRzO1xuXHRcdGlmIChjaGVja1NlbGYgJiYgdGhpcy5fcGFyZW50XG5cdFx0XHRcdCYmIChjaGVja1Bvc2l0aW9uIHx8IGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSkge1xuXHRcdFx0aWYgKGNoZWNrQ2VudGVyIHx8IGNoZWNrQm91bmRzKSB7XG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKTtcblx0XHRcdH1cblx0XHRcdHJlcyA9IGNoZWNrUG9zaXRpb24gJiYgY2hlY2tQb2ludCgncG9zaXRpb24nKSB8fFxuXHRcdFx0XHRcdGNoZWNrQ2VudGVyICYmIGNoZWNrUG9pbnQoJ2NlbnRlcicsICdDZW50ZXInKTtcblx0XHRcdGlmICghcmVzICYmIGNoZWNrQm91bmRzKSB7XG5cdFx0XHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlcidcblx0XHRcdFx0XTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4ICYmICFyZXM7IGkrKykge1xuXHRcdFx0XHRcdHJlcyA9IGNoZWNrUG9pbnQoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlcyA9IGZpbHRlcihyZXMpO1xuXHRcdH1cblxuXHRcdGlmICghcmVzKSB7XG5cdFx0XHRyZXMgPSB0aGlzLl9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpXG5cdFx0XHRcdHx8IGNoZWNrU2VsZlxuXHRcdFx0XHRcdCYmIGZpbHRlcih0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0XHRcdHRoaXMuZ2V0U3Ryb2tlU2NhbGluZygpID8gbnVsbFxuXHRcdFx0XHRcdFx0XHQ6IHZpZXdNYXRyaXguX3NoaWZ0bGVzcygpLmludmVydCgpKSlcblx0XHRcdFx0fHwgbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpIHtcblx0XHRcdHJlcy5wb2ludCA9IG1hdHJpeC50cmFuc2Zvcm0ocmVzLnBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9LFxuXG5cdG1hdGNoZXM6IGZ1bmN0aW9uKG5hbWUsIGNvbXBhcmUpIHtcblx0XHRmdW5jdGlvbiBtYXRjaE9iamVjdChvYmoxLCBvYmoyKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsMSA9IG9iajFbaV0sXG5cdFx0XHRcdFx0XHR2YWwyID0gb2JqMltpXTtcblx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KHZhbDEpICYmIEJhc2UuaXNQbGFpbk9iamVjdCh2YWwyKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdCh2YWwxLCB2YWwyKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbDEsIHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgbmFtZTtcblx0XHRpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSh0aGlzKTtcblx0XHR9IGVsc2UgaWYgKG5hbWUgPT09ICdtYXRjaCcpIHtcblx0XHRcdHJldHVybiBjb21wYXJlKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdFx0PyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKClcblx0XHRcdFx0XHQ6IG5hbWUgPT09ICd0eXBlJ1xuXHRcdFx0XHRcdFx0PyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogdGhpc1tuYW1lXTtcblx0XHRcdGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGNvbXBhcmU7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5fY2xhc3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuICEhY29tcGFyZSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUpIHtcblx0XHRcdFx0aWYgKGNvbXBhcmUudGVzdCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wYXJlLnRlc3QodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMsIG9wdGlvbnMsIHRoaXMuX21hdHJpeCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLCBvcHRpb25zLCB0aGlzLl9tYXRyaXgsIG51bGwsIHRydWUpWzBdXG5cdFx0XHRcdHx8IG51bGw7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9nZXRJdGVtczogZnVuY3Rpb24gX2dldEl0ZW1zKGl0ZW0sIG9wdGlvbnMsIG1hdHJpeCwgcGFyYW0sIGZpcnN0T25seSkge1xuXHRcdFx0aWYgKCFwYXJhbSkge1xuXHRcdFx0XHR2YXIgb2JqID0gdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmcgPSBvYmogJiYgb2JqLm92ZXJsYXBwaW5nLFxuXHRcdFx0XHRcdGluc2lkZSA9IG9iaiAmJiBvYmouaW5zaWRlLFxuXHRcdFx0XHRcdGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcblx0XHRcdFx0XHRyZWN0ID0gYm91bmRzICYmIFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdKTtcblx0XHRcdFx0cGFyYW0gPSB7XG5cdFx0XHRcdFx0aXRlbXM6IFtdLFxuXHRcdFx0XHRcdHJlY3Vyc2l2ZTogb2JqICYmIG9iai5yZWN1cnNpdmUgIT09IGZhbHNlLFxuXHRcdFx0XHRcdGluc2lkZTogISFpbnNpZGUsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmc6ICEhb3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0cmVjdDogcmVjdCxcblx0XHRcdFx0XHRwYXRoOiBvdmVybGFwcGluZyAmJiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0XHRcdFx0cmVjdGFuZ2xlOiByZWN0LFxuXHRcdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChvYmopIHtcblx0XHRcdFx0XHRvcHRpb25zID0gQmFzZS5maWx0ZXIoe30sIG9wdGlvbnMsIHtcblx0XHRcdFx0XHRcdHJlY3Vyc2l2ZTogdHJ1ZSwgaW5zaWRlOiB0cnVlLCBvdmVybGFwcGluZzogdHJ1ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbixcblx0XHRcdFx0aXRlbXMgPSBwYXJhbS5pdGVtcyxcblx0XHRcdFx0cmVjdCA9IHBhcmFtLnJlY3Q7XG5cdFx0XHRtYXRyaXggPSByZWN0ICYmIChtYXRyaXggfHwgbmV3IE1hdHJpeCgpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRcdGNoaWxkTWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5hcHBlbmRlZChjaGlsZC5fbWF0cml4KSxcblx0XHRcdFx0XHRhZGQgPSB0cnVlO1xuXHRcdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmICghcmVjdC5pbnRlcnNlY3RzKGJvdW5kcykpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAoIShyZWN0LmNvbnRhaW5zKGJvdW5kcylcblx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ub3ZlcmxhcHBpbmcgJiYgKGJvdW5kcy5jb250YWlucyhyZWN0KVxuXHRcdFx0XHRcdFx0XHRcdHx8IHBhcmFtLnBhdGguaW50ZXJzZWN0cyhjaGlsZCwgY2hpbGRNYXRyaXgpKSkpXG5cdFx0XHRcdFx0XHRhZGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWRkICYmIGNoaWxkLm1hdGNoZXMob3B0aW9ucykpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRpZiAoZmlyc3RPbmx5KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHBhcmFtLnJlY3Vyc2l2ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRfZ2V0SXRlbXMoY2hpbGQsIG9wdGlvbnMsIGNoaWxkTWF0cml4LCBwYXJhbSwgZmlyc3RPbmx5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpcyA/IHRoaXMuYWRkQ2hpbGQocmVzKSA6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG5cdFx0dmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0pIDogbnVsbDtcblx0XHRyZXR1cm4gcmVzICYmIHJlc1swXTtcblx0fSxcblxuXHRhZGRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQmFzZS5zbGljZShpdGVtcyk7XG5cdFx0XHR2YXIgaW5zZXJ0ZWQgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldLFxuXHRcdFx0XHRcdGlkID0gaXRlbSAmJiBpdGVtLl9pZDtcblx0XHRcdFx0aWYgKCFpdGVtIHx8IGluc2VydGVkW2lkXSkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdGluc2VydGVkW2lkXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEJhc2Uuc3BsaWNlKGNoaWxkcmVuLCBpdGVtcywgaW5kZXgsIDApO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRub3RpZnlTZWxmID0gcHJvamVjdC5fY2hhbmdlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV0sXG5cdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX25hbWU7XG5cdFx0XHRcdGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cdFx0XHRcdGl0ZW0uX3NldFByb2plY3QocHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChuYW1lKVxuXHRcdFx0XHRcdGl0ZW0uc2V0TmFtZShuYW1lKTtcblx0XHRcdFx0aWYgKG5vdGlmeVNlbGYpXG5cdFx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtcyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfaW5zZXJ0SXRlbTogJyNpbnNlcnRDaGlsZCcsXG5cblx0X2luc2VydEF0OiBmdW5jdGlvbihpdGVtLCBvZmZzZXQpIHtcblx0XHR2YXIgb3duZXIgPSBpdGVtICYmIGl0ZW0uX2dldE93bmVyKCksXG5cdFx0XHRyZXMgPSBpdGVtICE9PSB0aGlzICYmIG93bmVyID8gdGhpcyA6IG51bGw7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0cmVzLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0b3duZXIuX2luc2VydEl0ZW0oaXRlbS5faW5kZXggKyBvZmZzZXQsIHJlcyk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0aW5zZXJ0QWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5faW5zZXJ0QXQoaXRlbSwgMCk7XG5cdH0sXG5cblx0c2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKTtcblx0XHRyZXR1cm4gb3duZXIgPyBvd25lci5faW5zZXJ0SXRlbSgwLCB0aGlzKSA6IG51bGw7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdHJldHVybiBvd25lciA/IG93bmVyLl9pbnNlcnRJdGVtKHVuZGVmaW5lZCwgdGhpcykgOiBudWxsO1xuXHR9LFxuXG5cdGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG5cblx0YXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG5cdH0sXG5cblx0bW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcblxuXHRtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuXG5cdGFkZFRvOiBmdW5jdGlvbihvd25lcikge1xuXHRcdHJldHVybiBvd25lci5faW5zZXJ0SXRlbSh1bmRlZmluZWQsIHRoaXMpO1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24ob3duZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZShmYWxzZSkuYWRkVG8ob3duZXIpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuWzBdLnJlZHVjZShvcHRpb25zKTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpIHtcblx0XHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaGlsZC5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3JlbW92ZU5hbWVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9nZXRPd25lcigpO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gb3duZXIuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRcdG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0XHRuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcblx0XHRcdFx0aW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKVxuXHRcdFx0XHRcdGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0bmFtZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24obm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fZ2V0T3duZXIoKSxcblx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleDtcblx0XHRpZiAodGhpcy5fc3R5bGUpXG5cdFx0XHR0aGlzLl9zdHlsZS5fZGlzcG9zZSgpO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdFx0cHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdFx0QmFzZS5zcGxpY2Uob3duZXIuX2NoaWxkcmVuLCBudWxsLCBpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KVxuXHRcdFx0XHRvd25lci5fY2hhbmdlZCgxMSwgdGhpcyk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdGVuZCA9IEJhc2UucGljayhlbmQsIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgc3RhcnQsIGVuZCAtIHN0YXJ0KTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24ocmVjdXJzaXZlbHkpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHR2YXIgbnVtQ2hpbGRyZW4gPSBjaGlsZHJlbiA/IGNoaWxkcmVuLmxlbmd0aCA6IDA7XG5cdFx0aWYgKHJlY3Vyc2l2ZWx5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bUNoaWxkcmVuOyBpKyspIHtcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0VtcHR5KHJlY3Vyc2l2ZWx5KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhbnVtQ2hpbGRyZW47XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09PSBpdGVtKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNTaWJsaW5nOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbS5fcGFyZW50O1xuXHR9LFxuXG5cdGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQuX3BhcmVudFxuXHRcdFx0XHQmJiAvXihHcm91cHxMYXllcnxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKVxuXHRcdFx0XHQmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxufSwgQmFzZS5lYWNoKFsncm90YXRlJywgJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHZhciByb3RhdGUgPSBrZXkgPT09ICdyb3RhdGUnO1xuXHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSAocm90YXRlID8gQmFzZSA6IFBvaW50KS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW2tleV0odmFsdWUsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH07XG59LCB7XG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlNYXRyaXgsIF9hcHBseVJlY3Vyc2l2ZWx5LFxuXHRcdFx0X3NldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHR0cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXggJiYgIW1hdHJpeC5pc0lkZW50aXR5KCksXG5cdFx0XHRhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG5cdFx0XHRcdFx0JiYgKCghX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgdHJhbnNmb3JtTWF0cml4KVxuXHRcdFx0XHRcdFx0fHwgX2FwcGx5TWF0cml4ICYmIF9hcHBseVJlY3Vyc2l2ZWx5ICYmIHRoaXMuX2NoaWxkcmVuKTtcblx0XHRpZiAoIXRyYW5zZm9ybU1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAodHJhbnNmb3JtTWF0cml4KSB7XG5cdFx0XHRpZiAoIW1hdHJpeC5pc0ludmVydGlibGUoKSAmJiBfbWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0XHRfbWF0cml4Ll9iYWNrdXAgPSBfbWF0cml4LmdldFZhbHVlcygpO1xuXHRcdFx0X21hdHJpeC5wcmVwZW5kKG1hdHJpeCwgdHJ1ZSk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuXHRcdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuXHRcdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdFx0ZmlsbENvbG9yLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0aWYgKHN0cm9rZUNvbG9yKVxuXHRcdFx0XHRzdHJva2VDb2xvci50cmFuc2Zvcm0obWF0cml4KTtcblx0XHR9XG5cdFx0aWYgKGFwcGx5TWF0cml4ICYmIChhcHBseU1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCxcblx0XHRcdFx0X2FwcGx5UmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkpKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdGlmIChwaXZvdClcblx0XHRcdFx0X21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QsIHBpdm90LCB0cnVlKTtcblx0XHRcdF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0XHRpZiAoX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4KVxuXHRcdFx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdGlmICh0cmFuc2Zvcm1NYXRyaXggfHwgYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdH1cblx0XHR2YXIgZGVjb21wID0gdHJhbnNmb3JtTWF0cml4ICYmIGJvdW5kcyAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0aWYgKGRlY29tcCAmJiBkZWNvbXAuc2tld2luZy5pc1plcm8oKSAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgY2FjaGUgPSBib3VuZHNba2V5XTtcblx0XHRcdFx0aWYgKGNhY2hlLm5vbnNjYWxpbmcpIHtcblx0XHRcdFx0XHRkZWxldGUgYm91bmRzW2tleV07XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXBwbHlNYXRyaXggfHwgIWNhY2hlLmludGVybmFsKSB7XG5cdFx0XHRcdFx0dmFyIHJlY3QgPSBjYWNoZS5yZWN0O1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0XHR2YXIgY2FjaGVkID0gYm91bmRzW3RoaXMuX2dldEJvdW5kc0NhY2hlS2V5KFxuXHRcdFx0XHR0aGlzLl9ib3VuZHNPcHRpb25zIHx8IHt9KV07XG5cdFx0XHRpZiAoY2FjaGVkKSB7XG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25Gcm9tQm91bmRzKGNhY2hlZC5yZWN0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybU1hdHJpeCAmJiBwb3NpdGlvbiAmJiB0aGlzLl9waXZvdCkge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvc2l0aW9uLCBwb3NpdGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgsIGFwcGx5UmVjdXJzaXZlbHksIHNldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0udHJhbnNmb3JtKG1hdHJpeCwgdHJ1ZSwgYXBwbHlSZWN1cnNpdmVseSxcblx0XHRcdFx0XHRcdHNldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX2ludmVyc2VUcmFuc2Zvcm0oXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb0dsb2JhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRwYXJlbnRUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb1BhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgZmlsbCkge1xuXHRcdHJlY3RhbmdsZSA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuXHRcdFx0cmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcblx0XHRcdHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pXG5cdFx0XHRcdFx0PyByZWN0YW5nbGUud2lkdGggLyBib3VuZHMud2lkdGhcblx0XHRcdFx0XHQ6IHJlY3RhbmdsZS5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuXHRcdFx0bmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSxcblx0XHRcdFx0XHRuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG5cdFx0bmV3Qm91bmRzLnNldENlbnRlcihyZWN0YW5nbGUuZ2V0Q2VudGVyKCkpO1xuXHRcdHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG5cdH1cbn0pLCB7XG5cblx0X3NldFN0eWxlczogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsQ29sb3IoKS50b0NhbnZhc1N0eWxlKGN0eCwgbWF0cml4KTtcblx0XHR9XG5cdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5nZXRTdHJva2VDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4LCBtYXRyaXgpO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCk7XG5cdFx0XHR2YXIgc3Ryb2tlSm9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdFx0c3Ryb2tlQ2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRpZiAoc3Ryb2tlSm9pbilcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gc3Ryb2tlSm9pbjtcblx0XHRcdGlmIChzdHJva2VDYXApXG5cdFx0XHRcdGN0eC5saW5lQ2FwID0gc3Ryb2tlQ2FwO1xuXHRcdFx0aWYgKG1pdGVyTGltaXQpXG5cdFx0XHRcdGN0eC5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblx0XHRcdGlmIChwYXBlci5zdXBwb3J0Lm5hdGl2ZURhc2gpIHtcblx0XHRcdFx0dmFyIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRcdGRhc2hPZmZzZXQgPSBzdHlsZS5nZXREYXNoT2Zmc2V0KCk7XG5cdFx0XHRcdGlmIChkYXNoQXJyYXkgJiYgZGFzaEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuXHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG5cdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjdHgubW96RGFzaCA9IGRhc2hBcnJheTtcblx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN0eWxlLmhhc1NoYWRvdygpKSB7XG5cdFx0XHR2YXIgcGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdFx0bXggPSB2aWV3TWF0cml4Ll9zaGlmdGxlc3MoKS5wcmVwZW5kKFxuXHRcdFx0XHRcdG5ldyBNYXRyaXgoKS5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKSksXG5cdFx0XHRcdGJsdXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KHN0eWxlLmdldFNoYWRvd0JsdXIoKSwgMCkpLFxuXHRcdFx0XHRvZmZzZXQgPSBteC50cmFuc2Zvcm0odGhpcy5nZXRTaGFkb3dPZmZzZXQoKSk7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzdHlsZS5nZXRTaGFkb3dDb2xvcigpLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdGN0eC5zaGFkb3dCbHVyID0gYmx1ci5nZXRMZW5ndGgoKTtcblx0XHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gb2Zmc2V0Lng7XG5cdFx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IG9mZnNldC55O1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBwYXJlbnRTdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBtYXRyaWNlcyA9IHBhcmFtLm1hdHJpY2VzLFxuXHRcdFx0dmlld01hdHJpeCA9IHBhcmFtLnZpZXdNYXRyaXgsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRnbG9iYWxNYXRyaXggPSBtYXRyaWNlc1ttYXRyaWNlcy5sZW5ndGggLSAxXS5hcHBlbmRlZChtYXRyaXgpO1xuXHRcdGlmICghZ2xvYmFsTWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmlld01hdHJpeCA9IHZpZXdNYXRyaXggPyB2aWV3TWF0cml4LmFwcGVuZGVkKGdsb2JhbE1hdHJpeClcblx0XHRcdFx0OiBnbG9iYWxNYXRyaXg7XG5cblx0XHRtYXRyaWNlcy5wdXNoKGdsb2JhbE1hdHJpeCk7XG5cdFx0aWYgKHBhcmFtLnVwZGF0ZU1hdHJpeCkge1xuXHRcdFx0dGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4O1xuXHRcdH1cblxuXHRcdHZhciBibGVuZE1vZGUgPSB0aGlzLl9ibGVuZE1vZGUsXG5cdFx0XHRvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSxcblx0XHRcdG5vcm1hbEJsZW5kID0gYmxlbmRNb2RlID09PSAnbm9ybWFsJyxcblx0XHRcdG5hdGl2ZUJsZW5kID0gQmxlbmRNb2RlLm5hdGl2ZU1vZGVzW2JsZW5kTW9kZV0sXG5cdFx0XHRkaXJlY3QgPSBub3JtYWxCbGVuZCAmJiBvcGFjaXR5ID09PSAxXG5cdFx0XHRcdFx0fHwgcGFyYW0uZG9udFN0YXJ0XG5cdFx0XHRcdFx0fHwgcGFyYW0uY2xpcFxuXHRcdFx0XHRcdHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSlcblx0XHRcdFx0XHRcdCYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdG1haW5DdHgsIGl0ZW1PZmZzZXQsIHByZXZPZmZzZXQ7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyh2aWV3TWF0cml4KTtcblx0XHRcdGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcblx0XHRcdG1haW5DdHggPSBjdHg7XG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKVxuXHRcdFx0XHRcdC5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSlcblx0XHRcdFx0Y3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXhcblx0XHRcdFx0PyBwYXJlbnRTdHJva2VNYXRyaXguYXBwZW5kZWQobWF0cml4KVxuXHRcdFx0XHQ6IHRoaXMuX2NhblNjYWxlU3Ryb2tlICYmICF0aGlzLmdldFN0cm9rZVNjYWxpbmcodHJ1ZSlcblx0XHRcdFx0XHQmJiB2aWV3TWF0cml4LFxuXHRcdFx0Y2xpcCA9ICFkaXJlY3QgJiYgcGFyYW0uY2xpcEl0ZW0sXG5cdFx0XHR0cmFuc2Zvcm0gPSAhc3Ryb2tlTWF0cml4IHx8IGNsaXA7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblx0XHRcdGlmIChuYXRpdmVCbGVuZClcblx0XHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcblx0XHR9XG5cdFx0aWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0KGRpcmVjdCA/IG1hdHJpeCA6IHZpZXdNYXRyaXgpLmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0fVxuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRwYXJhbS5jbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKSB7XG5cdFx0XHRjdHguY2xpcCh0aGlzLmdldEZpbGxSdWxlKCkpO1xuXHRcdH1cblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3Rpb25JdGVtcywgdXBkYXRlVmVyc2lvbikge1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRpdGVtU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAxLFxuXHRcdFx0Ym91bmRzU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiAyXG5cdFx0XHRcdFx0fHwgaXRlbVNlbGVjdGVkICYmIHRoaXMuX3NlbGVjdEJvdW5kcyxcblx0XHRcdHBvc2l0aW9uU2VsZWN0ZWQgPSBzZWxlY3Rpb24gJiA0O1xuXHRcdGlmICghdGhpcy5fZHJhd1NlbGVjdGVkKVxuXHRcdFx0aXRlbVNlbGVjdGVkID0gZmFsc2U7XG5cdFx0aWYgKChpdGVtU2VsZWN0ZWQgfHwgYm91bmRzU2VsZWN0ZWQgfHwgcG9zaXRpb25TZWxlY3RlZClcblx0XHRcdFx0JiYgdGhpcy5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR2YXIgbGF5ZXIsXG5cdFx0XHRcdGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpIHx8IChsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSlcblx0XHRcdFx0XHQmJiBsYXllci5nZXRTZWxlY3RlZENvbG9yKHRydWUpLFxuXHRcdFx0XHRteCA9IG1hdHJpeC5hcHBlbmRlZCh0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSksXG5cdFx0XHRcdGhhbGYgPSBzaXplIC8gMjtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKGl0ZW1TZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGlvbkl0ZW1zKTtcblx0XHRcdGlmIChwb3NpdGlvblNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBwb3MgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRcdHBhcmVudCA9IHRoaXMuX3BhcmVudCxcblx0XHRcdFx0XHRwb2ludCA9IHBhcmVudCA/IHBhcmVudC5sb2NhbFRvR2xvYmFsKHBvcykgOiBwb3MsXG5cdFx0XHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyh4LCB5LCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0dmFyIGRlbHRhcyA9IFtbMCwgLTFdLCBbMSwgMF0sIFswLCAxXSwgWy0xLCAwXV0sXG5cdFx0XHRcdFx0c3RhcnQgPSBoYWxmLFxuXHRcdFx0XHRcdGVuZCA9IHNpemUgKyAxO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciBkZWx0YSA9IGRlbHRhc1tpXSxcblx0XHRcdFx0XHRcdGR4ID0gZGVsdGFbMF0sXG5cdFx0XHRcdFx0XHRkeSA9IGRlbHRhWzFdO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oeCArIGR4ICogc3RhcnQsIHkgKyBkeSAqIHN0YXJ0KTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyBkeCAqIGVuZCwgeSArIGR5ICogZW5kKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChib3VuZHNTZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgY29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRcdGN0eFshaSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsXG5cdFx0XHRcdFx0XHRcdHNpemUsIHNpemUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShrZXkpXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNoID0ge307XG5cdFx0aGFzaFtrZXldID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pLCB7XG5cdHR3ZWVuOiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHRvO1xuXHRcdFx0dG8gPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IG51bGw7XG5cdFx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdFx0b3B0aW9ucyA9IHRvO1xuXHRcdFx0XHR0byA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBlYXNpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZWFzaW5nLFxuXHRcdFx0c3RhcnQgPSBvcHRpb25zICYmIG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMgIT0gbnVsbCAmJiAoXG5cdFx0XHRcdHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJyA/IG9wdGlvbnMgOiBvcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpLFxuXHRcdFx0dHdlZW4gPSBuZXcgVHdlZW4odGhpcywgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KTtcblx0XHRmdW5jdGlvbiBvbkZyYW1lKGV2ZW50KSB7XG5cdFx0XHR0d2Vlbi5faGFuZGxlRnJhbWUoZXZlbnQudGltZSAqIDEwMDApO1xuXHRcdFx0aWYgKCF0d2Vlbi5ydW5uaW5nKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCdmcmFtZScsIG9uRnJhbWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZHVyYXRpb24pIHtcblx0XHRcdHRoaXMub24oJ2ZyYW1lJywgb25GcmFtZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fSxcblxuXHR0d2VlblRvOiBmdW5jdGlvbih0bywgb3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnR3ZWVuKG51bGwsIHRvLCBvcHRpb25zKTtcblx0fSxcblxuXHR0d2VlbkZyb206IGZ1bmN0aW9uKGZyb20sIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy50d2Vlbihmcm9tLCBudWxsLCBvcHRpb25zKTtcblx0fVxufSk7XG5cbnZhciBHcm91cCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JvdXAnLFxuXHRfc2VsZWN0Qm91bmRzOiBmYWxzZSxcblx0X3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiAyMDUwKSB7XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0X2dldENsaXBJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblx0XHRpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xpcEl0ZW0gPSBudWxsO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24gX2dldEJvdW5kcyhtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHRcdHJldHVybiBjbGlwSXRlbVxuXHRcdFx0PyBjbGlwSXRlbS5fZ2V0Q2FjaGVkQm91bmRzKGNsaXBJdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksXG5cdFx0XHRcdEJhc2Uuc2V0KHt9LCBvcHRpb25zLCB7IHN0cm9rZTogZmFsc2UgfSkpXG5cdFx0XHQ6IF9nZXRCb3VuZHMuYmFzZS5jYWxsKHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2hpdFRlc3RDaGlsZHJlbjogZnVuY3Rpb24gX2hpdFRlc3RDaGlsZHJlbihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCkge1xuXHRcdHZhciBjbGlwSXRlbSA9IHRoaXMuX2dldENsaXBJdGVtKCk7XG5cdFx0cmV0dXJuICghY2xpcEl0ZW0gfHwgY2xpcEl0ZW0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHQmJiBfaGl0VGVzdENoaWxkcmVuLmJhc2UuY2FsbCh0aGlzLCBwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0XHRjbGlwSXRlbSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCk7XG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBjbGlwSXRlbTogY2xpcEl0ZW0sIGNsaXA6IGZhbHNlIH0pO1xuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGl0ZW0gIT09IGNsaXBJdGVtKVxuXHRcdFx0XHRpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKCkge1xuXHRcdEdyb3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2dldE93bmVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuX2luZGV4ICE9IG51bGwgJiYgdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKCkge1xuXHR9XG59KTtcblxudmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaGFwZScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHR5cGU6IG51bGwsXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRyYWRpdXM6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcywgcG9pbnQpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzLCBwb2ludCk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSBpdGVtLl90eXBlXG5cdFx0XHQmJiB0aGlzLl9zaXplLmVxdWFscyhpdGVtLl9zaXplKVxuXHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fcmFkaXVzLCBpdGVtLl9yYWRpdXMpO1xuXHR9LFxuXG5cdGNvcHlDb250ZW50OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR0aGlzLnNldFR5cGUoc291cmNlLl90eXBlKTtcblx0XHR0aGlzLnNldFNpemUoc291cmNlLl9zaXplKTtcblx0XHR0aGlzLnNldFJhZGl1cyhzb3VyY2UuX3JhZGl1cyk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChTaXplLm1pbih0aGlzLl9yYWRpdXMsIHNpemUuZGl2aWRlKDIpKSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5fc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zaXplLl9zZXQod2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG5cdFx0XHRcdD8gcmFkXG5cdFx0XHRcdDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbihyYWRpdXMpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBzaXplID0gcmFkaXVzICogMjtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMuX3NpemUuX3NldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cyk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplLl9zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRpZiAocGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXgpXG5cdFx0XHRwYXRoLnNldEFwcGx5TWF0cml4KHRydWUpO1xuXHRcdGlmIChpbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBpbnNlcnQpXG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdHRvU2hhcGU6ICcjY2xvbmUnLFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50b1BhdGgoZmFsc2UpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuXHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSB8fCBkb250UGFpbnQpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRpc0NpcmNsZSA9IHR5cGUgPT09ICdjaXJjbGUnO1xuXHRcdFx0aWYgKCFwYXJhbS5kb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIGlzQ2lyY2xlKSB7XG5cdFx0XHRcdGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcnggPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRzaXplID0gdGhpcy5fc2l6ZSxcblx0XHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIHR5cGUgPT09ICdyZWN0YW5nbGUnICYmIHJ4ID09PSAwICYmIHJ5ID09PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LnJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciB4ID0gd2lkdGggLyAyLFxuXHRcdFx0XHRcdFx0eSA9IGhlaWdodCAvIDIsXG5cdFx0XHRcdFx0XHRrYXBwYSA9IDEgLSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0XHRcdFx0XHRjeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjeSA9IHJ5ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjID0gW1xuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIC15LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgeSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIHJ5XG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdGlmIChzdHJva2VNYXRyaXgpXG5cdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgudHJhbnNmb3JtKGMsIGMsIDMyKTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGNbMF0sIGNbMV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1s4XSwgY1s5XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxMF0sIGNbMTFdLCBjWzEyXSwgY1sxM10sIGNbMTRdLCBjWzE1XSk7XG5cdFx0XHRcdFx0aWYgKHkgIT09IHJ5KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzE2XSwgY1sxN10pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMThdLCBjWzE5XSwgY1syMF0sIGNbMjFdLCBjWzIyXSwgY1syM10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1syNF0sIGNbMjVdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzI2XSwgY1syN10sIGNbMjhdLCBjWzI5XSwgY1szMF0sIGNbMzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdH1cblx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cdFx0XHRpZiAoaGFzRmlsbCkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdHN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKClcblx0XHRcdFx0XHQmJiBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRyZWN0ID0gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCk7XG5cdFx0cmV0dXJuIHN0cm9rZVdpZHRoXG5cdFx0XHRcdD8gcmVjdC5leHBhbmQoUGF0aC5fZ2V0U3Ryb2tlUGFkZGluZyhzdHJva2VXaWR0aCxcblx0XHRcdFx0XHR0aGlzLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSkpXG5cdFx0XHRcdDogcmVjdDtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIHEgPSAxOyBxIDw9IDQ7IHErKykge1xuXHRcdFx0XHR2YXIgZGlyID0gbmV3IFBvaW50KHEgPiAxICYmIHEgPCA0ID8gLTEgOiAxLCBxID4gMiA/IC0xIDogMSksXG5cdFx0XHRcdFx0Y29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcblx0XHRcdFx0XHRjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuXHRcdFx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKFxuXHRcdFx0XHRcdFx0XHRleHBhbmQgPyBjb3JuZXIuYWRkKGRpci5tdWx0aXBseShleHBhbmQpKSA6IGNvcm5lcixcblx0XHRcdFx0XHRcdFx0Y2VudGVyKTtcblx0XHRcdFx0aWYgKHJlY3QuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB7IHBvaW50OiBjZW50ZXIsIHF1YWRyYW50OiBxIH07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNPbkVsbGlwc2VTdHJva2UocG9pbnQsIHJhZGl1cywgcGFkZGluZywgcXVhZHJhbnQpIHtcblx0XHR2YXIgdmVjdG9yID0gcG9pbnQuZGl2aWRlKHJhZGl1cyk7XG5cdFx0cmV0dXJuICghcXVhZHJhbnQgfHwgdmVjdG9yLmlzSW5RdWFkcmFudChxdWFkcmFudCkpICYmXG5cdFx0XHRcdHZlY3Rvci5zdWJ0cmFjdCh2ZWN0b3Iubm9ybWFsaXplKCkpLm11bHRpcGx5KHJhZGl1cylcblx0XHRcdFx0XHQuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfY29udGFpbnM6IGZ1bmN0aW9uIF9jb250YWlucyhwb2ludCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY2VudGVyXG5cdFx0XHRcdFx0XHQ/IHBvaW50LnN1YnRyYWN0KGNlbnRlci5wb2ludCkuZGl2aWRlKHRoaXMuX3JhZGl1cylcblx0XHRcdFx0XHRcdFx0LmdldExlbmd0aCgpIDw9IDFcblx0XHRcdFx0XHRcdDogX2NvbnRhaW5zLmJhc2UuY2FsbCh0aGlzLCBwb2ludCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQuZGl2aWRlKHRoaXMuc2l6ZSkuZ2V0TGVuZ3RoKCkgPD0gMC41O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIF9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCxcblx0XHRcdFx0c3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2UsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKTtcblx0XHRcdGlmIChoaXRTdHJva2UgfHwgaGl0RmlsbCkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogMCxcblx0XHRcdFx0XHRzdHJva2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZy5hZGQoXG5cdFx0XHRcdFx0XHRQYXRoLl9nZXRTdHJva2VQYWRkaW5nKHN0cm9rZVJhZGl1cyxcblx0XHRcdFx0XHRcdFx0IXN0eWxlLmdldFN0cm9rZVNjYWxpbmcoKSAmJiBzdHJva2VNYXRyaXgpKTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHBhZGRpbmcgPSBzdHJva2VQYWRkaW5nLm11bHRpcGx5KDIpLFxuXHRcdFx0XHRcdFx0Y2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBwYWRkaW5nKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHRoaXQgPSBpc09uRWxsaXBzZVN0cm9rZShwb2ludC5zdWJ0cmFjdChjZW50ZXIucG9pbnQpLFxuXHRcdFx0XHRcdFx0XHRcdHJhZGl1cywgc3Ryb2tlUGFkZGluZywgY2VudGVyLnF1YWRyYW50KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nKSxcblx0XHRcdFx0XHRcdFx0aW5uZXIgPSByZWN0LmV4cGFuZChwYWRkaW5nLm5lZ2F0ZSgpKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhpdCA9IGlzT25FbGxpcHNlU3Ryb2tlKHBvaW50LCByYWRpdXMsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0ID8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IF9oaXRUZXN0U2VsZi5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5zdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNyZWF0ZVNoYXBlKHR5cGUsIHBvaW50LCBzaXplLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgaXRlbSA9IG5ldyBTaGFwZShCYXNlLmdldE5hbWVkKGFyZ3MpLCBwb2ludCk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cyxcblx0XHRcdFx0XHRhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSxcblx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpLFxuXHRcdFx0XHRyYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksXG5cdFx0XHRcdFx0cmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBjZW50ZXIsXG5cdFx0XHRcdHJhZGl1cztcblx0XHRcdGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuXHRcdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdFx0cmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcbn0sIHtcblx0X2NsYXNzOiAnUmFzdGVyJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc09wdGlvbnM6IHsgc3Ryb2tlOiBmYWxzZSwgaGFuZGxlOiBmYWxzZSB9LFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cdF9wcmlvcml0aXplOiBbJ2Nyb3NzT3JpZ2luJ10sXG5cdF9zbW9vdGhpbmc6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3Rlcihzb3VyY2UsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKHNvdXJjZSxcblx0XHRcdFx0cG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpKSB7XG5cdFx0XHR2YXIgaW1hZ2UsXG5cdFx0XHRcdHR5cGUgPSB0eXBlb2Ygc291cmNlLFxuXHRcdFx0XHRvYmplY3QgPSB0eXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdD8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKVxuXHRcdFx0XHRcdDogdHlwZSAgPT09ICdvYmplY3QnXG5cdFx0XHRcdFx0XHQ/IHNvdXJjZVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0aWYgKG9iamVjdCAmJiBvYmplY3QgIT09IEl0ZW0uTk9fSU5TRVJUKSB7XG5cdFx0XHRcdGlmIChvYmplY3QuZ2V0Q29udGVudCB8fCBvYmplY3QubmF0dXJhbEhlaWdodCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0aW1hZ2UgPSBvYmplY3Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0XHRpZiAoIXNpemUuaXNaZXJvKCkpIHtcblx0XHRcdFx0XHRcdGltYWdlID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gbmV3IFNpemUoKTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U291cmNlKCkgPT09IGl0ZW0uZ2V0U291cmNlKCk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBpbWFnZSA9IHNvdXJjZS5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSBzb3VyY2UuX2NhbnZhcztcblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdHRoaXMuX3NldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc291cmNlLl9zaXplKTtcblx0XHRcdGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdHRoaXMuX3NldEltYWdlKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IHNvdXJjZS5fY3Jvc3NPcmlnaW47XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplID8gc2l6ZS53aWR0aCA6IDAsIHNpemUgPyBzaXplLmhlaWdodCA6IDAsXG5cdFx0XHRcdHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXNpemUuZXF1YWxzKHRoaXMuX3NpemUpKSB7XG5cdFx0XHRpZiAoc2l6ZS53aWR0aCA+IDAgJiYgc2l6ZS5oZWlnaHQgPiAwKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0XHRcdHRoaXMuX3NldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0Z2V0TG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gIXNpemUgfHwgc2l6ZS53aWR0aCA9PT0gMCAmJiBzaXplLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0b3JpZyA9IG5ldyBQb2ludCgwLCAwKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHUgPSBuZXcgUG9pbnQoMSwgMCkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyksXG5cdFx0XHR2ID0gbmV3IFBvaW50KDAsIDEpLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpO1xuXHRcdHJldHVybiBuZXcgU2l6ZShcblx0XHRcdDcyIC8gdS5nZXRMZW5ndGgoKSxcblx0XHRcdDcyIC8gdi5nZXRMZW5ndGgoKVxuXHRcdCk7XG5cdH0sXG5cblx0Z2V0UHBpOiAnI2dldFJlc29sdXRpb24nLFxuXG5cdGdldEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2U7XG5cdH0sXG5cblx0c2V0SW1hZ2U6IGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gZW1pdChldmVudCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKSxcblx0XHRcdFx0dHlwZSA9IGV2ZW50ICYmIGV2ZW50LnR5cGUgfHwgJ2xvYWQnO1xuXHRcdFx0aWYgKHZpZXcgJiYgdGhhdC5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRwYXBlciA9IHZpZXcuX3Njb3BlO1xuXHRcdFx0XHR0aGF0LmVtaXQodHlwZSwgbmV3IEV2ZW50KGV2ZW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcblx0XHRcdHNldFRpbWVvdXQoZW1pdCwgMCk7XG5cdFx0fSBlbHNlIGlmIChpbWFnZSkge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7XG5cdFx0XHRcdGxvYWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0dGhhdC5fc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHRcdGVtaXQoZXZlbnQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZW1pdFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gISEoaW1hZ2UgJiYgaW1hZ2Uuc3JjICYmIGltYWdlLmNvbXBsZXRlKTtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aCA6IDAsXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQgOiAwKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDEwMzMpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihfY2hhbmdlKSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZXh0KVxuXHRcdFx0dGhpcy5fY29udGV4dCA9IHRoaXMuZ2V0Q2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoX2NoYW5nZSkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMDI1KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5faW1hZ2U7XG5cdFx0cmV0dXJuIGltYWdlICYmIGltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIGltYWdlID0gbmV3IHNlbGYuSW1hZ2UoKSxcblx0XHRcdGNyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW47XG5cdFx0aWYgKGNyb3NzT3JpZ2luKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAoc3JjKVxuXHRcdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRyZXR1cm4gaW1hZ2UgJiYgaW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcblx0XHRpZiAoaW1hZ2UpXG5cdFx0XHRpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldFNtb290aGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Ntb290aGluZztcblx0fSxcblxuXHRzZXRTbW9vdGhpbmc6IGZ1bmN0aW9uKHNtb290aGluZykge1xuXHRcdHRoaXMuX3Ntb290aGluZyA9IHNtb290aGluZztcblx0XHR0aGlzLl9jaGFuZ2VkKDI1Nyk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9sb2FkZWQgJiYgdGhpcy5faW1hZ2U7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldFN1YkNhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChyZWN0LmdldFNpemUoKSk7XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmdldENhbnZhcygpLCByZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3R4LmNhbnZhcztcblx0fSxcblxuXHRnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5fc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVwZW5kKHRoaXMuX21hdHJpeCk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0dG9EYXRhVVJMOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLl9pbWFnZSxcblx0XHRcdHNyYyA9IGltYWdlICYmIGltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cykgOiBudWxsO1xuXHR9LFxuXG5cdGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2UgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEF2ZXJhZ2VDb2xvcjogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0dmFyIGJvdW5kcywgcGF0aDtcblx0XHRpZiAoIW9iamVjdCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFBhdGhJdGVtKSB7XG5cdFx0XHRwYXRoID0gb2JqZWN0O1xuXHRcdFx0Ym91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICgnd2lkdGgnIGluIG9iamVjdCkge1xuXHRcdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKCd4JyBpbiBvYmplY3QpIHtcblx0XHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWJvdW5kcylcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRjdHguZHJhd0ltYWdlKGVsZW1lbnQsIC1zaXplLndpZHRoIC8gMiwgLXNpemUuaGVpZ2h0IC8gMik7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLjUsIDAuNSwgTWF0aC5jZWlsKHdpZHRoKSxcblx0XHRcdFx0TWF0aC5jZWlsKGhlaWdodCkpLmRhdGEsXG5cdFx0XHRjaGFubmVscyA9IFswLCAwLCAwXSxcblx0XHRcdHRvdGFsID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBpeGVscy5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdHZhciBhbHBoYSA9IHBpeGVsc1tpICsgM107XG5cdFx0XHR0b3RhbCArPSBhbHBoYTtcblx0XHRcdGFscGhhIC89IDI1NTtcblx0XHRcdGNoYW5uZWxzWzBdICs9IHBpeGVsc1tpXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMV0gKz0gcGl4ZWxzW2kgKyAxXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMl0gKz0gcGl4ZWxzW2kgKyAyXSAqIGFscGhhO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKylcblx0XHRcdGNoYW5uZWxzW2ldIC89IHRvdGFsO1xuXHRcdHJldHVybiB0b3RhbCA/IENvbG9yLnJlYWQoY2hhbm5lbHMpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHBvaW50LngsIHBvaW50LnksIDEsIDEpLmRhdGE7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigncmdiJywgW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdLFxuXHRcdFx0XHRkYXRhWzNdIC8gMjU1KTtcblx0fSxcblxuXHRzZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb21wb25lbnRzID0gY29sb3IuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0YWxwaGEgPSBjb2xvci5fYWxwaGEsXG5cdFx0XHRjdHggPSB0aGlzLmdldENvbnRleHQodHJ1ZSksXG5cdFx0XHRpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDEsIDEpLFxuXHRcdFx0ZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdGRhdGFbMF0gPSBjb21wb25lbnRzWzBdICogMjU1O1xuXHRcdGRhdGFbMV0gPSBjb21wb25lbnRzWzFdICogMjU1O1xuXHRcdGRhdGFbMl0gPSBjb21wb25lbnRzWzJdICogMjU1O1xuXHRcdGRhdGFbM10gPSBhbHBoYSAhPSBudWxsID8gYWxwaGEgKiAyNTUgOiAyNTU7XG5cdFx0Y3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhyZWN0KSA6IHJlY3Q7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsZW1lbnQgJiYgZWxlbWVudC53aWR0aCA+IDAgJiYgZWxlbWVudC5oZWlnaHQgPiAwKSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcGFjaXR5O1xuXG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cblx0XHRcdERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoXG5cdFx0XHRcdGN0eCwgJ2ltYWdlU21vb3RoaW5nRW5hYmxlZCcsIHRoaXMuX3Ntb290aGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFN5bWJvbEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbEl0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzT3B0aW9uczogeyBzdHJva2U6IHRydWUgfSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbEl0ZW0oYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihhcmcwIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbiA/XG5cdFx0XHRcdFx0YXJnMCA6IG5ldyBTeW1ib2xEZWZpbml0aW9uKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlZmluaXRpb24gPT09IGl0ZW0uX2RlZmluaXRpb247XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0RGVmaW5pdGlvbihzb3VyY2UuX2RlZmluaXRpb24pO1xuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGRlZmluaXRpb24pIHtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogJyNnZXREZWZpbml0aW9uJyxcblx0c2V0U3ltYm9sOiAnI3NldERlZmluaXRpb24nLFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uLl9pdGVtLmlzRW1wdHkoKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2RlZmluaXRpb24uX2l0ZW07XG5cdFx0cmV0dXJuIGl0ZW0uX2dldENhY2hlZEJvdW5kcyhpdGVtLl9tYXRyaXgucHJlcGVuZGVkKG1hdHJpeCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcblx0XHR2YXIgcmVzID0gdGhpcy5fZGVmaW5pdGlvbi5faXRlbS5faGl0VGVzdChwb2ludCwgb3B0aW9ucywgdmlld01hdHJpeCk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5fZGVmaW5pdGlvbi5faXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHR9XG5cbn0pO1xuXG52YXIgU3ltYm9sRGVmaW5pdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU3ltYm9sRGVmaW5pdGlvbicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sRGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0SXRlbShpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5faXRlbV0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpXG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdGlmIChmbGFncyAmIDEpXG5cdFx0XHR0aGlzLnByb2plY3QuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3N5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2l0ZW0pXG5cdFx0XHR0aGlzLl9pdGVtLl9zeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3N5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiAnI2dldEl0ZW0nLFxuXHRzZXREZWZpbml0aW9uOiAnI3NldEl0ZW0nLFxuXG5cdHBsYWNlOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sSXRlbSh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbih0aGlzLl9pdGVtLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRyZXR1cm4gc3ltYm9sID09PSB0aGlzXG5cdFx0XHRcdHx8IHN5bWJvbCAmJiB0aGlzLl9pdGVtLmVxdWFscyhzeW1ib2wuX2l0ZW0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpXG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihhcmdzKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3MgJiYgQmFzZS5yZWFkKGFyZ3MpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2V0KHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0cG9zaXRpb246IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cdF9zZWxlY3Rpb246IDAsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0LCBzZWxlY3Rpb247XG5cdFx0aWYgKGNvdW50ID4gMCkge1xuXHRcdFx0aWYgKGFyZzAgPT0gbnVsbCB8fCB0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAxICYmIGFyZzAgJiYgJ3BvaW50JyBpbiBhcmcwKSB7XG5cdFx0XHRcdFx0cG9pbnQgPSBhcmcwLnBvaW50O1xuXHRcdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBhcmcwLnNlbGVjdGlvbjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0XHRcdGhhbmRsZU91dCA9IGFyZzI7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gYXJnMztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBbIGFyZzAsIGFyZzEgXTtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcyICE9PSB1bmRlZmluZWQgPyBbIGFyZzIsIGFyZzMgXSA6IG51bGw7XG5cdFx0XHRcdGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0bmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcblx0XHRpZiAoc2VsZWN0aW9uKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb24sXG5cdFx0XHRvYmogPSBzZWxlY3Rpb24gfHwgdGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0XHQ/IFtwb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dF1cblx0XHRcdFx0XHQ6IHBvaW50O1xuXHRcdGlmIChzZWxlY3Rpb24pXG5cdFx0XHRvYmoucHVzaChzZWxlY3Rpb24pO1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRpZiAoIXBhdGgpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIGN1cnZlcyA9IHBhdGguX2N1cnZlcyxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXgsXG5cdFx0XHRjdXJ2ZTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluKVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGluZGV4ID4gMCA/IGN1cnZlc1tpbmRleCAtIDFdIDogcGF0aC5fY2xvc2VkXG5cdFx0XHRcdFx0XHQ/IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0gOiBudWxsKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHRcdGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0KVxuXHRcdFx0XHRcdCYmIChjdXJ2ZSA9IGN1cnZlc1tpbmRleF0pKVxuXHRcdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRwYXRoLl9jaGFuZ2VkKDQxKTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSB8fCAhdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdGlzU21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlSW4gPSB0aGlzLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZU91dCA9IHRoaXMuX2hhbmRsZU91dDtcblx0XHRyZXR1cm4gIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xsaW5lYXIoaGFuZGxlT3V0KTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2hhbmRsZUluLl9zZXQoMCwgMCk7XG5cdFx0dGhpcy5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuXHR9LFxuXG5cdHNldFNlbGVjdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cdFx0dmFyIG9sZFNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbixcblx0XHRcdHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCAwO1xuXHRcdGlmIChwYXRoICYmIHNlbGVjdGlvbiAhPT0gb2xkU2VsZWN0aW9uKSB7XG5cdFx0XHRwYXRoLl91cGRhdGVTZWxlY3Rpb24odGhpcywgb2xkU2VsZWN0aW9uLCBzZWxlY3Rpb24pO1xuXHRcdFx0cGF0aC5fY2hhbmdlZCgyNTcpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlU2VsZWN0aW9uOiBmdW5jdGlvbihmbGFnLCBzZWxlY3RlZCkge1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG5cdFx0dGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0ZWQgPyBzZWxlY3Rpb24gfCBmbGFnIDogc2VsZWN0aW9uICYgfmZsYWcpO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhISh0aGlzLl9zZWxlY3Rpb24gJiA3KTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9jaGFuZ2VTZWxlY3Rpb24oNywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKG9wdGlvbnMsIF9maXJzdCwgX2xhc3QpIHtcblx0XHR2YXIgb3B0cyA9IG9wdGlvbnMgfHwge30sXG5cdFx0XHR0eXBlID0gb3B0cy50eXBlLFxuXHRcdFx0ZmFjdG9yID0gb3B0cy5mYWN0b3IsXG5cdFx0XHRwcmV2ID0gdGhpcy5nZXRQcmV2aW91cygpLFxuXHRcdFx0bmV4dCA9IHRoaXMuZ2V0TmV4dCgpLFxuXHRcdFx0cDAgPSAocHJldiB8fCB0aGlzKS5fcG9pbnQsXG5cdFx0XHRwMSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0cDIgPSAobmV4dCB8fCB0aGlzKS5fcG9pbnQsXG5cdFx0XHRkMSA9IHAwLmdldERpc3RhbmNlKHAxKSxcblx0XHRcdGQyID0gcDEuZ2V0RGlzdGFuY2UocDIpO1xuXHRcdGlmICghdHlwZSB8fCB0eXBlID09PSAnY2F0bXVsbC1yb20nKSB7XG5cdFx0XHR2YXIgYSA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC41IDogZmFjdG9yLFxuXHRcdFx0XHRkMV9hID0gTWF0aC5wb3coZDEsIGEpLFxuXHRcdFx0XHRkMV8yYSA9IGQxX2EgKiBkMV9hLFxuXHRcdFx0XHRkMl9hID0gTWF0aC5wb3coZDIsIGEpLFxuXHRcdFx0XHRkMl8yYSA9IGQyX2EgKiBkMl9hO1xuXHRcdFx0aWYgKCFfZmlyc3QgJiYgcHJldikge1xuXHRcdFx0XHR2YXIgQSA9IDIgKiBkMl8yYSArIDMgKiBkMl9hICogZDFfYSArIGQxXzJhLFxuXHRcdFx0XHRcdE4gPSAzICogZDJfYSAqIChkMl9hICsgZDFfYSk7XG5cdFx0XHRcdHRoaXMuc2V0SGFuZGxlSW4oTiAhPT0gMFxuXHRcdFx0XHRcdD8gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0KGQyXzJhICogcDAuX3ggKyBBICogcDEuX3ggLSBkMV8yYSAqIHAyLl94KSAvIE4gLSBwMS5feCxcblx0XHRcdFx0XHRcdChkMl8yYSAqIHAwLl95ICsgQSAqIHAxLl95IC0gZDFfMmEgKiBwMi5feSkgLyBOIC0gcDEuX3kpXG5cdFx0XHRcdFx0OiBuZXcgUG9pbnQoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIV9sYXN0ICYmIG5leHQpIHtcblx0XHRcdFx0dmFyIEEgPSAyICogZDFfMmEgKyAzICogZDFfYSAqIGQyX2EgKyBkMl8yYSxcblx0XHRcdFx0XHROID0gMyAqIGQxX2EgKiAoZDFfYSArIGQyX2EpO1xuXHRcdFx0XHR0aGlzLnNldEhhbmRsZU91dChOICE9PSAwXG5cdFx0XHRcdFx0PyBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHQoZDFfMmEgKiBwMi5feCArIEEgKiBwMS5feCAtIGQyXzJhICogcDAuX3gpIC8gTiAtIHAxLl94LFxuXHRcdFx0XHRcdFx0KGQxXzJhICogcDIuX3kgKyBBICogcDEuX3kgLSBkMl8yYSAqIHAwLl95KSAvIE4gLSBwMS5feSlcblx0XHRcdFx0XHQ6IG5ldyBQb2ludCgpKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdnZW9tZXRyaWMnKSB7XG5cdFx0XHRpZiAocHJldiAmJiBuZXh0KSB7XG5cdFx0XHRcdHZhciB2ZWN0b3IgPSBwMC5zdWJ0cmFjdChwMiksXG5cdFx0XHRcdFx0dCA9IGZhY3RvciA9PT0gdW5kZWZpbmVkID8gMC40IDogZmFjdG9yLFxuXHRcdFx0XHRcdGsgPSB0ICogZDEgLyAoZDEgKyBkMik7XG5cdFx0XHRcdGlmICghX2ZpcnN0KVxuXHRcdFx0XHRcdHRoaXMuc2V0SGFuZGxlSW4odmVjdG9yLm11bHRpcGx5KGspKTtcblx0XHRcdFx0aWYgKCFfbGFzdClcblx0XHRcdFx0XHR0aGlzLnNldEhhbmRsZU91dCh2ZWN0b3IubXVsdGlwbHkoayAtIHQpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTbW9vdGhpbmcgbWV0aG9kIFxcJycgKyB0eXBlICsgJ1xcJyBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5faW5kZXggPT09IHBhdGguX3NlZ21lbnRzLmxlbmd0aCAtIDEgfHwgZmFsc2U7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZUluID0gdGhpcy5faGFuZGxlSW4sXG5cdFx0XHRoYW5kbGVPdXQgPSB0aGlzLl9oYW5kbGVPdXQsXG5cdFx0XHR0bXAgPSBoYW5kbGVJbi5jbG9uZSgpO1xuXHRcdGhhbmRsZUluLnNldChoYW5kbGVPdXQpO1xuXHRcdGhhbmRsZU91dC5zZXQodG1wKTtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVPdXQsIHRoaXMuX2hhbmRsZUluKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoID8gISF0aGlzLl9wYXRoLnJlbW92ZVNlZ21lbnQodGhpcy5faW5kZXgpIDogZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0cmV0dXJuIHNlZ21lbnQgPT09IHRoaXMgfHwgc2VnbWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gc2VnbWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fcG9pbnQuZXF1YWxzKHNlZ21lbnQuX3BvaW50KVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVJbi5lcXVhbHMoc2VnbWVudC5faGFuZGxlSW4pXG5cdFx0XHRcdCYmIHRoaXMuX2hhbmRsZU91dC5lcXVhbHMoc2VnbWVudC5faGFuZGxlT3V0KVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gWyAncG9pbnQ6ICcgKyB0aGlzLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVJbjogJyArIHRoaXMuX2hhbmRsZUluKTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZU91dDogJyArIHRoaXMuX2hhbmRsZU91dCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCB0cnVlKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcblx0XHR2YXIgdSA9IDEgLSBmYWN0b3IsXG5cdFx0XHR2ID0gZmFjdG9yLFxuXHRcdFx0cG9pbnQxID0gZnJvbS5fcG9pbnQsXG5cdFx0XHRwb2ludDIgPSB0by5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbjEgPSBmcm9tLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZUluMiA9IHRvLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZU91dDIgPSB0by5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlT3V0MSA9IGZyb20uX2hhbmRsZU91dDtcblx0XHR0aGlzLl9wb2ludC5fc2V0KFxuXHRcdFx0XHR1ICogcG9pbnQxLl94ICsgdiAqIHBvaW50Mi5feCxcblx0XHRcdFx0dSAqIHBvaW50MS5feSArIHYgKiBwb2ludDIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2hhbmRsZUluLl9zZXQoXG5cdFx0XHRcdHUgKiBoYW5kbGVJbjEuX3ggKyB2ICogaGFuZGxlSW4yLl94LFxuXHRcdFx0XHR1ICogaGFuZGxlSW4xLl95ICsgdiAqIGhhbmRsZUluMi5feSwgdHJ1ZSk7XG5cdFx0dGhpcy5faGFuZGxlT3V0Ll9zZXQoXG5cdFx0XHRcdHUgKiBoYW5kbGVPdXQxLl94ICsgdiAqIGhhbmRsZU91dDIuX3gsXG5cdFx0XHRcdHUgKiBoYW5kbGVPdXQxLl95ICsgdiAqIGhhbmRsZU91dDIuX3ksIHRydWUpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcblx0XHRcdGhhbmRsZUluID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZUluIDogbnVsbCxcblx0XHRcdGhhbmRsZU91dCA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcblx0XHRcdHggPSBwb2ludC5feCxcblx0XHRcdHkgPSBwb2ludC5feSxcblx0XHRcdGkgPSAyO1xuXHRcdGNvb3Jkc1swXSA9IHg7XG5cdFx0Y29vcmRzWzFdID0geTtcblx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll95ICsgeTtcblx0XHR9XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgaSAvIDIpO1xuXHRcdFx0eCA9IGNvb3Jkc1swXTtcblx0XHRcdHkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoY2hhbmdlKSB7XG5cdFx0XHRcdHBvaW50Ll94ID0geDtcblx0XHRcdFx0cG9pbnQuX3kgPSB5O1xuXHRcdFx0XHRpID0gMjtcblx0XHRcdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlSW4uX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3kgPSBjb29yZHNbaSsrXSAtIHk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICghaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY29vcmRzO1xuXHR9XG59KTtcblxudmFyIFNlZ21lbnRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnRQb2ludChwb2ludCwgb3duZXIsIGtleSkge1xuXHRcdHZhciB4LCB5LFxuXHRcdFx0c2VsZWN0ZWQ7XG5cdFx0aWYgKCFwb2ludCkge1xuXHRcdFx0eCA9IHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoKHggPSBwb2ludFswXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0eSA9IHBvaW50WzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHQgPSBwb2ludDtcblx0XHRcdGlmICgoeCA9IHB0LngpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHggPSBwdC54O1xuXHRcdFx0fVxuXHRcdFx0eSA9IHB0Lnk7XG5cdFx0XHRzZWxlY3RlZCA9IHB0LnNlbGVjdGVkO1xuXHRcdH1cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdG93bmVyW2tleV0gPSB0aGlzO1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHRoaXMuX3gpICYmIGlzWmVybyh0aGlzLl95KTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fb3duZXIuX3NlbGVjdGlvbiAmIHRoaXMuX2dldFNlbGVjdGlvbigpKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlU2VsZWN0aW9uKHRoaXMuX2dldFNlbGVjdGlvbigpLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X2dldFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0cmV0dXJuIHRoaXMgPT09IG93bmVyLl9wb2ludCA/IDFcblx0XHRcdDogdGhpcyA9PT0gb3duZXIuX2hhbmRsZUluID8gMlxuXHRcdFx0OiB0aGlzID09PSBvd25lci5faGFuZGxlT3V0ID8gNFxuXHRcdFx0OiAwO1xuXHR9XG59KTtcblxudmFyIEN1cnZlID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDdXJ2ZScsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0c2VnMSwgc2VnMixcblx0XHRcdHBvaW50MSwgcG9pbnQyLFxuXHRcdFx0aGFuZGxlMSwgaGFuZGxlMjtcblx0XHRpZiAoY291bnQgPT09IDMpIHtcblx0XHRcdHRoaXMuX3BhdGggPSBhcmcwO1xuXHRcdFx0c2VnMSA9IGFyZzE7XG5cdFx0XHRzZWcyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKCFjb3VudCkge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHRzZWcyID0gbmV3IFNlZ21lbnQoKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoJ3NlZ21lbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuXHRcdFx0fSBlbHNlIGlmICgncG9pbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHBvaW50MSA9IGFyZzAucG9pbnQxO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMC5oYW5kbGUxO1xuXHRcdFx0XHRoYW5kbGUyID0gYXJnMC5oYW5kbGUyO1xuXHRcdFx0XHRwb2ludDIgPSBhcmcwLnBvaW50Mjtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHRwb2ludDEgPSBbYXJnMFswXSwgYXJnMFsxXV07XG5cdFx0XHRcdHBvaW50MiA9IFthcmcwWzZdLCBhcmcwWzddXTtcblx0XHRcdFx0aGFuZGxlMSA9IFthcmcwWzJdIC0gYXJnMFswXSwgYXJnMFszXSAtIGFyZzBbMV1dO1xuXHRcdFx0XHRoYW5kbGUyID0gW2FyZzBbNF0gLSBhcmcwWzZdLCBhcmcwWzVdIC0gYXJnMFs3XV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KGFyZzApO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcblx0XHRcdHBvaW50MSA9IGFyZzA7XG5cdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdGhhbmRsZTIgPSBhcmcyO1xuXHRcdFx0cG9pbnQyID0gYXJnMztcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRwb2ludDEgPSBbYXJnMCwgYXJnMV07XG5cdFx0XHRwb2ludDIgPSBbYXJnNiwgYXJnN107XG5cdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG5cdFx0fVxuXHRcdHRoaXMuX3NlZ21lbnQxID0gc2VnMSB8fCBuZXcgU2VnbWVudChwb2ludDEsIG51bGwsIGhhbmRsZTEpO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnMiB8fCBuZXcgU2VnbWVudChwb2ludDIsIGhhbmRsZTIsIG51bGwpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0PyBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRIYW5kbGUxKCksIHRoaXMuZ2V0SGFuZGxlMigpLFxuXHRcdFx0XHRcdHRoaXMuZ2V0UG9pbnQyKCldXG5cdFx0XHRcdDogW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0UG9pbnQyKCldLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRjbGFzc2lmeTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmNsYXNzaWZ5KHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG5cdFx0XHRpZiAocmVtb3ZlZClcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoaGFuZGxlT3V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Z2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDE7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG5cdH0sXG5cblx0aXNGaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0aXNMYXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0cmV0dXJuIHBhdGggJiYgdGhpcy5fc2VnbWVudDEuX2luZGV4ID09PSBwYXRoLl9jdXJ2ZXMubGVuZ3RoIC0gMVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludDEoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldFBvaW50MigpLmlzU2VsZWN0ZWQoKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLmdldFBvaW50MSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0UG9pbnQyKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFZhbHVlcyh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIsIG1hdHJpeCk7XG5cdH0sXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSkpO1xuXHRcdHJldHVybiBwb2ludHM7XG5cdH1cbn0sIHtcblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpXG5cdFx0XHR0aGlzLl9sZW5ndGggPSBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRnZXRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IExpbmUodGhpcy5fc2VnbWVudDEuX3BvaW50LCB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZShDdXJ2ZS5nZXRQYXJ0KHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKSk7XG5cdH0sXG5cblx0Z2V0UGFydExlbmd0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIGZyb20sIHRvKTtcblx0fSxcblxuXHRkaXZpZGVBdDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUobG9jYXRpb24gJiYgbG9jYXRpb24uY3VydmUgPT09IHRoaXNcblx0XHRcdFx0PyBsb2NhdGlvbi50aW1lIDogdGhpcy5nZXRUaW1lQXQobG9jYXRpb24pKTtcblx0fSxcblxuXHRkaXZpZGVBdFRpbWU6IGZ1bmN0aW9uKHRpbWUsIF9zZXRIYW5kbGVzKSB7XG5cdFx0dmFyIHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAodGltZSA+PSB0TWluICYmIHRpbWUgPD0gdE1heCkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHRpbWUpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV0sXG5cdFx0XHRcdHNldEhhbmRsZXMgPSBfc2V0SGFuZGxlcyB8fCB0aGlzLmhhc0hhbmRsZXMoKSxcblx0XHRcdFx0c2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0XHRzZWcyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdFx0aWYgKHNldEhhbmRsZXMpIHtcblx0XHRcdFx0c2VnMS5faGFuZGxlT3V0Ll9zZXQobGVmdFsyXSAtIGxlZnRbMF0sIGxlZnRbM10gLSBsZWZ0WzFdKTtcblx0XHRcdFx0c2VnMi5faGFuZGxlSW4uX3NldChyaWdodFs0XSAtIHJpZ2h0WzZdLHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSBsZWZ0WzZdLCB5ID0gbGVmdFs3XSxcblx0XHRcdFx0c2VnbWVudCA9IG5ldyBTZWdtZW50KG5ldyBQb2ludCh4LCB5KSxcblx0XHRcdFx0XHRcdHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0cGF0aC5pbnNlcnQoc2VnMS5faW5kZXggKyAxLCBzZWdtZW50KTtcblx0XHRcdFx0cmVzID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZ21lbnQ7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdFx0cmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIHNlZzIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0QXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoID8gcGF0aC5zcGxpdEF0KGxvY2F0aW9uKSA6IG51bGw7XG5cdH0sXG5cblx0c3BsaXRBdFRpbWU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zcGxpdEF0KHRoaXMuZ2V0TG9jYXRpb25BdFRpbWUodGltZSkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24ob2Zmc2V0LCBpc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVBdFRpbWUob2Zmc2V0ID09PSB1bmRlZmluZWQgPyAwLjUgOiBpc1RpbWUgPyBvZmZzZXRcblx0XHRcdFx0OiB0aGlzLmdldFRpbWVBdChvZmZzZXQpKTtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1RpbWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zcGxpdEF0VGltZShvZmZzZXQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IGlzVGltZSA/IG9mZnNldFxuXHRcdFx0XHQ6IHRoaXMuZ2V0VGltZUF0KG9mZnNldCkpO1xuXHR9LFxuXG5cdHJldmVyc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2VkKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2VkKCkpO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5fc2V0KDAsIDApO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldFZhbHVlczogZnVuY3Rpb24oc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgsIHN0cmFpZ2h0KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHgxID0gcDEueCwgeTEgPSBwMS55LFxuXHRcdFx0eDIgPSBwMi54LCB5MiA9IHAyLnksXG5cdFx0XHR2YWx1ZXMgPSBzdHJhaWdodFxuXHRcdFx0XHQ/IFsgeDEsIHkxLCB4MSwgeTEsIHgyLCB5MiwgeDIsIHkyIF1cblx0XHRcdFx0OiBbXG5cdFx0XHRcdFx0eDEsIHkxLFxuXHRcdFx0XHRcdHgxICsgaDEuX3gsIHkxICsgaDEuX3ksXG5cdFx0XHRcdFx0eDIgKyBoMi5feCwgeTIgKyBoMi5feSxcblx0XHRcdFx0XHR4MiwgeTJcblx0XHRcdFx0XTtcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyh2YWx1ZXMsIHZhbHVlcywgNCk7XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRzdWJkaXZpZGU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHg0ID0gdSAqIHgwICsgdCAqIHgxLCB5NCA9IHUgKiB5MCArIHQgKiB5MSxcblx0XHRcdHg1ID0gdSAqIHgxICsgdCAqIHgyLCB5NSA9IHUgKiB5MSArIHQgKiB5Mixcblx0XHRcdHg2ID0gdSAqIHgyICsgdCAqIHgzLCB5NiA9IHUgKiB5MiArIHQgKiB5Myxcblx0XHRcdHg3ID0gdSAqIHg0ICsgdCAqIHg1LCB5NyA9IHUgKiB5NCArIHQgKiB5NSxcblx0XHRcdHg4ID0gdSAqIHg1ICsgdCAqIHg2LCB5OCA9IHUgKiB5NSArIHQgKiB5Nixcblx0XHRcdHg5ID0gdSAqIHg3ICsgdCAqIHg4LCB5OSA9IHUgKiB5NyArIHQgKiB5ODtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3gwLCB5MCwgeDQsIHk0LCB4NywgeTcsIHg5LCB5OV0sXG5cdFx0XHRbeDksIHk5LCB4OCwgeTgsIHg2LCB5NiwgeDMsIHkzXVxuXHRcdF07XG5cdH0sXG5cblx0Z2V0TW9ub0N1cnZlczogZnVuY3Rpb24odiwgZGlyKSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0aW8gPSBkaXIgPyAwIDogMSxcblx0XHRcdG8wID0gdltpbyArIDBdLFxuXHRcdFx0bzEgPSB2W2lvICsgMl0sXG5cdFx0XHRvMiA9IHZbaW8gKyA0XSxcblx0XHRcdG8zID0gdltpbyArIDZdO1xuXHRcdGlmICgobzAgPj0gbzEpID09PSAobzEgPj0gbzIpICYmIChvMSA+PSBvMikgPT09IChvMiA+PSBvMylcblx0XHRcdFx0fHwgQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0Y3VydmVzLnB1c2godik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhID0gMyAqIChvMSAtIG8yKSAtIG8wICsgbzMsXG5cdFx0XHRcdGIgPSAyICogKG8wICsgbzIpIC0gNCAqIG8xLFxuXHRcdFx0XHRjID0gbzEgLSBvMCxcblx0XHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0biA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgdE1pbiwgdE1heCk7XG5cdFx0XHRpZiAoIW4pIHtcblx0XHRcdFx0Y3VydmVzLnB1c2godik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyb290cy5zb3J0KCk7XG5cdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzBdKTtcblx0XHRcdFx0aWYgKG4gPiAxKSB7XG5cdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG5cdFx0XHRcdFx0Y3VydmVzLnB1c2gocGFydHNbMF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1cnZlcy5wdXNoKHBhcnRzWzFdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHYwID0gdltjb29yZF0sXG5cdFx0XHR2MSA9IHZbY29vcmQgKyAyXSxcblx0XHRcdHYyID0gdltjb29yZCArIDRdLFxuXHRcdFx0djMgPSB2W2Nvb3JkICsgNl0sXG5cdFx0XHRyZXMgPSAwO1xuXHRcdGlmICggICEodjAgPCB2YWwgJiYgdjMgPCB2YWwgJiYgdjEgPCB2YWwgJiYgdjIgPCB2YWwgfHxcblx0XHRcdFx0djAgPiB2YWwgJiYgdjMgPiB2YWwgJiYgdjEgPiB2YWwgJiYgdjIgPiB2YWwpKSB7XG5cdFx0XHR2YXIgYyA9IDMgKiAodjEgLSB2MCksXG5cdFx0XHRcdGIgPSAzICogKHYyIC0gdjEpIC0gYyxcblx0XHRcdFx0YSA9IHYzIC0gdjAgLSBjIC0gYjtcblx0XHRcdHJlcyA9IE51bWVyaWNhbC5zb2x2ZUN1YmljKGEsIGIsIGMsIHYwIC0gdmFsLCByb290cywgbWluLCBtYXgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdGdldFRpbWVPZjogZnVuY3Rpb24odiwgcG9pbnQpIHtcblx0XHR2YXIgcDAgPSBuZXcgUG9pbnQodlswXSwgdlsxXSksXG5cdFx0XHRwMyA9IG5ldyBQb2ludCh2WzZdLCB2WzddKSxcblx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdGdlb21FcHNpbG9uID0gMWUtNyxcblx0XHRcdHQgPSBwb2ludC5pc0Nsb3NlKHAwLCBlcHNpbG9uKSA/IDBcblx0XHRcdCAgOiBwb2ludC5pc0Nsb3NlKHAzLCBlcHNpbG9uKSA/IDFcblx0XHRcdCAgOiBudWxsO1xuXHRcdGlmICh0ID09PSBudWxsKSB7XG5cdFx0XHR2YXIgY29vcmRzID0gW3BvaW50LngsIHBvaW50LnldLFxuXHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgYyA9IDA7IGMgPCAyOyBjKyspIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyh2LCBjLCBjb29yZHNbY10sIHJvb3RzLCAwLCAxKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHUgPSByb290c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuaXNDbG9zZShDdXJ2ZS5nZXRQb2ludCh2LCB1KSwgZ2VvbUVwc2lsb24pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzQ2xvc2UocDAsIGdlb21FcHNpbG9uKSA/IDBcblx0XHRcdCA6IHBvaW50LmlzQ2xvc2UocDMsIGdlb21FcHNpbG9uKSA/IDFcblx0XHRcdCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFRpbWU6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0aWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdHZ4ID0geDMgLSB4MCwgdnkgPSB5MyAtIHkwLFxuXHRcdFx0XHRkZXQgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcblx0XHRcdGlmIChkZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0dmFyIHUgPSAoKHBvaW50LnggLSB4MCkgKiB2eCArIChwb2ludC55IC0geTApICogdnkpIC8gZGV0O1xuXHRcdFx0cmV0dXJuIHUgPCAxZS0xMiA/IDBcblx0XHRcdFx0IDogdSA+IDAuOTk5OTk5OTk5OTk5ID8gMVxuXHRcdFx0XHQgOiBDdXJ2ZS5nZXRUaW1lT2Yodixcblx0XHRcdFx0XHRuZXcgUG9pbnQoeDAgKyB1ICogdngsIHkwICsgdSAqIHZ5KSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvdW50ID0gMTAwLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluVCA9IDA7XG5cblx0XHRmdW5jdGlvbiByZWZpbmUodCkge1xuXHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcblx0XHRcdFx0dmFyIGRpc3QgPSBwb2ludC5nZXREaXN0YW5jZShDdXJ2ZS5nZXRQb2ludCh2LCB0KSwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChkaXN0IDwgbWluRGlzdCkge1xuXHRcdFx0XHRcdG1pbkRpc3QgPSBkaXN0O1xuXHRcdFx0XHRcdG1pblQgPSB0O1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKylcblx0XHRcdHJlZmluZShpIC8gY291bnQpO1xuXG5cdFx0dmFyIHN0ZXAgPSAxIC8gKGNvdW50ICogMik7XG5cdFx0d2hpbGUgKHN0ZXAgPiAxZS04KSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0cmV0dXJuIG1pblQ7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHR2YXIgZmxpcCA9IGZyb20gPiB0bztcblx0XHRpZiAoZmxpcCkge1xuXHRcdFx0dmFyIHRtcCA9IGZyb207XG5cdFx0XHRmcm9tID0gdG87XG5cdFx0XHR0byA9IHRtcDtcblx0XHR9XG5cdFx0aWYgKGZyb20gPiAwKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCBmcm9tKVsxXTtcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdO1xuXHRcdHJldHVybiBmbGlwXG5cdFx0XHRcdD8gW3ZbNl0sIHZbN10sIHZbNF0sIHZbNV0sIHZbMl0sIHZbM10sIHZbMF0sIHZbMV1dXG5cdFx0XHRcdDogdjtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIGZsYXRuZXNzKSB7XG5cdFx0dmFyIHgwID0gdlswXSwgeTAgPSB2WzFdLFxuXHRcdFx0eDEgPSB2WzJdLCB5MSA9IHZbM10sXG5cdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddLFxuXHRcdFx0dXggPSAzICogeDEgLSAyICogeDAgLSB4Myxcblx0XHRcdHV5ID0gMyAqIHkxIC0gMiAqIHkwIC0geTMsXG5cdFx0XHR2eCA9IDMgKiB4MiAtIDIgKiB4MyAtIHgwLFxuXHRcdFx0dnkgPSAzICogeTIgLSAyICogeTMgLSB5MDtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8PSAxNiAqIGZsYXRuZXNzICogZmxhdG5lc3M7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XTtcblx0XHRyZXR1cm4gMyAqICgoeTMgLSB5MCkgKiAoeDEgKyB4MikgLSAoeDMgLSB4MCkgKiAoeTEgKyB5Milcblx0XHRcdFx0KyB5MSAqICh4MCAtIHgyKSAtIHgxICogKHkwIC0geTIpXG5cdFx0XHRcdCsgeTMgKiAoeDIgKyB4MCAvIDMpIC0geDMgKiAoeTIgKyB5MCAvIDMpKSAvIDIwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IFswLCAwXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKylcblx0XHRcdEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSxcblx0XHRcdFx0XHRpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0X2FkZEJvdW5kczogZnVuY3Rpb24odjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcblx0XHRmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcblx0XHRcdHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuXHRcdFx0XHRyaWdodCA9IHZhbHVlICsgcGFkZGluZztcblx0XHRcdGlmIChsZWZ0IDwgbWluW2Nvb3JkXSlcblx0XHRcdFx0bWluW2Nvb3JkXSA9IGxlZnQ7XG5cdFx0XHRpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuXHRcdFx0XHRtYXhbY29vcmRdID0gcmlnaHQ7XG5cdFx0fVxuXG5cdFx0cGFkZGluZyAvPSAyO1xuXHRcdHZhciBtaW5QYWQgPSBtaW5bY29vcmRdIC0gcGFkZGluZyxcblx0XHRcdG1heFBhZCA9IG1heFtjb29yZF0gKyBwYWRkaW5nO1xuXHRcdGlmICggICAgdjAgPCBtaW5QYWQgfHwgdjEgPCBtaW5QYWQgfHwgdjIgPCBtaW5QYWQgfHwgdjMgPCBtaW5QYWQgfHxcblx0XHRcdFx0djAgPiBtYXhQYWQgfHwgdjEgPiBtYXhQYWQgfHwgdjIgPiBtYXhQYWQgfHwgdjMgPiBtYXhQYWQpIHtcblx0XHRcdGlmICh2MSA8IHYwICE9IHYxIDwgdjMgJiYgdjIgPCB2MCAhPSB2MiA8IHYzKSB7XG5cdFx0XHRcdGFkZCh2MCwgcGFkZGluZyk7XG5cdFx0XHRcdGFkZCh2MywgcGFkZGluZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuXHRcdFx0XHRcdGIgPSAyICogKHYwICsgdjIpIC0gNCAqIHYxLFxuXHRcdFx0XHRcdGMgPSB2MSAtIHYwLFxuXHRcdFx0XHRcdGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcblx0XHRcdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0XHRcdGFkZCh2MywgMCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdFx0XHR1ID0gMSAtIHQ7XG5cdFx0XHRcdFx0aWYgKHRNaW4gPD0gdCAmJiB0IDw9IHRNYXgpXG5cdFx0XHRcdFx0XHRhZGQodSAqIHUgKiB1ICogdjBcblx0XHRcdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHRcdFx0KyAzICogdSAqIHQgKiB0ICogdjJcblx0XHRcdFx0XHRcdFx0KyB0ICogdCAqIHQgKiB2Myxcblx0XHRcdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn19LCBCYXNlLmVhY2goXG5cdFsnZ2V0Qm91bmRzJywgJ2dldFN0cm9rZUJvdW5kcycsICdnZXRIYW5kbGVCb3VuZHMnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV07XG5cdFx0XHRpZiAoIWJvdW5kcykge1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFxuXHRcdFx0XHRcdFx0W3RoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHMuY2xvbmUoKTtcblx0XHR9O1xuXHR9LFxue1xuXG59KSwgQmFzZS5lYWNoKHtcblx0aXNTdHJhaWdodDogZnVuY3Rpb24ocDEsIGgxLCBoMiwgcDIpIHtcblx0XHRpZiAoaDEuaXNaZXJvKCkgJiYgaDIuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdiA9IHAyLnN1YnRyYWN0KHAxKTtcblx0XHRcdGlmICh2LmlzWmVybygpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodi5pc0NvbGxpbmVhcihoMSkgJiYgdi5pc0NvbGxpbmVhcihoMikpIHtcblx0XHRcdFx0dmFyIGwgPSBuZXcgTGluZShwMSwgcDIpLFxuXHRcdFx0XHRcdGVwc2lsb24gPSAxZS03O1xuXHRcdFx0XHRpZiAobC5nZXREaXN0YW5jZShwMS5hZGQoaDEpKSA8IGVwc2lsb24gJiZcblx0XHRcdFx0XHRsLmdldERpc3RhbmNlKHAyLmFkZChoMikpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRcdHZhciBkaXYgPSB2LmRvdCh2KSxcblx0XHRcdFx0XHRcdHMxID0gdi5kb3QoaDEpIC8gZGl2LFxuXHRcdFx0XHRcdFx0czIgPSB2LmRvdChoMikgLyBkaXY7XG5cdFx0XHRcdFx0cmV0dXJuIHMxID49IDAgJiYgczEgPD0gMSAmJiBzMiA8PSAwICYmIHMyID49IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24ocDEsIGgxLCBoMiwgcDIpIHtcblx0XHR2YXIgdGhpcmQgPSBwMi5zdWJ0cmFjdChwMSkuZGl2aWRlKDMpO1xuXHRcdHJldHVybiBoMS5lcXVhbHModGhpcmQpICYmIGgyLm5lZ2F0ZSgpLmVxdWFscyh0aGlyZCk7XG5cdH1cbn0sIGZ1bmN0aW9uKHRlc3QsIG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGVwc2lsb24pIHtcblx0XHR2YXIgc2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0c2VnMiA9IHRoaXMuX3NlZ21lbnQyO1xuXHRcdHJldHVybiB0ZXN0KHNlZzEuX3BvaW50LCBzZWcxLl9oYW5kbGVPdXQsIHNlZzIuX2hhbmRsZUluLCBzZWcyLl9wb2ludCxcblx0XHRcdFx0ZXBzaWxvbik7XG5cdH07XG5cblx0dGhpcy5zdGF0aWNzW25hbWVdID0gZnVuY3Rpb24odiwgZXBzaWxvbikge1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgzID0gdls2XSwgeTMgPSB2WzddO1xuXHRcdHJldHVybiB0ZXN0KFxuXHRcdFx0XHRuZXcgUG9pbnQoeDAsIHkwKSxcblx0XHRcdFx0bmV3IFBvaW50KHZbMl0gLSB4MCwgdlszXSAtIHkwKSxcblx0XHRcdFx0bmV3IFBvaW50KHZbNF0gLSB4Mywgdls1XSAtIHkzKSxcblx0XHRcdFx0bmV3IFBvaW50KHgzLCB5MyksIGVwc2lsb24pO1xuXHR9O1xufSwge1xuXHRzdGF0aWNzOiB7fSxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0fHwgIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKTtcblx0fSxcblxuXHRoYXNMZW5ndGg6IGZ1bmN0aW9uKGVwc2lsb24pIHtcblx0XHRyZXR1cm4gKCF0aGlzLmdldFBvaW50MSgpLmVxdWFscyh0aGlzLmdldFBvaW50MigpKSB8fCB0aGlzLmhhc0hhbmRsZXMoKSlcblx0XHRcdFx0JiYgdGhpcy5nZXRMZW5ndGgoKSA+IChlcHNpbG9uIHx8IDApO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBjdXJ2ZSAmJiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZS5pc1N0cmFpZ2h0KClcblx0XHRcdFx0JiYgdGhpcy5nZXRMaW5lKCkuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TGluZSgpKTtcblx0fSxcblxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdFRpbWUoMC41KS55KVxuXHRcdFx0XHQ8IDFlLTg7XG5cdH0sXG5cblx0aXNWZXJ0aWNhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0VGltZSgwLjUpLngpXG5cdFx0XHRcdDwgMWUtODtcblx0fVxufSksIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCwgX2lzVGltZSkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKFxuXHRcdFx0XHRfaXNUaW1lID8gb2Zmc2V0IDogdGhpcy5nZXRUaW1lQXQob2Zmc2V0KSk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdFRpbWU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDFcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGltZUF0OiBmdW5jdGlvbihvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFRpbWVBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogJyNnZXRUaW1lQXQnLFxuXG5cdGdldFRpbWVzV2l0aFRhbmdlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGFuZ2VudC5pc1plcm8oKVxuXHRcdFx0XHQ/IFtdXG5cdFx0XHRcdDogQ3VydmUuZ2V0VGltZXNXaXRoVGFuZ2VudCh0aGlzLmdldFZhbHVlcygpLCB0YW5nZW50KTtcblx0fSxcblxuXHRnZXRPZmZzZXRBdFRpbWU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJ0TGVuZ3RoKDAsIHQpO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXRUaW1lKHRoaXMuZ2V0VGltZU9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0VGltZU9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VGltZU9mKHRoaXMuZ2V0VmFsdWVzKCksIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6ICcjZ2V0VGltZU9mJyxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHR0ID0gQ3VydmUuZ2V0TmVhcmVzdFRpbWUodmFsdWVzLCBwb2ludCksXG5cdFx0XHRwdCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQsIHB0LCBudWxsLCBwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRQb2ludCgpIDogbG9jO1xuXHR9XG5cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBtZXRob2RzID0gWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRXZWlnaHRlZFRhbmdlbnQnLFxuXHRcdCdnZXRXZWlnaHRlZE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXTtcblx0cmV0dXJuIEJhc2UuZWFjaChtZXRob2RzLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24obG9jYXRpb24sIF9pc1RpbWUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh2YWx1ZXMsIF9pc1RpbWUgPyBsb2NhdGlvblxuXHRcdFx0XHRcdFx0OiBDdXJ2ZS5nZXRUaW1lQXQodmFsdWVzLCBsb2NhdGlvbikpO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1tuYW1lICsgJ0F0VGltZSddID0gZnVuY3Rpb24odGltZSkge1xuXHRcdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5nZXRWYWx1ZXMoKSwgdGltZSk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdHN0YXRpY3M6IHtcblx0XHRcdFx0X2V2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqICh4MSAtIHgyKSArIDMgKiAoeDMgLSB4MCksXG5cdFx0XHRieCA9IDYgKiAoeDAgKyB4MikgLSAxMiAqIHgxLFxuXHRcdFx0Y3ggPSAzICogKHgxIC0geDApLFxuXG5cdFx0XHRheSA9IDkgKiAoeTEgLSB5MikgKyAzICogKHkzIC0geTApLFxuXHRcdFx0YnkgPSA2ICogKHkwICsgeTIpIC0gMTIgKiB5MSxcblx0XHRcdGN5ID0gMyAqICh5MSAtIHkwKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmFsdWF0ZSh2LCB0LCB0eXBlLCBub3JtYWxpemVkKSB7XG5cdFx0aWYgKHQgPT0gbnVsbCB8fCB0IDwgMCB8fCB0ID4gMSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4MCA9IHZbMF0sIHkwID0gdlsxXSxcblx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0eDIgPSB2WzRdLCB5MiA9IHZbNV0sXG5cdFx0XHR4MyA9IHZbNl0sIHkzID0gdls3XSxcblx0XHRcdGlzWmVybyA9IE51bWVyaWNhbC5pc1plcm87XG5cdFx0aWYgKGlzWmVybyh4MSAtIHgwKSAmJiBpc1plcm8oeTEgLSB5MCkpIHtcblx0XHRcdHgxID0geDA7XG5cdFx0XHR5MSA9IHkwO1xuXHRcdH1cblx0XHRpZiAoaXNaZXJvKHgyIC0geDMpICYmIGlzWmVybyh5MiAtIHkzKSkge1xuXHRcdFx0eDIgPSB4Mztcblx0XHRcdHkyID0geTM7XG5cdFx0fVxuXHRcdHZhciBjeCA9IDMgKiAoeDEgLSB4MCksXG5cdFx0XHRieCA9IDMgKiAoeDIgLSB4MSkgLSBjeCxcblx0XHRcdGF4ID0geDMgLSB4MCAtIGN4IC0gYngsXG5cdFx0XHRjeSA9IDMgKiAoeTEgLSB5MCksXG5cdFx0XHRieSA9IDMgKiAoeTIgLSB5MSkgLSBjeSxcblx0XHRcdGF5ID0geTMgLSB5MCAtIGN5IC0gYnksXG5cdFx0XHR4LCB5O1xuXHRcdGlmICh0eXBlID09PSAwKSB7XG5cdFx0XHR4ID0gdCA9PT0gMCA/IHgwIDogdCA9PT0gMSA/IHgzXG5cdFx0XHRcdFx0OiAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgeDA7XG5cdFx0XHR5ID0gdCA9PT0gMCA/IHkwIDogdCA9PT0gMSA/IHkzXG5cdFx0XHRcdFx0OiAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgeTA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdFx0aWYgKHQgPCB0TWluKSB7XG5cdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0eSA9IGN5O1xuXHRcdFx0fSBlbHNlIGlmICh0ID4gdE1heCkge1xuXHRcdFx0XHR4ID0gMyAqICh4MyAtIHgyKTtcblx0XHRcdFx0eSA9IDMgKiAoeTMgLSB5Mik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuXHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG5cdFx0XHRcdFx0eCA9IHgyIC0geDE7XG5cdFx0XHRcdFx0eSA9IHkyIC0geTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGxlbikge1xuXHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHR2YXIgeDIgPSA2ICogYXggKiB0ICsgMiAqIGJ4LFxuXHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRkID0gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHR4ID0gZCAhPT0gMCA/ICh4ICogeTIgLSB5ICogeDIpIC8gZCA6IDA7XG5cdFx0XHRcdHkgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cblx0XHRjbGFzc2lmeTogZnVuY3Rpb24odikge1xuXG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGExID0geDAgKiAoeTMgLSB5MikgKyB5MCAqICh4MiAtIHgzKSArIHgzICogeTIgLSB5MyAqIHgyLFxuXHRcdFx0XHRhMiA9IHgxICogKHkwIC0geTMpICsgeTEgKiAoeDMgLSB4MCkgKyB4MCAqIHkzIC0geTAgKiB4Myxcblx0XHRcdFx0YTMgPSB4MiAqICh5MSAtIHkwKSArIHkyICogKHgwIC0geDEpICsgeDEgKiB5MCAtIHkxICogeDAsXG5cdFx0XHRcdGQzID0gMyAqIGEzLFxuXHRcdFx0XHRkMiA9IGQzIC0gYTIsXG5cdFx0XHRcdGQxID0gZDIgLSBhMiArIGExLFxuXHRcdFx0XHRsID0gTWF0aC5zcXJ0KGQxICogZDEgKyBkMiAqIGQyICsgZDMgKiBkMyksXG5cdFx0XHRcdHMgPSBsICE9PSAwID8gMSAvIGwgOiAwLFxuXHRcdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvLFxuXHRcdFx0XHRzZXJwZW50aW5lID0gJ3NlcnBlbnRpbmUnO1xuXHRcdFx0ZDEgKj0gcztcblx0XHRcdGQyICo9IHM7XG5cdFx0XHRkMyAqPSBzO1xuXG5cdFx0XHRmdW5jdGlvbiB0eXBlKHR5cGUsIHQxLCB0Mikge1xuXHRcdFx0XHR2YXIgaGFzUm9vdHMgPSB0MSAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHQxT2sgPSBoYXNSb290cyAmJiB0MSA+IDAgJiYgdDEgPCAxLFxuXHRcdFx0XHRcdHQyT2sgPSBoYXNSb290cyAmJiB0MiA+IDAgJiYgdDIgPCAxO1xuXHRcdFx0XHRpZiAoaGFzUm9vdHMgJiYgKCEodDFPayB8fCB0Mk9rKVxuXHRcdFx0XHRcdFx0fHwgdHlwZSA9PT0gJ2xvb3AnICYmICEodDFPayAmJiB0Mk9rKSkpIHtcblx0XHRcdFx0XHR0eXBlID0gJ2FyY2gnO1xuXHRcdFx0XHRcdHQxT2sgPSB0Mk9rID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdHJvb3RzOiB0MU9rIHx8IHQyT2tcblx0XHRcdFx0XHRcdFx0PyB0MU9rICYmIHQyT2tcblx0XHRcdFx0XHRcdFx0XHQ/IHQxIDwgdDIgPyBbdDEsIHQyXSA6IFt0MiwgdDFdXG5cdFx0XHRcdFx0XHRcdFx0OiBbdDFPayA/IHQxIDogdDJdXG5cdFx0XHRcdFx0XHRcdDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNaZXJvKGQxKSkge1xuXHRcdFx0XHRyZXR1cm4gaXNaZXJvKGQyKVxuXHRcdFx0XHRcdFx0PyB0eXBlKGlzWmVybyhkMykgPyAnbGluZScgOiAncXVhZHJhdGljJylcblx0XHRcdFx0XHRcdDogdHlwZShzZXJwZW50aW5lLCBkMyAvICgzICogZDIpKTtcblx0XHRcdH1cblx0XHRcdHZhciBkID0gMyAqIGQyICogZDIgLSA0ICogZDEgKiBkMztcblx0XHRcdGlmIChpc1plcm8oZCkpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGUoJ2N1c3AnLCBkMiAvICgyICogZDEpKTtcblx0XHRcdH1cblx0XHRcdHZhciBmMSA9IGQgPiAwID8gTWF0aC5zcXJ0KGQgLyAzKSA6IE1hdGguc3FydCgtZCksXG5cdFx0XHRcdGYyID0gMiAqIGQxO1xuXHRcdFx0cmV0dXJuIHR5cGUoZCA+IDAgPyBzZXJwZW50aW5lIDogJ2xvb3AnLFxuXHRcdFx0XHRcdChkMiArIGYxKSAvIGYyLFxuXHRcdFx0XHRcdChkMiAtIGYxKSAvIGYyKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbih2LCBhLCBiLCBkcykge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdGlmIChDdXJ2ZS5pc1N0cmFpZ2h0KHYpKSB7XG5cdFx0XHRcdHZhciBjID0gdjtcblx0XHRcdFx0aWYgKGIgPCAxKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBiKVswXTtcblx0XHRcdFx0XHRhIC89IGI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEgPiAwKSB7XG5cdFx0XHRcdFx0YyA9IEN1cnZlLnN1YmRpdmlkZShjLCBhKVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZHggPSBjWzZdIC0gY1swXSxcblx0XHRcdFx0XHRkeSA9IGNbN10gLSBjWzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzIHx8IGdldExlbmd0aEludGVncmFuZCh2KSwgYSwgYixcblx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGltZUF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDA7XG5cdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gc3RhcnQ7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHYsIGEsIGIsIGRzKSxcblx0XHRcdFx0ZGlmZiA9IGFicyhvZmZzZXQpIC0gcmFuZ2VMZW5ndGg7XG5cdFx0XHRpZiAoYWJzKGRpZmYpIDwgZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuXHRcdFx0fSBlbHNlIGlmIChkaWZmID4gZXBzaWxvbikge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMzIsXG5cdFx0XHRcdFx0MWUtMTIpO1xuXHRcdH0sXG5cblx0XHRnZXRQb2ludDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDAsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIHRydWUpO1xuXHRcdH0sXG5cblx0XHRnZXRXZWlnaHRlZE5vcm1hbDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDIsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0Q3VydmF0dXJlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMywgZmFsc2UpLng7XG5cdFx0fSxcblxuXHRcdGdldFBlYWtzOiBmdW5jdGlvbih2KSB7XG5cdFx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHRcdHgxID0gdlsyXSwgeTEgPSB2WzNdLFxuXHRcdFx0XHR4MiA9IHZbNF0sIHkyID0gdls1XSxcblx0XHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRcdGF4ID0gICAgIC14MCArIDMgKiB4MSAtIDMgKiB4MiArIHgzLFxuXHRcdFx0XHRieCA9ICAzICogeDAgLSA2ICogeDEgKyAzICogeDIsXG5cdFx0XHRcdGN4ID0gLTMgKiB4MCArIDMgKiB4MSxcblx0XHRcdFx0YXkgPSAgICAgLXkwICsgMyAqIHkxIC0gMyAqIHkyICsgeTMsXG5cdFx0XHRcdGJ5ID0gIDMgKiB5MCAtIDYgKiB5MSArIDMgKiB5Mixcblx0XHRcdFx0Y3kgPSAtMyAqIHkwICsgMyAqIHkxLFxuXHRcdFx0XHR0TWluID0gMWUtOCxcblx0XHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0TnVtZXJpY2FsLnNvbHZlQ3ViaWMoXG5cdFx0XHRcdFx0OSAqIChheCAqIGF4ICsgYXkgKiBheSksXG5cdFx0XHRcdFx0OSAqIChheCAqIGJ4ICsgYnkgKiBheSksXG5cdFx0XHRcdFx0MiAqIChieCAqIGJ4ICsgYnkgKiBieSkgKyAzICogKGN4ICogYXggKyBjeSAqIGF5KSxcblx0XHRcdFx0XHQoY3ggKiBieCArIGJ5ICogY3kpLFxuXHRcdFx0XHRcdHJvb3RzLCB0TWluLCB0TWF4KTtcblx0XHRcdHJldHVybiByb290cy5zb3J0KCk7XG5cdFx0fVxuXHR9fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgdDEsIGMyLCB0Miwgb3ZlcmxhcCkge1xuXHRcdHZhciBleGNsdWRlU3RhcnQgPSAhb3ZlcmxhcCAmJiBjMS5nZXRQcmV2aW91cygpID09PSBjMixcblx0XHRcdGV4Y2x1ZGVFbmQgPSAhb3ZlcmxhcCAmJiBjMSAhPT0gYzIgJiYgYzEuZ2V0TmV4dCgpID09PSBjMixcblx0XHRcdHRNaW4gPSAxZS04LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0MSAhPT0gbnVsbCAmJiB0MSA+PSAoZXhjbHVkZVN0YXJ0ID8gdE1pbiA6IDApICYmXG5cdFx0XHR0MSA8PSAoZXhjbHVkZUVuZCA/IHRNYXggOiAxKSkge1xuXHRcdFx0aWYgKHQyICE9PSBudWxsICYmIHQyID49IChleGNsdWRlRW5kID8gdE1pbiA6IDApICYmXG5cdFx0XHRcdHQyIDw9IChleGNsdWRlU3RhcnQgPyB0TWF4IDogMSkpIHtcblx0XHRcdFx0dmFyIGxvYzEgPSBuZXcgQ3VydmVMb2NhdGlvbihjMSwgdDEsIG51bGwsIG92ZXJsYXApLFxuXHRcdFx0XHRcdGxvYzIgPSBuZXcgQ3VydmVMb2NhdGlvbihjMiwgdDIsIG51bGwsIG92ZXJsYXApO1xuXHRcdFx0XHRsb2MxLl9pbnRlcnNlY3Rpb24gPSBsb2MyO1xuXHRcdFx0XHRsb2MyLl9pbnRlcnNlY3Rpb24gPSBsb2MxO1xuXHRcdFx0XHRpZiAoIWluY2x1ZGUgfHwgaW5jbHVkZShsb2MxKSkge1xuXHRcdFx0XHRcdEN1cnZlTG9jYXRpb24uaW5zZXJ0KGxvY2F0aW9ucywgbG9jMSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgpIHtcblx0XHRpZiAoKytjYWxscyA+PSA0MDk2IHx8ICsrcmVjdXJzaW9uID49IDQwKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciBmYXRMaW5lRXBzaWxvbiA9IDFlLTksXG5cdFx0XHRxMHggPSB2MlswXSwgcTB5ID0gdjJbMV0sIHEzeCA9IHYyWzZdLCBxM3kgPSB2Mls3XSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSksXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0aHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRib3R0b20gPSBodWxsWzFdLFxuXHRcdFx0dE1pbkNsaXAsXG5cdFx0XHR0TWF4Q2xpcDtcblx0XHRpZiAoZDEgPT09IDAgJiYgZDIgPT09IDBcblx0XHRcdFx0JiYgZHAwID09PSAwICYmIGRwMSA9PT0gMCAmJiBkcDIgPT09IDAgJiYgZHAzID09PSAwXG5cdFx0XHR8fCAodE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCkpID09IG51bGxcblx0XHRcdHx8ICh0TWF4Q2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcC5yZXZlcnNlKCksIGJvdHRvbS5yZXZlcnNlKCksXG5cdFx0XHRcdGRNaW4sIGRNYXgpKSA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGNhbGxzO1xuXHRcdHZhciB0TWluTmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWluQ2xpcCxcblx0XHRcdHRNYXhOZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNYXhDbGlwO1xuXHRcdGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgZmF0TGluZUVwc2lsb24pIHtcblx0XHRcdHZhciB0ID0gKHRNaW5OZXcgKyB0TWF4TmV3KSAvIDIsXG5cdFx0XHRcdHUgPSAodU1pbiArIHVNYXgpIC8gMjtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRmbGlwID8gYzIgOiBjMSwgZmxpcCA/IHUgOiB0LFxuXHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdCA6IHUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG5cdFx0XHRpZiAodE1heENsaXAgLSB0TWluQ2xpcCA+IDAuOCkge1xuXHRcdFx0XHRpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1TWF4IC0gdU1pbikge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgMC41KSxcblx0XHRcdFx0XHRcdHQgPSAodE1pbk5ldyArIHRNYXhOZXcpIC8gMjtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djIsIHBhcnRzWzBdLCBjMiwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSwgIWZsaXAsXG5cdFx0XHRcdFx0XHRcdHJlY3Vyc2lvbiwgY2FsbHMsIHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQpO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdU1heCwgdCwgdE1heE5ldyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdFx0dSA9ICh1TWluICsgdU1heCkgLyAyO1xuXHRcdFx0XHRcdGNhbGxzID0gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBpbmNsdWRlLCAhZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdU1pbiwgdSwgdE1pbk5ldywgdE1heE5ldyk7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHBhcnRzWzFdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHVNYXggLSB1TWluID49IGZhdExpbmVFcHNpbG9uKSB7XG5cdFx0XHRcdFx0Y2FsbHMgPSBhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0XHRcdHYyLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIGluY2x1ZGUsICFmbGlwLFxuXHRcdFx0XHRcdFx0XHRyZWN1cnNpb24sIGNhbGxzLCB1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjYWxscyA9IGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRcdFx0djEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSwgZmxpcCxcblx0XHRcdFx0XHRcdFx0cmVjdXJzaW9uLCBjYWxscywgdE1pbk5ldywgdE1heE5ldywgdU1pbiwgdU1heCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhbGxzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRkaXN0MSA9IGRxMSAtICgyICogZHEwICsgZHEzKSAvIDMsXG5cdFx0XHRkaXN0MiA9IGRxMiAtIChkcTAgKyAyICogZHEzKSAvIDMsXG5cdFx0XHRodWxsO1xuXHRcdGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuXHRcdFx0aHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0UmF0aW8gPSBkaXN0MSAvIGRpc3QyO1xuXHRcdFx0aHVsbCA9IFtcblx0XHRcdFx0ZGlzdFJhdGlvID49IDIgPyBbcDAsIHAxLCBwM11cblx0XHRcdFx0OiBkaXN0UmF0aW8gPD0gMC41ID8gW3AwLCBwMiwgcDNdXG5cdFx0XHRcdDogW3AwLCBwMSwgcDIsIHAzXSxcblx0XHRcdFx0W3AwLCBwM11cblx0XHRcdF07XG5cdFx0fVxuXHRcdHJldHVybiAoZGlzdDEgfHwgZGlzdDIpIDwgMCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG5cdFx0fSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBodWxsVG9wWzBdWzBdO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuXHRcdHZhciBweCA9IHBhcnRbMF1bMF0sXG5cdFx0XHRweSA9IHBhcnRbMF1bMV07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHF4ID0gcGFydFtpXVswXSxcblx0XHRcdFx0cXkgPSBwYXJ0W2ldWzFdO1xuXHRcdFx0aWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZCkge1xuXHRcdFx0XHRyZXR1cm4gcXkgPT09IHRocmVzaG9sZCA/IHF4XG5cdFx0XHRcdFx0XHQ6IHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH1cblx0XHRcdHB4ID0gcXg7XG5cdFx0XHRweSA9IHF5O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEN1cnZlTGluZUludGVyc2VjdGlvbnModiwgcHgsIHB5LCB2eCwgdnkpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRpZiAoaXNaZXJvKHZ4KSAmJiBpc1plcm8odnkpKSB7XG5cdFx0XHR2YXIgdCA9IEN1cnZlLmdldFRpbWVPZih2LCBuZXcgUG9pbnQocHgsIHB5KSk7XG5cdFx0XHRyZXR1cm4gdCA9PT0gbnVsbCA/IFtdIDogW3RdO1xuXHRcdH1cblx0XHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKC12eSwgdngpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cnYgPSBbXSxcblx0XHRcdHJvb3RzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdltpXSAtIHB4LFxuXHRcdFx0XHR5ID0gdltpICsgMV0gLSBweTtcblx0XHRcdHJ2LnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR4ICogc2luICsgeSAqIGNvcyk7XG5cdFx0fVxuXHRcdEN1cnZlLnNvbHZlQ3ViaWMocnYsIDEsIDAsIHJvb3RzLCAwLCAxKTtcblx0XHRyZXR1cm4gcm9vdHM7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRmbGlwKSB7XG5cdFx0dmFyIHgxID0gdjJbMF0sIHkxID0gdjJbMV0sXG5cdFx0XHR4MiA9IHYyWzZdLCB5MiA9IHYyWzddLFxuXHRcdFx0cm9vdHMgPSBnZXRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdDEgPSByb290c1tpXSxcblx0XHRcdFx0cDEgPSBDdXJ2ZS5nZXRQb2ludCh2MSwgdDEpLFxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFRpbWVPZih2MiwgcDEpO1xuXHRcdFx0aWYgKHQyICE9PSBudWxsKSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMiA6IGMxLCBmbGlwID8gdDIgOiB0MSxcblx0XHRcdFx0XHRcdGZsaXAgPyBjMSA6IGMyLCBmbGlwID8gdDEgOiB0Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHB0ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHB0KSB7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0YzEsIEN1cnZlLmdldFRpbWVPZih2MSwgcHQpLFxuXHRcdFx0XHRcdGMyLCBDdXJ2ZS5nZXRUaW1lT2YodjIsIHB0KSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0bWluID0gTWF0aC5taW4sXG5cdFx0XHRtYXggPSBNYXRoLm1heDtcblxuXHRcdGlmIChtYXgodjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtaW4odjFbMF0sIHYxWzJdLCB2MVs0XSwgdjFbNl0pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMF0sIHYyWzJdLCB2Mls0XSwgdjJbNl0pICYmXG5cdFx0XHRtYXgodjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pICsgZXBzaWxvbiA+XG5cdFx0XHRtaW4odjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pICYmXG5cdFx0XHRtaW4odjFbMV0sIHYxWzNdLCB2MVs1XSwgdjFbN10pIC0gZXBzaWxvbiA8XG5cdFx0XHRtYXgodjJbMV0sIHYyWzNdLCB2Mls1XSwgdjJbN10pKSB7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBnZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdGMxLCBvdmVybGFwWzBdLFxuXHRcdFx0XHRcdFx0XHRjMiwgb3ZlcmxhcFsxXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdFx0XHRzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcblx0XHRcdFx0XHRzdHJhaWdodCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG5cdFx0XHRcdFx0ZmxpcCA9IHN0cmFpZ2h0MSAmJiAhc3RyYWlnaHQyLFxuXHRcdFx0XHRcdGJlZm9yZSA9IGxvY2F0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdChzdHJhaWdodFxuXHRcdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHRcdDogc3RyYWlnaHQxIHx8IHN0cmFpZ2h0MlxuXHRcdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHRcdGZsaXAgPyB2MiA6IHYxLCBmbGlwID8gdjEgOiB2Mixcblx0XHRcdFx0XHRcdFx0ZmxpcCA/IGMyIDogYzEsIGZsaXAgPyBjMSA6IGMyLFxuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbnMsIGluY2x1ZGUsIGZsaXAsXG5cdFx0XHRcdFx0XHRcdDAsIDAsIDAsIDEsIDAsIDEpO1xuXHRcdFx0XHRpZiAoIXN0cmFpZ2h0IHx8IGxvY2F0aW9ucy5sZW5ndGggPT09IGJlZm9yZSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgdDEgPSBpID4+IDEsXG5cdFx0XHRcdFx0XHRcdHQyID0gaSAmIDEsXG5cdFx0XHRcdFx0XHRcdGkxID0gdDEgKiA2LFxuXHRcdFx0XHRcdFx0XHRpMiA9IHQyICogNixcblx0XHRcdFx0XHRcdFx0cDEgPSBuZXcgUG9pbnQodjFbaTFdLCB2MVtpMSArIDFdKSxcblx0XHRcdFx0XHRcdFx0cDIgPSBuZXcgUG9pbnQodjJbaTJdLCB2MltpMiArIDFdKTtcblx0XHRcdFx0XHRcdGlmIChwMS5pc0Nsb3NlKHAyLCBlcHNpbG9uKSkge1xuXHRcdFx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMSwgdDEsXG5cdFx0XHRcdFx0XHRcdFx0XHRjMiwgdDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0TG9vcEludGVyc2VjdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBpbmZvID0gQ3VydmUuY2xhc3NpZnkodjEpO1xuXHRcdGlmIChpbmZvLnR5cGUgPT09ICdsb29wJykge1xuXHRcdFx0dmFyIHJvb3RzID0gaW5mby5yb290cztcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjMSwgcm9vdHNbMF0sXG5cdFx0XHRcdFx0YzEsIHJvb3RzWzFdKTtcblx0XHR9XG5cdCAgcmV0dXJuIGxvY2F0aW9ucztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMoY3VydmVzMSwgY3VydmVzMiwgaW5jbHVkZSwgbWF0cml4MSwgbWF0cml4Mixcblx0XHRcdF9yZXR1cm5GaXJzdCkge1xuXHRcdHZhciBzZWxmID0gIWN1cnZlczI7XG5cdFx0aWYgKHNlbGYpXG5cdFx0XHRjdXJ2ZXMyID0gY3VydmVzMTtcblx0XHR2YXIgbGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoMiA9IGN1cnZlczIubGVuZ3RoLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0YXJyYXlzID0gW10sXG5cdFx0XHRsb2NhdGlvbnMsXG5cdFx0XHRjdXJyZW50O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKVxuXHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcblx0XHRcdFx0dmFsdWVzMSA9IHNlbGYgPyB2YWx1ZXMyW2ldIDogY3VydmUxLmdldFZhbHVlcyhtYXRyaXgxKSxcblx0XHRcdFx0cGF0aDEgPSBjdXJ2ZTEuZ2V0UGF0aCgpO1xuXHRcdFx0aWYgKHBhdGgxICE9PSBjdXJyZW50KSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBwYXRoMTtcblx0XHRcdFx0bG9jYXRpb25zID0gW107XG5cdFx0XHRcdGFycmF5cy5wdXNoKGxvY2F0aW9ucyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZikge1xuXHRcdFx0XHRnZXRMb29wSW50ZXJzZWN0aW9uKHZhbHVlczEsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGogPSBzZWxmID8gaSArIDEgOiAwOyBqIDwgbGVuZ3RoMjsgaisrKSB7XG5cdFx0XHRcdGlmIChfcmV0dXJuRmlyc3QgJiYgbG9jYXRpb25zLmxlbmd0aClcblx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0XHRnZXRDdXJ2ZUludGVyc2VjdGlvbnModmFsdWVzMSwgdmFsdWVzMltqXSwgY3VydmUxLCBjdXJ2ZXMyW2pdLFxuXHRcdFx0XHRcdFx0bG9jYXRpb25zLCBpbmNsdWRlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9jYXRpb25zID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRCYXNlLnB1c2gobG9jYXRpb25zLCBhcnJheXNbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0T3ZlcmxhcHModjEsIHYyKSB7XG5cblx0XHRmdW5jdGlvbiBnZXRTcXVhcmVkTGluZUxlbmd0aCh2KSB7XG5cdFx0XHR2YXIgeCA9IHZbNl0gLSB2WzBdLFxuXHRcdFx0XHR5ID0gdls3XSAtIHZbMV07XG5cdFx0XHRyZXR1cm4geCAqIHggKyB5ICogeTtcblx0XHR9XG5cblx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRnZXREaXN0YW5jZSA9IExpbmUuZ2V0RGlzdGFuY2UsXG5cdFx0XHR0aW1lRXBzaWxvbiA9IDFlLTgsXG5cdFx0XHRnZW9tRXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuXHRcdFx0c3RyYWlnaHRCb3RoID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0Mixcblx0XHRcdGZsaXAgPSBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MSkgPCBnZXRTcXVhcmVkTGluZUxlbmd0aCh2MiksXG5cdFx0XHRsMSA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0bDIgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdHB4ID0gbDFbMF0sIHB5ID0gbDFbMV0sXG5cdFx0XHR2eCA9IGwxWzZdIC0gcHgsIHZ5ID0gbDFbN10gLSBweTtcblx0XHRpZiAoZ2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzBdLCBsMlsxXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzZdLCBsMls3XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuXHRcdFx0aWYgKCFzdHJhaWdodEJvdGggJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwxWzJdLCBsMVszXSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbiAmJlxuXHRcdFx0XHRnZXREaXN0YW5jZShweCwgcHksIHZ4LCB2eSwgbDFbNF0sIGwxWzVdLCB0cnVlKSA8IGdlb21FcHNpbG9uICYmXG5cdFx0XHRcdGdldERpc3RhbmNlKHB4LCBweSwgdngsIHZ5LCBsMlsyXSwgbDJbM10sIHRydWUpIDwgZ2VvbUVwc2lsb24gJiZcblx0XHRcdFx0Z2V0RGlzdGFuY2UocHgsIHB5LCB2eCwgdnksIGwyWzRdLCBsMls1XSwgdHJ1ZSkgPCBnZW9tRXBzaWxvbikge1xuXHRcdFx0XHRzdHJhaWdodDEgPSBzdHJhaWdodDIgPSBzdHJhaWdodEJvdGggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc3RyYWlnaHRCb3RoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHN0cmFpZ2h0MSBeIHN0cmFpZ2h0Mikge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHYgPSBbdjEsIHYyXSxcblx0XHRcdHBhaXJzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHBhaXJzLmxlbmd0aCA8IDI7IGkrKykge1xuXHRcdFx0dmFyIGkxID0gaSAmIDEsXG5cdFx0XHRcdGkyID0gaTEgXiAxLFxuXHRcdFx0XHR0MSA9IGkgPj4gMSxcblx0XHRcdFx0dDIgPSBDdXJ2ZS5nZXRUaW1lT2YodltpMV0sIG5ldyBQb2ludChcblx0XHRcdFx0XHR2W2kyXVt0MSA/IDYgOiAwXSxcblx0XHRcdFx0XHR2W2kyXVt0MSA/IDcgOiAxXSkpO1xuXHRcdFx0aWYgKHQyICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIHBhaXIgPSBpMSA/IFt0MSwgdDJdIDogW3QyLCB0MV07XG5cdFx0XHRcdGlmICghcGFpcnMubGVuZ3RoIHx8XG5cdFx0XHRcdFx0YWJzKHBhaXJbMF0gLSBwYWlyc1swXVswXSkgPiB0aW1lRXBzaWxvbiAmJlxuXHRcdFx0XHRcdGFicyhwYWlyWzFdIC0gcGFpcnNbMF1bMV0pID4gdGltZUVwc2lsb24pIHtcblx0XHRcdFx0XHRwYWlycy5wdXNoKHBhaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaSA+IDIgJiYgIXBhaXJzLmxlbmd0aClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChwYWlycy5sZW5ndGggIT09IDIpIHtcblx0XHRcdHBhaXJzID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKCFzdHJhaWdodEJvdGgpIHtcblx0XHRcdHZhciBvMSA9IEN1cnZlLmdldFBhcnQodjEsIHBhaXJzWzBdWzBdLCBwYWlyc1sxXVswXSksXG5cdFx0XHRcdG8yID0gQ3VydmUuZ2V0UGFydCh2MiwgcGFpcnNbMF1bMV0sIHBhaXJzWzFdWzFdKTtcblx0XHRcdGlmIChhYnMobzJbMl0gLSBvMVsyXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbM10gLSBvMVszXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbNF0gLSBvMVs0XSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRhYnMobzJbNV0gLSBvMVs1XSkgPiBnZW9tRXBzaWxvbilcblx0XHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFpcnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUaW1lc1dpdGhUYW5nZW50KHYsIHRhbmdlbnQpIHtcblx0XHR2YXIgeDAgPSB2WzBdLCB5MCA9IHZbMV0sXG5cdFx0XHR4MSA9IHZbMl0sIHkxID0gdlszXSxcblx0XHRcdHgyID0gdls0XSwgeTIgPSB2WzVdLFxuXHRcdFx0eDMgPSB2WzZdLCB5MyA9IHZbN10sXG5cdFx0XHRub3JtYWxpemVkID0gdGFuZ2VudC5ub3JtYWxpemUoKSxcblx0XHRcdHR4ID0gbm9ybWFsaXplZC54LFxuXHRcdFx0dHkgPSBub3JtYWxpemVkLnksXG5cdFx0XHRheCA9IDMgKiB4MyAtIDkgKiB4MiArIDkgKiB4MSAtIDMgKiB4MCxcblx0XHRcdGF5ID0gMyAqIHkzIC0gOSAqIHkyICsgOSAqIHkxIC0gMyAqIHkwLFxuXHRcdFx0YnggPSA2ICogeDIgLSAxMiAqIHgxICsgNiAqIHgwLFxuXHRcdFx0YnkgPSA2ICogeTIgLSAxMiAqIHkxICsgNiAqIHkwLFxuXHRcdFx0Y3ggPSAzICogeDEgLSAzICogeDAsXG5cdFx0XHRjeSA9IDMgKiB5MSAtIDMgKiB5MCxcblx0XHRcdGRlbiA9IDIgKiBheCAqIHR5IC0gMiAqIGF5ICogdHgsXG5cdFx0XHR0aW1lcyA9IFtdO1xuXHRcdGlmIChNYXRoLmFicyhkZW4pIDwgTnVtZXJpY2FsLkNVUlZFVElNRV9FUFNJTE9OKSB7XG5cdFx0XHR2YXIgbnVtID0gYXggKiBjeSAtIGF5ICogY3gsXG5cdFx0XHRcdGRlbiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXHRcdFx0aWYgKGRlbiAhPSAwKSB7XG5cdFx0XHRcdHZhciB0ID0gLW51bSAvIGRlbjtcblx0XHRcdFx0aWYgKHQgPj0gMCAmJiB0IDw9IDEpIHRpbWVzLnB1c2godCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkZWx0YSA9IChieCAqIGJ4IC0gNCAqIGF4ICogY3gpICogdHkgKiB0eSArXG5cdFx0XHRcdCgtMiAqIGJ4ICogYnkgKyA0ICogYXkgKiBjeCArIDQgKiBheCAqIGN5KSAqIHR4ICogdHkgK1xuXHRcdFx0XHQoYnkgKiBieSAtIDQgKiBheSAqIGN5KSAqIHR4ICogdHgsXG5cdFx0XHRcdGsgPSBieCAqIHR5IC0gYnkgKiB0eDtcblx0XHRcdGlmIChkZWx0YSA+PSAwICYmIGRlbiAhPSAwKSB7XG5cdFx0XHRcdHZhciBkID0gTWF0aC5zcXJ0KGRlbHRhKSxcblx0XHRcdFx0XHR0MCA9IC0oayArIGQpIC8gZGVuLFxuXHRcdFx0XHRcdHQxID0gKC1rICsgZCkgLyBkZW47XG5cdFx0XHRcdGlmICh0MCA+PSAwICYmIHQwIDw9IDEpIHRpbWVzLnB1c2godDApO1xuXHRcdFx0XHRpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB0aW1lcy5wdXNoKHQxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRpbWVzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdFx0dmFyIHYxID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0djIgPSBjdXJ2ZSAmJiBjdXJ2ZSAhPT0gdGhpcyAmJiBjdXJ2ZS5nZXRWYWx1ZXMoKTtcblx0XHRcdHJldHVybiB2MiA/IGdldEN1cnZlSW50ZXJzZWN0aW9ucyh2MSwgdjIsIHRoaXMsIGN1cnZlLCBbXSlcblx0XHRcdFx0XHQgIDogZ2V0TG9vcEludGVyc2VjdGlvbih2MSwgdGhpcywgW10pO1xuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRnZXRPdmVybGFwczogZ2V0T3ZlcmxhcHMsXG5cdFx0XHRnZXRJbnRlcnNlY3Rpb25zOiBnZXRJbnRlcnNlY3Rpb25zLFxuXHRcdFx0Z2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9uczogZ2V0Q3VydmVMaW5lSW50ZXJzZWN0aW9ucyxcblx0XHRcdGdldFRpbWVzV2l0aFRhbmdlbnQ6IGdldFRpbWVzV2l0aFRhbmdlbnRcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHRpbWUsIHBvaW50LCBfb3ZlcmxhcCwgX2Rpc3RhbmNlKSB7XG5cdFx0aWYgKHRpbWUgPj0gMC45OTk5OTk5OSkge1xuXHRcdFx0dmFyIG5leHQgPSBjdXJ2ZS5nZXROZXh0KCk7XG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHR0aW1lID0gMDtcblx0XHRcdFx0Y3VydmUgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0dGhpcy5fdGltZSA9IHRpbWU7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludCB8fCBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0aW1lKTtcblx0XHR0aGlzLl9vdmVybGFwID0gX292ZXJsYXA7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcblx0fSxcblxuXHRfc2V0Q3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHR0aGlzLl9wYXRoID0gcGF0aDtcblx0XHR0aGlzLl92ZXJzaW9uID0gcGF0aCA/IHBhdGguX3ZlcnNpb24gOiAwO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudCA9IG51bGw7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdH0sXG5cblx0X3NldFNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHR0aGlzLl9zZXRDdXJ2ZShzZWdtZW50LmdldEN1cnZlKCkpO1xuXHRcdHRoaXMuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdHRoaXMuX3RpbWUgPSBzZWdtZW50ID09PSB0aGlzLl9zZWdtZW50MSA/IDAgOiAxO1xuXHRcdHRoaXMuX3BvaW50ID0gc2VnbWVudC5fcG9pbnQuY2xvbmUoKTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnQ7XG5cdFx0aWYgKCFzZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdGlmICh0aW1lID09PSAwKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRpbWUgPT09IDEpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAodGltZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHRpbWUpXG5cdFx0XHRcdFx0PCBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKHRpbWUsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmIChwYXRoICYmIHBhdGguX3ZlcnNpb24gIT09IHRoaXMuX3ZlcnNpb24pIHtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aGlzLl9vZmZzZXQgPSB0aGlzLl9jdXJ2ZU9mZnNldCA9IHRoaXMuX2N1cnZlID0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cnlTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQgJiYgc2VnbWVudC5nZXRDdXJ2ZSgpO1xuXHRcdFx0aWYgKGN1cnZlICYmICh0aGF0Ll90aW1lID0gY3VydmUuZ2V0VGltZU9mKHRoYXQuX3BvaW50KSkgIT0gbnVsbCkge1xuXHRcdFx0XHR0aGF0Ll9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fY3VydmVcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudClcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDEpXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkpO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcblx0fSxcblxuXHRnZXRUaW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHR0aW1lID0gdGhpcy5fdGltZTtcblx0XHRyZXR1cm4gY3VydmUgJiYgdGltZSA9PSBudWxsXG5cdFx0XHQ/IHRoaXMuX3RpbWUgPSBjdXJ2ZS5nZXRUaW1lT2YodGhpcy5fcG9pbnQpXG5cdFx0XHQ6IHRpbWU7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiAnI2dldFRpbWUnLFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXHRcdGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCksXG5cdFx0XHRcdGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdFx0aWYgKHBhdGggJiYgaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY3VydmVzID0gcGF0aC5nZXRDdXJ2ZXMoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuXHRcdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKz0gdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fY3VydmVPZmZzZXQ7XG5cdFx0aWYgKG9mZnNldCA9PSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRcdHRoaXMuX2N1cnZlT2Zmc2V0ID0gb2Zmc2V0ID0gdGltZSAhPSBudWxsICYmIGN1cnZlXG5cdFx0XHRcdFx0JiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0aW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kaXN0YW5jZTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHJlcyA9IGN1cnZlICYmIGN1cnZlLmRpdmlkZUF0VGltZSh0aGlzLmdldFRpbWUoKSk7XG5cdFx0aWYgKHJlcykge1xuXHRcdFx0dGhpcy5fc2V0U2VnbWVudChyZXMuX3NlZ21lbnQxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGF0aCA9IGN1cnZlLl9wYXRoLFxuXHRcdFx0cmVzID0gY3VydmUgJiYgY3VydmUuc3BsaXRBdFRpbWUodGhpcy5nZXRUaW1lKCkpO1xuXHRcdGlmIChyZXMpIHtcblx0XHRcdHRoaXMuX3NldFNlZ21lbnQocGF0aC5nZXRMYXN0U2VnbWVudCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuICByZXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MsIF9pZ25vcmVPdGhlcikge1xuXHRcdHZhciByZXMgPSB0aGlzID09PSBsb2M7XG5cdFx0aWYgKCFyZXMgJiYgbG9jIGluc3RhbmNlb2YgQ3VydmVMb2NhdGlvbikge1xuXHRcdFx0dmFyIGMxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRjMiA9IGxvYy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRwMSA9IGMxLl9wYXRoLFxuXHRcdFx0XHRwMiA9IGMyLl9wYXRoO1xuXHRcdFx0aWYgKHAxID09PSBwMikge1xuXHRcdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTcsXG5cdFx0XHRcdFx0ZGlmZiA9IGFicyh0aGlzLmdldE9mZnNldCgpIC0gbG9jLmdldE9mZnNldCgpKSxcblx0XHRcdFx0XHRpMSA9ICFfaWdub3JlT3RoZXIgJiYgdGhpcy5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdGkyID0gIV9pZ25vcmVPdGhlciAmJiBsb2MuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0cmVzID0gKGRpZmYgPCBlcHNpbG9uXG5cdFx0XHRcdFx0XHR8fCBwMSAmJiBhYnMocDEuZ2V0TGVuZ3RoKCkgLSBkaWZmKSA8IGVwc2lsb24pXG5cdFx0XHRcdFx0JiYgKCFpMSAmJiAhaTIgfHwgaTEgJiYgaTIgJiYgaTEuZXF1YWxzKGkyLCB0cnVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciB0aW1lID0gdGhpcy5nZXRUaW1lKCk7XG5cdFx0aWYgKHRpbWUgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3RpbWU6ICcgKyBmLm51bWJlcih0aW1lKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRpc1RvdWNoaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKGludGVyICYmIHRoaXMuZ2V0VGFuZ2VudCgpLmlzQ29sbGluZWFyKGludGVyLmdldFRhbmdlbnQoKSkpIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGN1cnZlMiA9IGludGVyLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gIShjdXJ2ZTEuaXNTdHJhaWdodCgpICYmIGN1cnZlMi5pc1N0cmFpZ2h0KClcblx0XHRcdFx0XHQmJiBjdXJ2ZTEuZ2V0TGluZSgpLmludGVyc2VjdChjdXJ2ZTIuZ2V0TGluZSgpKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0Nyb3NzaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgdDEgPSB0aGlzLmdldFRpbWUoKSxcblx0XHRcdHQyID0gaW50ZXIuZ2V0VGltZSgpLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHR0MUluc2lkZSA9IHQxID49IHRNaW4gJiYgdDEgPD0gdE1heCxcblx0XHRcdHQySW5zaWRlID0gdDIgPj0gdE1pbiAmJiB0MiA8PSB0TWF4O1xuXHRcdGlmICh0MUluc2lkZSAmJiB0Mkluc2lkZSlcblx0XHRcdHJldHVybiAhdGhpcy5pc1RvdWNoaW5nKCk7XG5cdFx0dmFyIGMyID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0YzEgPSB0MSA8IHRNaW4gPyBjMi5nZXRQcmV2aW91cygpIDogYzIsXG5cdFx0XHRjNCA9IGludGVyLmdldEN1cnZlKCksXG5cdFx0XHRjMyA9IHQyIDwgdE1pbiA/IGM0LmdldFByZXZpb3VzKCkgOiBjNDtcblx0XHRpZiAodDEgPiB0TWF4KVxuXHRcdFx0YzIgPSBjMi5nZXROZXh0KCk7XG5cdFx0aWYgKHQyID4gdE1heClcblx0XHRcdGM0ID0gYzQuZ2V0TmV4dCgpO1xuXHRcdGlmICghYzEgfHwgIWMyIHx8ICFjMyB8fCAhYzQpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR2YXIgb2Zmc2V0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkT2Zmc2V0cyhjdXJ2ZSwgZW5kKSB7XG5cdFx0XHR2YXIgdiA9IGN1cnZlLmdldFZhbHVlcygpLFxuXHRcdFx0XHRyb290cyA9IEN1cnZlLmNsYXNzaWZ5KHYpLnJvb3RzIHx8IEN1cnZlLmdldFBlYWtzKHYpLFxuXHRcdFx0XHRjb3VudCA9IHJvb3RzLmxlbmd0aCxcblx0XHRcdFx0dCA9IGVuZCAmJiBjb3VudCA+IDEgPyByb290c1tjb3VudCAtIDFdXG5cdFx0XHRcdFx0XHQ6IGNvdW50ID4gMCA/IHJvb3RzWzBdXG5cdFx0XHRcdFx0XHQ6IDAuNTtcblx0XHRcdG9mZnNldHMucHVzaChDdXJ2ZS5nZXRMZW5ndGgodiwgZW5kID8gdCA6IDAsIGVuZCA/IDEgOiB0KSAvIDIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzSW5SYW5nZShhbmdsZSwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBtaW4gPCBtYXhcblx0XHRcdFx0XHQ/IGFuZ2xlID4gbWluICYmIGFuZ2xlIDwgbWF4XG5cdFx0XHRcdFx0OiBhbmdsZSA+IG1pbiB8fCBhbmdsZSA8IG1heDtcblx0XHR9XG5cblx0XHRpZiAoIXQxSW5zaWRlKSB7XG5cdFx0XHRhZGRPZmZzZXRzKGMxLCB0cnVlKTtcblx0XHRcdGFkZE9mZnNldHMoYzIsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKCF0Mkluc2lkZSkge1xuXHRcdFx0YWRkT2Zmc2V0cyhjMywgdHJ1ZSk7XG5cdFx0XHRhZGRPZmZzZXRzKGM0LCBmYWxzZSk7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdG9mZnNldCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIG9mZnNldHMpLFxuXHRcdFx0djIgPSB0MUluc2lkZSA/IGMyLmdldFRhbmdlbnRBdFRpbWUodDEpXG5cdFx0XHRcdFx0OiBjMi5nZXRQb2ludEF0KG9mZnNldCkuc3VidHJhY3QocHQpLFxuXHRcdFx0djEgPSB0MUluc2lkZSA/IHYyLm5lZ2F0ZSgpXG5cdFx0XHRcdFx0OiBjMS5nZXRQb2ludEF0KC1vZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdHY0ID0gdDJJbnNpZGUgPyBjNC5nZXRUYW5nZW50QXRUaW1lKHQyKVxuXHRcdFx0XHRcdDogYzQuZ2V0UG9pbnRBdChvZmZzZXQpLnN1YnRyYWN0KHB0KSxcblx0XHRcdHYzID0gdDJJbnNpZGUgPyB2NC5uZWdhdGUoKVxuXHRcdFx0XHRcdDogYzMuZ2V0UG9pbnRBdCgtb2Zmc2V0KS5zdWJ0cmFjdChwdCksXG5cdFx0XHRhMSA9IHYxLmdldEFuZ2xlKCksXG5cdFx0XHRhMiA9IHYyLmdldEFuZ2xlKCksXG5cdFx0XHRhMyA9IHYzLmdldEFuZ2xlKCksXG5cdFx0XHRhNCA9IHY0LmdldEFuZ2xlKCk7XG5cdFx0cmV0dXJuICEhKHQxSW5zaWRlXG5cdFx0XHRcdD8gKGlzSW5SYW5nZShhMSwgYTMsIGE0KSBeIGlzSW5SYW5nZShhMiwgYTMsIGE0KSkgJiZcblx0XHRcdFx0ICAoaXNJblJhbmdlKGExLCBhNCwgYTMpIF4gaXNJblJhbmdlKGEyLCBhNCwgYTMpKVxuXHRcdFx0XHQ6IChpc0luUmFuZ2UoYTMsIGExLCBhMikgXiBpc0luUmFuZ2UoYTQsIGExLCBhMikpICYmXG5cdFx0XHRcdCAgKGlzSW5SYW5nZShhMywgYTIsIGExKSBeIGlzSW5SYW5nZShhNCwgYTIsIGExKSkpO1xuXHR9LFxuXG5cdGhhc092ZXJsYXA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX292ZXJsYXA7XG5cdH1cbn0sIEJhc2UuZWFjaChDdXJ2ZS5fZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHRpbWUgPSB0aGlzLmdldFRpbWUoKTtcblx0XHRyZXR1cm4gdGltZSAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0odGltZSwgdHJ1ZSk7XG5cdH07XG59LCB7XG5cdHByZXNlcnZlOiB0cnVlXG59KSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBpbnNlcnQobG9jYXRpb25zLCBsb2MsIG1lcmdlKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGxvY2F0aW9ucy5sZW5ndGgsXG5cdFx0XHRsID0gMCxcblx0XHRcdHIgPSBsZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gc2VhcmNoKGluZGV4LCBkaXIpIHtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGRpcjsgaSA+PSAtMSAmJiBpIDw9IGxlbmd0aDsgaSArPSBkaXIpIHtcblx0XHRcdFx0dmFyIGxvYzIgPSBsb2NhdGlvbnNbKChpICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdO1xuXHRcdFx0XHRpZiAoIWxvYy5nZXRQb2ludCgpLmlzQ2xvc2UobG9jMi5nZXRQb2ludCgpLFxuXHRcdFx0XHRcdFx0MWUtNykpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGlmIChsb2MuZXF1YWxzKGxvYzIpKVxuXHRcdFx0XHRcdHJldHVybiBsb2MyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGwgPD0gcikge1xuXHRcdFx0dmFyIG0gPSAobCArIHIpID4+PiAxLFxuXHRcdFx0XHRsb2MyID0gbG9jYXRpb25zW21dLFxuXHRcdFx0XHRmb3VuZDtcblx0XHRcdGlmIChtZXJnZSAmJiAoZm91bmQgPSBsb2MuZXF1YWxzKGxvYzIpID8gbG9jMlxuXHRcdFx0XHRcdDogKHNlYXJjaChtLCAtMSkgfHwgc2VhcmNoKG0sIDEpKSkpIHtcblx0XHRcdFx0aWYgKGxvYy5fb3ZlcmxhcCkge1xuXHRcdFx0XHRcdGZvdW5kLl9vdmVybGFwID0gZm91bmQuX2ludGVyc2VjdGlvbi5fb3ZlcmxhcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fVxuXHRcdHZhciBwYXRoMSA9IGxvYy5nZXRQYXRoKCksXG5cdFx0XHRwYXRoMiA9IGxvYzIuZ2V0UGF0aCgpLFxuXHRcdFx0ZGlmZiA9IHBhdGgxICE9PSBwYXRoMlxuXHRcdFx0XHQ/IHBhdGgxLl9pZCAtIHBhdGgyLl9pZFxuXHRcdFx0XHQ6IChsb2MuZ2V0SW5kZXgoKSArIGxvYy5nZXRUaW1lKCkpXG5cdFx0XHRcdC0gKGxvYzIuZ2V0SW5kZXgoKSArIGxvYzIuZ2V0VGltZSgpKTtcblx0XHRcdGlmIChkaWZmIDwgMCkge1xuXHRcdFx0XHRyID0gbSAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsID0gbSArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvY2F0aW9ucy5zcGxpY2UobCwgMCwgbG9jKTtcblx0XHRyZXR1cm4gbG9jO1xuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXHRcdGluc2VydDogaW5zZXJ0LFxuXG5cdFx0ZXhwYW5kOiBmdW5jdGlvbihsb2NhdGlvbnMpIHtcblx0XHRcdHZhciBleHBhbmRlZCA9IGxvY2F0aW9ucy5zbGljZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpbnNlcnQoZXhwYW5kZWQsIGxvY2F0aW9uc1tpXS5faW50ZXJzZWN0aW9uLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgUGF0aEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVtJyxcblx0X3NlbGVjdEJvdW5kczogZmFsc2UsXG5cdF9jYW5TY2FsZVN0cm9rZTogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aEl0ZW0oKSB7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24oYXJnKSB7XG5cdFx0XHR2YXIgZGF0YSxcblx0XHRcdFx0c2VnbWVudHMsXG5cdFx0XHRcdGNvbXBvdW5kO1xuXHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKSB7XG5cdFx0XHRcdHNlZ21lbnRzID0gYXJnLnNlZ21lbnRzO1xuXHRcdFx0XHRkYXRhID0gYXJnLnBhdGhEYXRhO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBhcmc7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRhdGEgPSBhcmc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VnbWVudHMpIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0XHRcdGNvbXBvdW5kID0gZmlyc3QgJiYgQXJyYXkuaXNBcnJheShmaXJzdFswXSk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGEpIHtcblx0XHRcdFx0Y29tcG91bmQgPSAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDFcblx0XHRcdFx0XHRcdHx8IC96XFxzKlxcUysvaS50ZXN0KGRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN0b3IgPSBjb21wb3VuZCA/IENvbXBvdW5kUGF0aCA6IFBhdGg7XG5cdFx0XHRyZXR1cm4gbmV3IGN0b3IoYXJnKTtcblx0XHR9XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBcmVhKCkgPj0gMDtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNldFBhdGhEYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0XHR2YXIgcGFydHMgPSBkYXRhICYmIGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQpO1xuXHRcdFx0c3dpdGNoIChsb3dlcikge1xuXHRcdFx0Y2FzZSAnbSc6XG5cdFx0XHRjYXNlICdsJzpcblx0XHRcdFx0dmFyIG1vdmUgPSBsb3dlciA9PT0gJ20nO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpc1ttb3ZlID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRpZiAobW92ZSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgPSBjdXJyZW50O1xuXHRcdFx0XHRcdFx0bW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5jbG9uZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgoMWUtMTIpO1xuXHRcdFx0XHRjdXJyZW50ID0gc3RhcnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gcG9pbnQuaXNJbnNpZGUoXG5cdFx0XHRcdHRoaXMuZ2V0Qm91bmRzKHsgaW50ZXJuYWw6IHRydWUsIGhhbmRsZTogdHJ1ZSB9KSlcblx0XHRcdFx0XHQ/IHRoaXMuX2dldFdpbmRpbmcocG9pbnQpXG5cdFx0XHRcdFx0OiB7fTtcblx0XHRyZXR1cm4gd2luZGluZy5vblBhdGggfHwgISEodGhpcy5nZXRGaWxsUnVsZSgpID09PSAnZXZlbm9kZCdcblx0XHRcdFx0PyB3aW5kaW5nLndpbmRpbmdMICYgMSB8fCB3aW5kaW5nLndpbmRpbmdSICYgMVxuXHRcdFx0XHQ6IHdpbmRpbmcud2luZGluZyk7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocGF0aCwgaW5jbHVkZSwgX21hdHJpeCwgX3JldHVybkZpcnN0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzID09PSBwYXRoIHx8ICFwYXRoLFxuXHRcdFx0bWF0cml4MSA9IHRoaXMuX21hdHJpeC5fb3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHNlbGYgPyBtYXRyaXgxXG5cdFx0XHRcdDogKF9tYXRyaXggfHwgcGF0aC5fbWF0cml4KS5fb3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHJldHVybiBzZWxmIHx8IHRoaXMuZ2V0Qm91bmRzKG1hdHJpeDEpLmludGVyc2VjdHMoXG5cdFx0XHRcdHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpLCAxZS0xMilcblx0XHRcdFx0PyBDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0dGhpcy5nZXRDdXJ2ZXMoKSwgIXNlbGYgJiYgcGF0aC5nZXRDdXJ2ZXMoKSwgaW5jbHVkZSxcblx0XHRcdFx0XHRcdG1hdHJpeDEsIG1hdHJpeDIsIF9yZXR1cm5GaXJzdClcblx0XHRcdFx0OiBbXTtcblx0fSxcblxuXHRnZXRDcm9zc2luZ3M6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKHBhdGgsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXIuaGFzT3ZlcmxhcCgpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHR9KTtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5Mb2MgPSBudWxsO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdG1pbkRpc3QgPSBsb2MuX2Rpc3RhbmNlO1xuXHRcdFx0XHRtaW5Mb2MgPSBsb2M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Mb2M7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldFBvaW50KCkgOiBsb2M7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBmYWN0b3IpIHtcblx0XHR2YXIgaXNQYXRoID0gIXRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bmFtZSA9IGlzUGF0aCA/ICdfc2VnbWVudHMnIDogJ19jaGlsZHJlbicsXG5cdFx0XHRpdGVtc0Zyb20gPSBmcm9tW25hbWVdLFxuXHRcdFx0aXRlbXNUbyA9IHRvW25hbWVdLFxuXHRcdFx0aXRlbXMgPSB0aGlzW25hbWVdO1xuXHRcdGlmICghaXRlbXNGcm9tIHx8ICFpdGVtc1RvIHx8IGl0ZW1zRnJvbS5sZW5ndGggIT09IGl0ZW1zVG8ubGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3BlcmFuZHMgaW4gaW50ZXJwb2xhdGUoKSBjYWxsOiAnICtcblx0XHRcdFx0XHRmcm9tICsgJywgJyArIHRvKTtcblx0XHR9XG5cdFx0dmFyIGN1cnJlbnQgPSBpdGVtcy5sZW5ndGgsXG5cdFx0XHRsZW5ndGggPSBpdGVtc1RvLmxlbmd0aDtcblx0XHRpZiAoY3VycmVudCA8IGxlbmd0aCkge1xuXHRcdFx0dmFyIGN0b3IgPSBpc1BhdGggPyBTZWdtZW50IDogUGF0aDtcblx0XHRcdGZvciAodmFyIGkgPSBjdXJyZW50OyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGQobmV3IGN0b3IoKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjdXJyZW50ID4gbGVuZ3RoKSB7XG5cdFx0XHR0aGlzW2lzUGF0aCA/ICdyZW1vdmVTZWdtZW50cycgOiAncmVtb3ZlQ2hpbGRyZW4nXShsZW5ndGgsIGN1cnJlbnQpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpdGVtc1tpXS5pbnRlcnBvbGF0ZShpdGVtc0Zyb21baV0sIGl0ZW1zVG9baV0sIGZhY3Rvcik7XG5cdFx0fVxuXHRcdGlmIChpc1BhdGgpIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZyb20uX2Nsb3NlZCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRjb21wYXJlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dmFyIG9rID0gZmFsc2U7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBwYXRoczEgPSB0aGlzLl9jaGlsZHJlbiB8fCBbdGhpc10sXG5cdFx0XHRcdHBhdGhzMiA9IHBhdGguX2NoaWxkcmVuID8gcGF0aC5fY2hpbGRyZW4uc2xpY2UoKSA6IFtwYXRoXSxcblx0XHRcdFx0bGVuZ3RoMSA9IHBhdGhzMS5sZW5ndGgsXG5cdFx0XHRcdGxlbmd0aDIgPSBwYXRoczIubGVuZ3RoLFxuXHRcdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdG9rID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGkxID0gbGVuZ3RoMSAtIDE7IGkxID49IDAgJiYgb2s7IGkxLS0pIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gcGF0aHMxW2kxXTtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaTIgPSBsZW5ndGgyIC0gMTsgaTIgPj0gMCAmJiAhb2s7IGkyLS0pIHtcblx0XHRcdFx0XHRpZiAocGF0aDEuY29tcGFyZShwYXRoczJbaTJdKSkge1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaGVkW2kyXSkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkW2kyXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvayA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvayA9IG9rICYmIGNvdW50ID09PSBsZW5ndGgyO1xuXHRcdH1cblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dGhpcy5fdmVyc2lvbiA9IDA7XG5cdFx0dmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJndW1lbnRzXG5cdFx0XHQ6IGFyZyAmJiAoYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0PyBhcmd1bWVudHNcblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fc2VnbWVudFNlbGVjdGlvbiA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0U2VnbWVudHMoc291cmNlLl9zZWdtZW50cyk7XG5cdFx0dGhpcy5fY2xvc2VkID0gc291cmNlLl9jbG9zZWQ7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9hcmVhID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGZsYWdzICYgMzIpIHtcblx0XHRcdFx0dGhpcy5fdmVyc2lvbisrO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdCAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZsYWdzICYgNjQpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0cmV0dXJuIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGggPyBwYXJlbnQgOiB0aGlzKS5fc3R5bGU7XG5cdH0sXG5cblx0Z2V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cztcblx0fSxcblxuXHRzZXRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHR2YXIgZnVsbHlTZWxlY3RlZCA9IHRoaXMuaXNGdWxseVNlbGVjdGVkKCksXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VnbWVudHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxhc3QgPSBzZWdtZW50c1tsZW5ndGggLSAxXTtcblx0XHRcdGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGxhc3QpO1xuXHRcdFx0XHRsZW5ndGgtLTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzLCAwLCB7fSwgbGVuZ3RoKSk7XG5cdFx0fVxuXHRcdGlmIChmdWxseVNlbGVjdGVkKVxuXHRcdFx0dGhpcy5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzWzBdO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbdGhpcy5fc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRpZiAoIWN1cnZlcykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRcdGN1cnZlc1tpXSA9IG5ldyBDdXJ2ZSh0aGlzLCBzZWdtZW50c1tpXSxcblx0XHRcdFx0XHRzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEN1cnZlcygpWzBdO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0cmV0dXJuIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9zZWQ7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHRpZiAodGhpcy5fY2xvc2VkICE9IChjbG9zZWQgPSAhIWNsb3NlZCkpIHtcblx0XHRcdHRoaXMuX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuX2N1cnZlcy5sZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tsZW5ndGggLSAxXSA9IG5ldyBDdXJ2ZSh0aGlzLFxuXHRcdFx0XHRcdFx0dGhpcy5fc2VnbWVudHNbbGVuZ3RoIC0gMV0sIHRoaXMuX3NlZ21lbnRzWzBdKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoNDEpO1xuXHRcdH1cblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0ZiA9IG5ldyBGb3JtYXR0ZXIoX3ByZWNpc2lvbiksXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZLFxuXHRcdFx0cGFydHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFNlZ21lbnQoc2VnbWVudCwgc2tpcExpbmUpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKF9tYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSkge1xuXHRcdFx0XHRcdFx0dmFyIGR4ID0gY3VyWCAtIHByZXZYLFxuXHRcdFx0XHRcdFx0XHRkeSA9IGN1clkgLSBwcmV2WTtcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goXG5cdFx0XHRcdFx0XHRcdCAgZHggPT09IDAgPyAndicgKyBmLm51bWJlcihkeSlcblx0XHRcdFx0XHRcdFx0OiBkeSA9PT0gMCA/ICdoJyArIGYubnVtYmVyKGR4KVxuXHRcdFx0XHRcdFx0XHQ6ICdsJyArIGYucGFpcihkeCwgZHkpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCArICcgJyArIGYucGFpciggaW5YIC0gcHJldlgsICBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0ICsgJyAnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdH1cblxuXHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1swXSwgdHJ1ZSk7XG5cdFx0XHRwYXJ0cy5wdXNoKCd6Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcnKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0QmFzZS5wdXNoKHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciB0b3RhbCA9IHRoaXMuX2NvdW50Q3VydmVzKCksXG5cdFx0XHRcdHN0YXJ0ID0gaW5kZXggPiAwICYmIGluZGV4ICsgYW1vdW50IC0gMSA9PT0gdG90YWwgPyBpbmRleCAtIDFcblx0XHRcdFx0XHQ6IGluZGV4LFxuXHRcdFx0XHRpbnNlcnQgPSBzdGFydCxcblx0XHRcdFx0ZW5kID0gTWF0aC5taW4oc3RhcnQgKyBhbW91bnQsIHRvdGFsKTtcblx0XHRcdGlmIChzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0Y3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtzdGFydCwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRpbnNlcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnQ7IGkgPCBlbmQ7IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKHN0YXJ0LCBlbmQpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDQxKTtcblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjdXJ2ZTtcblx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgIXN0YXJ0ID8gc2VnbWVudHMubGVuZ3RoIC0gMVxuXHRcdFx0XHQ6IHN0YXJ0IC0gMV0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW3N0YXJ0XSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1tlbmRdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tlbmRdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbihpbmRleCwgc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3QoYXJndW1lbnRzLCAxKSwgaW5kZXgpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZExpc3Qoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRMaXN0KHNlZ21lbnRzKSwgaW5kZXgpO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50czogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdFx0ZW5kID0gQmFzZS5waWNrKGVuZCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBzdGFydCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gc3RhcnQgPiAwICYmIGVuZCA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBzdGFydCAtIDFcblx0XHRcdFx0XHQ6IHN0YXJ0LFxuXHRcdFx0XHRjdXJ2ZXMgPSBjdXJ2ZXMuc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdFx0Y3VydmVzW2ldLl9wYXRoID0gbnVsbDtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoNDEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHNlZ21lbnRzW2ldLmhhc0hhbmRsZXMoKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uY2xlYXJIYW5kbGVzKCk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmVhID0gdGhpcy5fYXJlYTtcblx0XHRpZiAoYXJlYSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXHRcdFx0YXJlYSA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgbGFzdCA9IGkgKyAxID09PSBsO1xuXHRcdFx0XHRhcmVhICs9IEN1cnZlLmdldEFyZWEoQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdFx0c2VnbWVudHNbaV0sIHNlZ21lbnRzW2xhc3QgPyAwIDogaSArIDFdLFxuXHRcdFx0XHRcdFx0bnVsbCwgbGFzdCAmJiAhY2xvc2VkKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hcmVhID0gYXJlYTtcblx0XHR9XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKSAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlZ21lbnRTZWxlY3Rpb25cblx0XHRcdFx0PT09IGxlbmd0aCAqIDc7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRzZXRTZWxlY3Rpb246IGZ1bmN0aW9uIHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcblx0XHRpZiAoIShzZWxlY3Rpb24gJiAxKSlcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3Rpb24uYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGlvbik7XG5cdH0sXG5cblx0X3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0bGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0c2VsZWN0aW9uID0gc2VsZWN0ZWQgPyA3IDogMDtcblx0XHR0aGlzLl9zZWdtZW50U2VsZWN0aW9uID0gc2VsZWN0aW9uICogbGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFNlbGVjdGlvbiwgbmV3U2VsZWN0aW9uKSB7XG5cdFx0c2VnbWVudC5fc2VsZWN0aW9uID0gbmV3U2VsZWN0aW9uO1xuXHRcdHZhciBzZWxlY3Rpb24gPSB0aGlzLl9zZWdtZW50U2VsZWN0aW9uICs9IG5ld1NlbGVjdGlvbiAtIG9sZFNlbGVjdGlvbjtcblx0XHRpZiAoc2VsZWN0aW9uID4gMClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGl2aWRlQXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG5cdFx0XHRjdXJ2ZTtcblx0XHRyZXR1cm4gbG9jICYmIChjdXJ2ZSA9IGxvYy5nZXRDdXJ2ZSgpLmRpdmlkZUF0KGxvYy5nZXRDdXJ2ZU9mZnNldCgpKSlcblx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdHNwbGl0QXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChsb2NhdGlvbiksXG5cdFx0XHRpbmRleCA9IGxvYyAmJiBsb2MuaW5kZXgsXG5cdFx0XHR0aW1lID0gbG9jICYmIGxvYy50aW1lLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0aWYgKHRpbWUgPiB0TWF4KSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0dGltZSA9IDA7XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRpbWUgPj0gdE1pbikge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlQXRUaW1lKHRpbWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuXHRcdFx0XHRwYXRoO1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb3NlZChmYWxzZSk7XG5cdFx0XHRcdHBhdGggPSB0aGlzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdFx0cGF0aC5jb3B5QXR0cmlidXRlcyh0aGlzKTtcblx0XHRcdH1cblx0XHRcdHBhdGguX2FkZChzZWdzLCAwKTtcblx0XHRcdHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHRpbWUpIHtcblx0XHR2YXIgY3VydmUsXG5cdFx0XHRsb2NhdGlvbiA9IHRpbWUgPT09IHVuZGVmaW5lZCA/IGluZGV4XG5cdFx0XHRcdDogKGN1cnZlID0gdGhpcy5nZXRDdXJ2ZXMoKVtpbmRleF0pXG5cdFx0XHRcdFx0JiYgY3VydmUuZ2V0TG9jYXRpb25BdFRpbWUodGltZSk7XG5cdFx0cmV0dXJuIGxvY2F0aW9uICE9IG51bGwgPyB0aGlzLnNwbGl0QXQobG9jYXRpb24pIDogbnVsbDtcblx0fSxcblxuXHRqb2luOiBmdW5jdGlvbihwYXRoLCB0b2xlcmFuY2UpIHtcblx0XHR2YXIgZXBzaWxvbiA9IHRvbGVyYW5jZSB8fCAwO1xuXHRcdGlmIChwYXRoICYmIHBhdGggIT09IHRoaXMpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0XHRsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAoIWxhc3QyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5pc0Nsb3NlKGZpcnN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG5cdFx0XHRcdGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG5cdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmlzQ2xvc2UoZmlyc3QyLl9wb2ludCwgZXBzaWxvbikpXG5cdFx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuaXNDbG9zZShsYXN0Mi5fcG9pbnQsIGVwc2lsb24pKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRcdHRoaXMuX2FkZChbc2VnbWVudHNbMF1dKTtcblx0XHRcdHBhdGgucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRsYXN0ID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdGlmIChmaXJzdCAhPT0gbGFzdCAmJiBmaXJzdC5fcG9pbnQuaXNDbG9zZShsYXN0Ll9wb2ludCwgZXBzaWxvbikpIHtcblx0XHRcdGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcblx0XHRcdGxhc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRzaW1wbGlmeSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaW1wbGlmeSxcblx0XHRcdHRvbGVyYW5jZSA9IHNpbXBsaWZ5ID8gMWUtNyA6IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0aWYgKCFjdXJ2ZS5oYXNIYW5kbGVzKCkgJiYgKCFjdXJ2ZS5oYXNMZW5ndGgodG9sZXJhbmNlKVxuXHRcdFx0XHRcdHx8IHNpbXBsaWZ5ICYmIGN1cnZlLmlzQ29sbGluZWFyKGN1cnZlLmdldE5leHQoKSkpKVxuXHRcdFx0XHRjdXJ2ZS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24oZmxhdG5lc3MpIHtcblx0XHR2YXIgZmxhdHRlbmVyID0gbmV3IFBhdGhGbGF0dGVuZXIodGhpcywgZmxhdG5lc3MgfHwgMC4yNSwgMjU2LCB0cnVlKSxcblx0XHRcdHBhcnRzID0gZmxhdHRlbmVyLnBhcnRzLFxuXHRcdFx0bGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuXHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHBhcnRzW2ldLmN1cnZlLnNsaWNlKDAsIDIpKSk7XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocGFydHNbbGVuZ3RoIC0gMV0uY3VydmUuc2xpY2UoNikpKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0c2ltcGxpZnk6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdHZhciBzZWdtZW50cyA9IG5ldyBQYXRoRml0dGVyKHRoaXMpLmZpdCh0b2xlcmFuY2UgfHwgMi41KTtcblx0XHRpZiAoc2VnbWVudHMpXG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHRyZXR1cm4gISFzZWdtZW50cztcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRvcHRzID0gb3B0aW9ucyB8fCB7fSxcblx0XHRcdHR5cGUgPSBvcHRzLnR5cGUgfHwgJ2FzeW1tZXRyaWMnLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblxuXHRcdGZ1bmN0aW9uIGdldEluZGV4KHZhbHVlLCBfZGVmYXVsdCkge1xuXHRcdFx0dmFyIGluZGV4ID0gdmFsdWUgJiYgdmFsdWUuaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcGF0aCA9IHZhbHVlLnBhdGg7XG5cdFx0XHRcdGlmIChwYXRoICYmIHBhdGggIT09IHRoYXQpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHZhbHVlLl9jbGFzcyArICcgJyArIGluZGV4ICsgJyBvZiAnICsgcGF0aFxuXHRcdFx0XHRcdFx0XHQrICcgaXMgbm90IHBhcnQgb2YgJyArIHRoYXQpO1xuXHRcdFx0XHRpZiAoX2RlZmF1bHQgJiYgdmFsdWUgaW5zdGFuY2VvZiBDdXJ2ZSlcblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5kZXggPSB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBfZGVmYXVsdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBNYXRoLm1pbihpbmRleCA8IDAgJiYgY2xvc2VkXG5cdFx0XHRcdFx0PyBpbmRleCAlIGxlbmd0aFxuXHRcdFx0XHRcdDogaW5kZXggPCAwID8gaW5kZXggKyBsZW5ndGggOiBpbmRleCwgbGVuZ3RoIC0gMSk7XG5cdFx0fVxuXG5cdFx0dmFyIGxvb3AgPSBjbG9zZWQgJiYgb3B0cy5mcm9tID09PSB1bmRlZmluZWQgJiYgb3B0cy50byA9PT0gdW5kZWZpbmVkLFxuXHRcdFx0ZnJvbSA9IGdldEluZGV4KG9wdHMuZnJvbSwgMCksXG5cdFx0XHR0byA9IGdldEluZGV4KG9wdHMudG8sIGxlbmd0aCAtIDEpO1xuXG5cdFx0aWYgKGZyb20gPiB0bykge1xuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmcm9tIC09IGxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB0bXAgPSBmcm9tO1xuXHRcdFx0XHRmcm9tID0gdG87XG5cdFx0XHRcdHRvID0gdG1wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoL14oPzphc3ltbWV0cmljfGNvbnRpbnVvdXMpJC8udGVzdCh0eXBlKSkge1xuXHRcdFx0dmFyIGFzeW1tZXRyaWMgPSB0eXBlID09PSAnYXN5bW1ldHJpYycsXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluLFxuXHRcdFx0XHRhbW91bnQgPSB0byAtIGZyb20gKyAxLFxuXHRcdFx0XHRuID0gYW1vdW50IC0gMSxcblx0XHRcdFx0cGFkZGluZyA9IGxvb3AgPyBtaW4oYW1vdW50LCA0KSA6IDEsXG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gcGFkZGluZyxcblx0XHRcdFx0cGFkZGluZ1JpZ2h0ID0gcGFkZGluZyxcblx0XHRcdFx0a25vdHMgPSBbXTtcblx0XHRcdGlmICghY2xvc2VkKSB7XG5cdFx0XHRcdHBhZGRpbmdMZWZ0ID0gbWluKDEsIGZyb20pO1xuXHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBtaW4oMSwgbGVuZ3RoIC0gdG8gLSAxKTtcblx0XHRcdH1cblx0XHRcdG4gKz0gcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG5cdFx0XHRpZiAobiA8PSAxKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IGZyb20gLSBwYWRkaW5nTGVmdDsgaSA8PSBuOyBpKyssIGorKykge1xuXHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzWyhqIDwgMCA/IGogKyBsZW5ndGggOiBqKSAlIGxlbmd0aF0uX3BvaW50O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgeCA9IGtub3RzWzBdLl94ICsgMiAqIGtub3RzWzFdLl94LFxuXHRcdFx0XHR5ID0ga25vdHNbMF0uX3kgKyAyICoga25vdHNbMV0uX3ksXG5cdFx0XHRcdGYgPSAyLFxuXHRcdFx0XHRuXzEgPSBuIC0gMSxcblx0XHRcdFx0cnggPSBbeF0sXG5cdFx0XHRcdHJ5ID0gW3ldLFxuXHRcdFx0XHRyZiA9IFtmXSxcblx0XHRcdFx0cHggPSBbXSxcblx0XHRcdFx0cHkgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnRlcm5hbCA9IGkgPCBuXzEsXG5cdFx0XHRcdFx0YSA9IGludGVybmFsID8gMSA6IGFzeW1tZXRyaWMgPyAxIDogMixcblx0XHRcdFx0XHRiID0gaW50ZXJuYWwgPyA0IDogYXN5bW1ldHJpYyA/IDIgOiA3LFxuXHRcdFx0XHRcdHUgPSBpbnRlcm5hbCA/IDQgOiBhc3ltbWV0cmljID8gMyA6IDgsXG5cdFx0XHRcdFx0diA9IGludGVybmFsID8gMiA6IGFzeW1tZXRyaWMgPyAwIDogMSxcblx0XHRcdFx0XHRtID0gYSAvIGY7XG5cdFx0XHRcdGYgPSByZltpXSA9IGIgLSBtO1xuXHRcdFx0XHR4ID0gcnhbaV0gPSB1ICoga25vdHNbaV0uX3ggKyB2ICoga25vdHNbaSArIDFdLl94IC0gbSAqIHg7XG5cdFx0XHRcdHkgPSByeVtpXSA9IHUgKiBrbm90c1tpXS5feSArIHYgKiBrbm90c1tpICsgMV0uX3kgLSBtICogeTtcblx0XHRcdH1cblxuXHRcdFx0cHhbbl8xXSA9IHJ4W25fMV0gLyByZltuXzFdO1xuXHRcdFx0cHlbbl8xXSA9IHJ5W25fMV0gLyByZltuXzFdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IG4gLSAyOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRweFtpXSA9IChyeFtpXSAtIHB4W2kgKyAxXSkgLyByZltpXTtcblx0XHRcdFx0cHlbaV0gPSAocnlbaV0gLSBweVtpICsgMV0pIC8gcmZbaV07XG5cdFx0XHR9XG5cdFx0XHRweFtuXSA9ICgzICoga25vdHNbbl0uX3ggLSBweFtuXzFdKSAvIDI7XG5cdFx0XHRweVtuXSA9ICgzICoga25vdHNbbl0uX3kgLSBweVtuXzFdKSAvIDI7XG5cblx0XHRcdGZvciAodmFyIGkgPSBwYWRkaW5nTGVmdCwgbWF4ID0gbiAtIHBhZGRpbmdSaWdodCwgaiA9IGZyb207XG5cdFx0XHRcdFx0aSA8PSBtYXg7IGkrKywgaisrKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaiA8IDAgPyBqICsgbGVuZ3RoIDogal0sXG5cdFx0XHRcdFx0cHQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdFx0XHRoeCA9IHB4W2ldIC0gcHQuX3gsXG5cdFx0XHRcdFx0aHkgPSBweVtpXSAtIHB0Ll95O1xuXHRcdFx0XHRpZiAobG9vcCB8fCBpIDwgbWF4KVxuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KGh4LCBoeSk7XG5cdFx0XHRcdGlmIChsb29wIHx8IGkgPiBwYWRkaW5nTGVmdClcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKC1oeCwgLWh5KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGZyb207IGkgPD0gdG87IGkrKykge1xuXHRcdFx0XHRzZWdtZW50c1tpIDwgMCA/IGkgKyBsZW5ndGggOiBpXS5zbW9vdGgob3B0cyxcblx0XHRcdFx0XHRcdCFsb29wICYmIGkgPT09IGZyb20sICFsb29wICYmIGkgPT09IHRvKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0dG9TaGFwZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdHNpemUsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHR0b3BDZW50ZXI7XG5cblx0XHRmdW5jdGlvbiBpc0NvbGxpbmVhcihpLCBqKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdHNlZzMgPSBzZWdtZW50c1tqXSxcblx0XHRcdFx0c2VnNCA9IHNlZzMuZ2V0TmV4dCgpO1xuXHRcdFx0cmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzMuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWc0Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc0NvbGxpbmVhcihcblx0XHRcdFx0XHRcdHNlZzQuX3BvaW50LnN1YnRyYWN0KHNlZzMuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcblx0XHRcdHZhciBzZWcyID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzEgPSBzZWcyLmdldFByZXZpb3VzKCksXG5cdFx0XHRcdHNlZzMgPSBzZWcyLmdldE5leHQoKTtcblx0XHRcdHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdFx0c2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0FyYyhpKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdGhhbmRsZTEgPSBzZWcxLl9oYW5kbGVPdXQsXG5cdFx0XHRcdGhhbmRsZTIgPSBzZWcyLl9oYW5kbGVJbixcblx0XHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0XHRpZiAoaGFuZGxlMS5pc09ydGhvZ29uYWwoaGFuZGxlMikpIHtcblx0XHRcdFx0dmFyIHB0MSA9IHNlZzEuX3BvaW50LFxuXHRcdFx0XHRcdHB0MiA9IHNlZzIuX3BvaW50LFxuXHRcdFx0XHRcdGNvcm5lciA9IG5ldyBMaW5lKHB0MSwgaGFuZGxlMSwgdHJ1ZSkuaW50ZXJzZWN0KFxuXHRcdFx0XHRcdFx0XHRuZXcgTGluZShwdDIsIGhhbmRsZTIsIHRydWUpLCB0cnVlKTtcblx0XHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MSkuZ2V0TGVuZ3RoKCkgLSBrYXBwYSlcblx0XHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MikuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNIYW5kbGVzKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQ29sbGluZWFyKDAsIDIpICYmIGlzQ29sbGluZWFyKDEsIDMpICYmIGlzT3J0aG9nb25hbCgxKSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCAzKSwgZ2V0RGlzdGFuY2UoMCwgMSkpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50LmFkZChzZWdtZW50c1syXS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gOCAmJiBpc0FyYygwKSAmJiBpc0FyYygyKSAmJiBpc0FyYyg0KVxuXHRcdFx0XHQmJiBpc0FyYyg2KSAmJiBpc0NvbGxpbmVhcigxLCA1KSAmJiBpc0NvbGxpbmVhcigzLCA3KSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuXHRcdFx0cmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSxcblx0XHRcdFx0XHRnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5DaXJjbGU7XG5cdFx0XHRcdHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuXHRcdFx0XHRyYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRzaGFwZSA9IG5ldyB0eXBlKHtcblx0XHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHRzaGFwZS5jb3B5QXR0cmlidXRlcyh0aGlzLCB0cnVlKTtcblx0XHRcdHNoYXBlLl9tYXRyaXgucHJlcGVuZCh0aGlzLl9tYXRyaXgpO1xuXHRcdFx0c2hhcGUucm90YXRlKHRvcENlbnRlci5zdWJ0cmFjdChjZW50ZXIpLmdldEFuZ2xlKCkgKyA5MCk7XG5cdFx0XHRpZiAoaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgaW5zZXJ0KVxuXHRcdFx0XHRzaGFwZS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0dG9QYXRoOiAnI2Nsb25lJyxcblxuXHRjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHBhdGgpIHtcblx0XHRpZiAoIXBhdGggfHwgcGF0aCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdHJldHVybiBjb21wYXJlLmJhc2UuY2FsbCh0aGlzLCBwYXRoKTtcblx0XHR2YXIgY3VydmVzMSA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRjdXJ2ZXMyID0gcGF0aC5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBjdXJ2ZXMyLmxlbmd0aDtcblx0XHRpZiAoIWxlbmd0aDEgfHwgIWxlbmd0aDIpIHtcblx0XHRcdHJldHVybiBsZW5ndGgxID09IGxlbmd0aDI7XG5cdFx0fVxuXHRcdHZhciB2MSA9IGN1cnZlczFbMF0uZ2V0VmFsdWVzKCksXG5cdFx0XHR2YWx1ZXMyID0gW10sXG5cdFx0XHRwb3MxID0gMCwgcG9zMixcblx0XHRcdGVuZDEgPSAwLCBlbmQyO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG5cdFx0XHR2YXIgdjIgPSBjdXJ2ZXMyW2ldLmdldFZhbHVlcygpO1xuXHRcdFx0dmFsdWVzMi5wdXNoKHYyKTtcblx0XHRcdHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cdFx0XHRpZiAob3ZlcmxhcHMpIHtcblx0XHRcdFx0cG9zMiA9ICFpICYmIG92ZXJsYXBzWzBdWzBdID4gMCA/IGxlbmd0aDIgLSAxIDogaTtcblx0XHRcdFx0ZW5kMiA9IG92ZXJsYXBzWzBdWzFdO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0ZXBzaWxvbiA9IDFlLTgsXG5cdFx0XHR2MiA9IHZhbHVlczJbcG9zMl0sXG5cdFx0XHRzdGFydDI7XG5cdFx0d2hpbGUgKHYxICYmIHYyKSB7XG5cdFx0XHR2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0aWYgKG92ZXJsYXBzKSB7XG5cdFx0XHRcdHZhciB0MSA9IG92ZXJsYXBzWzBdWzBdO1xuXHRcdFx0XHRpZiAoYWJzKHQxIC0gZW5kMSkgPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0ZW5kMSA9IG92ZXJsYXBzWzFdWzBdO1xuXHRcdFx0XHRcdGlmIChlbmQxID09PSAxKSB7XG5cdFx0XHRcdFx0XHR2MSA9ICsrcG9zMSA8IGxlbmd0aDEgPyBjdXJ2ZXMxW3BvczFdLmdldFZhbHVlcygpIDogbnVsbDtcblx0XHRcdFx0XHRcdGVuZDEgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdDIgPSBvdmVybGFwc1swXVsxXTtcblx0XHRcdFx0XHRpZiAoYWJzKHQyIC0gZW5kMikgPCBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXN0YXJ0Milcblx0XHRcdFx0XHRcdFx0c3RhcnQyID0gW3BvczIsIHQyXTtcblx0XHRcdFx0XHRcdGVuZDIgPSBvdmVybGFwc1sxXVsxXTtcblx0XHRcdFx0XHRcdGlmIChlbmQyID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGlmICgrK3BvczIgPj0gbGVuZ3RoMilcblx0XHRcdFx0XHRcdFx0XHRwb3MyID0gMDtcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZXMyW3BvczJdIHx8IGN1cnZlczJbcG9zMl0uZ2V0VmFsdWVzKCk7XG5cdFx0XHRcdFx0XHRcdGVuZDIgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCF2MSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3RhcnQyWzBdID09PSBwb3MyICYmIHN0YXJ0MlsxXSA9PT0gZW5kMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zLCB2aWV3TWF0cml4LCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcblx0XHRcdHN0cm9rZVJhZGl1cyA9IGhpdFN0cm9rZVxuXHRcdFx0XHRcdD8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuXHRcdFx0XHRcdFx0PyAwIDogbnVsbDtcblx0XHRpZiAoc3Ryb2tlUmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuXHRcdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IHN0cm9rZVBhZGRpbmcuYWRkKFxuXHRcdFx0XHRcdFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpvaW4gPSBjYXAgPSAncm91bmQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcblx0XHRcdHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcblx0XHRcdGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG5cdFx0XHRcdGlmIChwdCAhPT0gYW5jaG9yKVxuXHRcdFx0XHRcdHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cdFx0XHRcdGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQ6IHNlZyxcblx0XHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuXHRcdFx0cmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG5cdFx0XHRcdCYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKVxuXHRcdFx0XHR8fCAoIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzKSAmJiAoXG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHxcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcblx0XHRcdGFyZWEuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuXHRcdFx0dmFyIGlzSm9pbiA9IGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcblx0XHRcdFx0XHQmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMTtcblx0XHRcdGlmICgoaXNKb2luID8gam9pbiA6IGNhcCkgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJlYSA9IG5ldyBQYXRoKHsgaW50ZXJuYWw6IHRydWUsIGNsb3NlZDogdHJ1ZSB9KTtcblx0XHRcdFx0aWYgKGlzSm9pbikge1xuXHRcdFx0XHRcdGlmICghc2VnbWVudC5pc1Ntb290aCgpKSB7XG5cdFx0XHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLFxuXHRcdFx0XHRcdFx0XHQgICBtaXRlckxpbWl0LCBudWxsLCBzdHJva2VNYXRyaXgsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCBzdHJva2VSYWRpdXMsIG51bGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeCwgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0dmFyIGxvYztcblx0XHRcdFx0XHRyZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcblx0XHRcdFx0XHRcdHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG5cdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuXHRcdFx0XHRcdHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspXG5cdFx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGlmIChzdHJva2VSYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGxvYyA9IHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MpIHtcblx0XHRcdFx0dmFyIHRpbWUgPSBsb2MuZ2V0VGltZSgpO1xuXHRcdFx0XHRpZiAodGltZSA9PT0gMCB8fCB0aW1lID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKVxuXHRcdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0XHRcdFx0PD0gbWl0ZXJMaW1pdCAqIHN0cm9rZVJhZGl1c1xuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHR8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogbG9jLmdldFBvaW50KClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uQXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0XHRsZW5ndGggKz0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBzdGFydCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjdXJ2ZXMubGVuZ3RoID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5nZXRMZW5ndGgoKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvZmZzZXQgJiYgb2Zmc2V0LmdldFBhdGggJiYgb2Zmc2V0LmdldFBhdGgoKSA9PT0gdGhpcykge1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0c1dpdGhUYW5nZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGFuZ2VudCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAodGFuZ2VudC5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRzID0gW107XG5cdFx0dmFyIGN1cnZlU3RhcnQgPSAwO1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0dmFyIGN1cnZlVGltZXMgPSBjdXJ2ZS5nZXRUaW1lc1dpdGhUYW5nZW50KHRhbmdlbnQpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSBjdXJ2ZVRpbWVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gY3VydmVTdGFydCArIGN1cnZlLmdldE9mZnNldEF0VGltZShjdXJ2ZVRpbWVzW2pdKTtcblx0XHRcdFx0aWYgKG9mZnNldHMuaW5kZXhPZihvZmZzZXQpIDwgMCkge1xuXHRcdFx0XHRcdG9mZnNldHMucHVzaChvZmZzZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdXJ2ZVN0YXJ0ICs9IGN1cnZlLmxlbmd0aDtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldHM7XG5cdH1cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGRyYXdIYW5kbGVzKGN0eCwgc2VnbWVudHMsIG1hdHJpeCwgc2l6ZSkge1xuXHRcdGlmIChzaXplIDw9IDApIHJldHVybjtcblxuXHRcdHZhciBoYWxmID0gc2l6ZSAvIDIsXG5cdFx0XHRtaW5pU2l6ZSA9IHNpemUgLSAyLFxuXHRcdFx0bWluaUhhbGYgPSBoYWxmIC0gMSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHBYLCBwWTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlbGVjdGlvbiA9IHNlZ21lbnQuX3NlbGVjdGlvbjtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdHBYID0gY29vcmRzWzBdO1xuXHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc2VsZWN0aW9uICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzZWxlY3Rpb24gJiA0KVxuXHRcdFx0XHRkcmF3SGFuZGxlKDQpO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiwgcFkgLSBoYWxmLCBzaXplLCBzaXplKTtcblx0XHRcdGlmIChtaW5pU2l6ZSA+IDAgJiYgIShzZWxlY3Rpb24gJiAxKSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gbWluaUhhbGYsIHBZIC0gbWluaUhhbGYsIG1pbmlTaXplLCBtaW5pU2l6ZSk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3Jkcyk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgdmlld01hdHJpeCwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG5cdFx0XHRcdHJldHVybiBkYXNoQXJyYXlbKChpICUgZGFzaExlbmd0aCkgKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgsIHBhcmFtLCB2aWV3TWF0cml4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRGaWxsUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMsIDAuMjUsIDMyLCBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBmbGF0dGVuZXIubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0ZmxhdHRlbmVyLmRyYXdQYXJ0KGN0eCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoZnJvbSwgMCksIE1hdGgubWF4KHRvLCAwKSk7XG5cdFx0XHRcdFx0XHRcdGZyb20gPSB0byArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIG1hdHJpeCk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRkcmF3SGFuZGxlcyhjdHgsIHRoaXMuX3NlZ21lbnRzLCBtYXRyaXgsIHBhcGVyLnNldHRpbmdzLmhhbmRsZVNpemUpO1xuXHRcdH1cblx0fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdHNxcnQgPSBNYXRoLnNxcnQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKSxcblx0XHRcdFx0ZnJvbSA9IGN1cnJlbnQuX3BvaW50LFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dGhyb3VnaCxcblx0XHRcdFx0cGVlayA9IEJhc2UucGVlayhhcmd1bWVudHMpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2socGVlaywgdHJ1ZSksXG5cdFx0XHRcdGNlbnRlciwgZXh0ZW50LCB2ZWN0b3IsIG1hdHJpeDtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dmFyIG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdHRocm91Z2ggPSBtaWRkbGUuYWRkKG1pZGRsZS5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UgPyAtOTAgOiA5MCkpO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLnJlbWFpbihhcmd1bWVudHMpIDw9IDIpIHtcblx0XHRcdFx0dGhyb3VnaCA9IHRvO1xuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdH0gZWxzZSBpZiAoIWZyb20uZXF1YWxzKHRvKSkge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0aXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRcdFx0aWYgKGlzWmVybyhyYWRpdXMud2lkdGgpIHx8IGlzWmVybyhyYWRpdXMuaGVpZ2h0KSlcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHR2YXIgcm90YXRpb24gPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRjbG9ja3dpc2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGxhcmdlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdHB0ID0gZnJvbS5zdWJ0cmFjdChtaWRkbGUpLnJvdGF0ZSgtcm90YXRpb24pLFxuXHRcdFx0XHRcdHggPSBwdC54LFxuXHRcdFx0XHRcdHkgPSBwdC55LFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0geCAqIHgsXG5cdFx0XHRcdFx0eVNxID0geSAqIHk7XG5cdFx0XHRcdHZhciBmYWN0b3IgPSBzcXJ0KHhTcSAvIHJ4U3EgKyB5U3EgLyByeVNxKTtcblx0XHRcdFx0aWYgKGZhY3RvciA+IDEpIHtcblx0XHRcdFx0XHRyeCAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnkgKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4O1xuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvXG5cdFx0XHRcdFx0XHQocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuXHRcdFx0XHRpZiAoYWJzKGZhY3RvcikgPCAxZS0xMilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpICogc3FydChmYWN0b3IpKVxuXHRcdFx0XHRcdFx0LnJvdGF0ZShyb3RhdGlvbikuYWRkKG1pZGRsZSk7XG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoY2VudGVyKS5yb3RhdGUocm90YXRpb24pXG5cdFx0XHRcdFx0XHQuc2NhbGUocngsIHJ5KTtcblx0XHRcdFx0dmVjdG9yID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKGZyb20pO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZShtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odG8pKTtcblx0XHRcdFx0aWYgKCFjbG9ja3dpc2UgJiYgZXh0ZW50ID4gMClcblx0XHRcdFx0XHRleHRlbnQgLT0gMzYwO1xuXHRcdFx0XHRlbHNlIGlmIChjbG9ja3dpc2UgJiYgZXh0ZW50IDwgMClcblx0XHRcdFx0XHRleHRlbnQgKz0gMzYwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRocm91Z2gpIHtcblx0XHRcdFx0dmFyIGwxID0gbmV3IExpbmUoZnJvbS5hZGQodGhyb3VnaCkuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0aHJvdWdoLnN1YnRyYWN0KGZyb20pLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGwyID0gbmV3IExpbmUodGhyb3VnaC5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dG8uc3VidHJhY3QodGhyb3VnaCkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bGluZSA9IG5ldyBMaW5lKGZyb20sIHRvKSxcblx0XHRcdFx0XHR0aHJvdWdoU2lkZSA9IGxpbmUuZ2V0U2lkZSh0aHJvdWdoKTtcblx0XHRcdFx0Y2VudGVyID0gbDEuaW50ZXJzZWN0KGwyLCB0cnVlKTtcblx0XHRcdFx0aWYgKCFjZW50ZXIpIHtcblx0XHRcdFx0XHRpZiAoIXRocm91Z2hTaWRlKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSBmcm9tLnN1YnRyYWN0KGNlbnRlcik7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKHRvLnN1YnRyYWN0KGNlbnRlcikpO1xuXHRcdFx0XHR2YXIgY2VudGVyU2lkZSA9IGxpbmUuZ2V0U2lkZShjZW50ZXIsIHRydWUpO1xuXHRcdFx0XHRpZiAoY2VudGVyU2lkZSA9PT0gMCkge1xuXHRcdFx0XHRcdGV4dGVudCA9IHRocm91Z2hTaWRlICogYWJzKGV4dGVudCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcblx0XHRcdFx0XHRleHRlbnQgKz0gZXh0ZW50IDwgMCA/IDM2MCA6IC0zNjA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChleHRlbnQpIHtcblx0XHRcdFx0dmFyIGVwc2lsb24gPSAxZS03LFxuXHRcdFx0XHRcdGV4dCA9IGFicyhleHRlbnQpLFxuXHRcdFx0XHRcdGNvdW50ID0gZXh0ID49IDM2MCA/IDQgOiBNYXRoLmNlaWwoKGV4dCAtIGVwc2lsb24pIC8gOTApLFxuXHRcdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRcdGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuXHRcdFx0XHRcdHogPSA0IC8gMyAqIE1hdGguc2luKGhhbGYpIC8gKDEgKyBNYXRoLmNvcyhoYWxmKSksXG5cdFx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwdCA9IHRvLFxuXHRcdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0XHRvdXQgPSB2ZWN0b3Iucm90YXRlKDkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdFx0cHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG5cdFx0XHRcdFx0XHRcdG91dCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChvdXQpKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB0ID0gY2VudGVyLmFkZCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIWkpIHtcblx0XHRcdFx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KG91dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRcdF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZlY3RvciA9IHZlY3Rvci5yb3RhdGUoaW5jKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRsaW5lQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0Y3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksXG5cdFx0XHRcdFx0Y3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdHRoaXMuam9pbih0aGlzLCB0b2xlcmFuY2UpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgbWV0aG9kID0gb3B0aW9ucy5oYW5kbGVcblx0XHRcdFx0PyAnZ2V0SGFuZGxlQm91bmRzJ1xuXHRcdFx0XHQ6IG9wdGlvbnMuc3Ryb2tlXG5cdFx0XHRcdD8gJ2dldFN0cm9rZUJvdW5kcydcblx0XHRcdFx0OiAnZ2V0Qm91bmRzJztcblx0XHRyZXR1cm4gUGF0aFttZXRob2RdKHRoaXMuX3NlZ21lbnRzLCB0aGlzLl9jbG9zZWQsIHRoaXMsIG1hdHJpeCwgb3B0aW9ucyk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSksXG5cdFx0XHRtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IG5ldyBBcnJheSgyKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdEN1cnZlLl9hZGRCb3VuZHMoXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpXSxcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSxcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpXSxcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgcGF0aCwgbWF0cml4LCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0eWxlID0gcGF0aC5nZXRTdHlsZSgpLFxuXHRcdFx0c3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRzdHJva2VXaWR0aCA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCksXG5cdFx0XHRzdHJva2VNYXRyaXggPSBzdHJva2UgJiYgcGF0aC5fZ2V0U3Ryb2tlTWF0cml4KG1hdHJpeCwgb3B0aW9ucyksXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gc3Ryb2tlICYmIFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlV2lkdGgsXG5cdFx0XHRcdHN0cm9rZU1hdHJpeCksXG5cdFx0XHRib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBwYXRoLCBtYXRyaXgsIG9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcpO1xuXHRcdGlmICghc3Ryb2tlKVxuXHRcdFx0cmV0dXJuIGJvdW5kcztcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3Ryb2tlV2lkdGggLyAyLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKSxcblx0XHRcdGpvaW5Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBTaXplKHN0cm9rZVBhZGRpbmcpKTtcblxuXHRcdGZ1bmN0aW9uIGFkZFBvaW50KHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKFxuXHRcdFx0XHRcdGpvaW5Cb3VuZHMuc2V0Q2VudGVyKHNlZ21lbnQuX3BvaW50LnRyYW5zZm9ybShtYXRyaXgpKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkSm9pbihzZWdtZW50LCBqb2luKSB7XG5cdFx0XHRpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCBzZWdtZW50LmlzU21vb3RoKCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgc3Ryb2tlUmFkaXVzLCBtaXRlckxpbWl0LFxuXHRcdFx0XHRcdFx0bWF0cml4LCBzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgc3Ryb2tlUmFkaXVzLCBtYXRyaXgsXG5cdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgsIGFkZFBvaW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0YWRkSm9pbihzZWdtZW50c1tpXSwgam9pbik7XG5cdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0YWRkSm9pbihzZWdtZW50c1swXSwgam9pbik7XG5cdFx0fSBlbHNlIGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRhZGRDYXAoc2VnbWVudHNbMF0sIGNhcCk7XG5cdFx0XHRhZGRDYXAoc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIGNhcCk7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0X2dldFN0cm9rZVBhZGRpbmc6IGZ1bmN0aW9uKHJhZGl1cywgbWF0cml4KSB7XG5cdFx0aWYgKCFtYXRyaXgpXG5cdFx0XHRyZXR1cm4gW3JhZGl1cywgcmFkaXVzXTtcblx0XHR2YXIgaG9yID0gbmV3IFBvaW50KHJhZGl1cywgMCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHR2ZXIgPSBuZXcgUG9pbnQoMCwgcmFkaXVzKS50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdHBoaSA9IGhvci5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YSA9IGhvci5nZXRMZW5ndGgoKSxcblx0XHRcdGIgPSB2ZXIuZ2V0TGVuZ3RoKCk7XG5cdFx0dmFyIHNpbiA9IE1hdGguc2luKHBoaSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhwaGkpLFxuXHRcdFx0dGFuID0gTWF0aC50YW4ocGhpKSxcblx0XHRcdHR4ID0gTWF0aC5hdGFuMihiICogdGFuLCBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuMihiLCB0YW4gKiBhKTtcblx0XHRyZXR1cm4gW01hdGguYWJzKGEgKiBNYXRoLmNvcyh0eCkgKiBjb3MgKyBiICogTWF0aC5zaW4odHgpICogc2luKSxcblx0XHRcdFx0TWF0aC5hYnMoYiAqIE1hdGguc2luKHR5KSAqIGNvcyArIGEgKiBNYXRoLmNvcyh0eSkgKiBzaW4pXTtcblx0fSxcblxuXHRfYWRkQmV2ZWxKb2luOiBmdW5jdGlvbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsIG1hdHJpeCxcblx0XHRcdHN0cm9rZU1hdHJpeCwgYWRkUG9pbnQsIGlzQXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50MSgpLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdFRpbWUoMSkubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0XHQudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCksXG5cdFx0XHRub3JtYWwyID0gY3VydmUyLmdldE5vcm1hbEF0VGltZSgwKS5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHRcdC50cmFuc2Zvcm0oc3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0YW5nbGUgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMik7XG5cdFx0aWYgKGFuZ2xlIDwgMCB8fCBhbmdsZSA+PSAxODApIHtcblx0XHRcdG5vcm1hbDEgPSBub3JtYWwxLm5lZ2F0ZSgpO1xuXHRcdFx0bm9ybWFsMiA9IG5vcm1hbDIubmVnYXRlKCk7XG5cdFx0fVxuXHRcdGlmIChpc0FyZWEpXG5cdFx0XHRhZGRQb2ludChwb2ludCk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRpZiAoam9pbiA9PT0gJ21pdGVyJykge1xuXHRcdFx0dmFyIGNvcm5lciA9IG5ldyBMaW5lKHBvaW50LmFkZChub3JtYWwxKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDEueSwgbm9ybWFsMS54KSwgdHJ1ZVxuXHRcdFx0XHQpLmludGVyc2VjdChuZXcgTGluZShwb2ludC5hZGQobm9ybWFsMiksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwyLnksIG5vcm1hbDIueCksIHRydWVcblx0XHRcdFx0KSwgdHJ1ZSk7XG5cdFx0XHRpZiAoY29ybmVyICYmIHBvaW50LmdldERpc3RhbmNlKGNvcm5lcikgPD0gbWl0ZXJMaW1pdCAqIHJhZGl1cykge1xuXHRcdFx0XHRhZGRQb2ludChjb3JuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBtYXRyaXgsIHN0cm9rZU1hdHJpeCxcblx0XHRcdGFkZFBvaW50LCBpc0FyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludC50cmFuc2Zvcm0obWF0cml4KSxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKVxuXHRcdFx0XHRcdC5tdWx0aXBseShsb2MuZ2V0VGltZSgpID09PSAwID8gcmFkaXVzIDogLXJhZGl1cylcblx0XHRcdFx0XHQudHJhbnNmb3JtKHN0cm9rZU1hdHJpeCk7XG5cdFx0aWYgKGNhcCA9PT0gJ3NxdWFyZScpIHtcblx0XHRcdGlmIChpc0FyZWEpIHtcblx0XHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRcdH1cblx0XHRcdHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUoLTkwKSk7XG5cdFx0fVxuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHBhdGgsIG1hdHJpeCwgb3B0aW9ucykge1xuXHRcdHZhciBzdHlsZSA9IHBhdGguZ2V0U3R5bGUoKSxcblx0XHRcdHN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyxcblx0XHRcdGpvaW5QYWRkaW5nO1xuXHRcdGlmIChzdHJva2UpIHtcblx0XHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXRoLl9nZXRTdHJva2VNYXRyaXgobWF0cml4LCBvcHRpb25zKSxcblx0XHRcdFx0c3Ryb2tlUmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXM7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguU1FSVDIpO1xuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IFBhdGguX2dldFN0cm9rZVBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0am9pblBhZGRpbmcgPSBQYXRoLl9nZXRTdHJva2VQYWRkaW5nKGpvaW5SYWRpdXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0fVxuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHR4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG5cdFx0XHRcdHZhciBwYWRkaW5nID0gIWogPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChbXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLm1vdmVUbyhmcm9tKTtcblx0XHRcdHBhdGguYXJjVG8odGhyb3VnaCwgdG8pO1xuXHRcdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0XHR9LFxuXG5cdFx0UmVndWxhclBvbHlnb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0c2lkZXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdzaWRlcycpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHNpZGVzLFxuXHRcdFx0XHR0aHJlZSA9IHNpZGVzICUgMyA9PT0gMCxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIHRocmVlID8gLXJhZGl1cyA6IHJhZGl1cyksXG5cdFx0XHRcdG9mZnNldCA9IHRocmVlID8gLTEgOiAwLjUsXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHNpZGVzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKFxuXHRcdFx0XHRcdHZlY3Rvci5yb3RhdGUoKGkgKyBvZmZzZXQpICogc3RlcCkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRTdGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3BvaW50cycpICogMixcblx0XHRcdFx0cmFkaXVzMSA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czEnKSxcblx0XHRcdFx0cmFkaXVzMiA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czInKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHBvaW50cyxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIC0xKSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkocG9pbnRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59fSk7XG5cbnZhciBDb21wb3VuZFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDb21wb3VuZFBhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcykge1xuXHRcdHZhciBsaXN0ID0gaXRlbXMsXG5cdFx0XHRmaXJzdCA9IGxpc3RbMF07XG5cdFx0aWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdFswXSA9PT0gJ251bWJlcicpXG5cdFx0XHRsaXN0ID0gW2xpc3RdO1xuXHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdFx0aWYgKGxpc3QgPT09IGl0ZW1zICYmICEoaXRlbSBpbnN0YW5jZW9mIFBhdGgpKVxuXHRcdFx0XHRsaXN0ID0gQmFzZS5zbGljZShsaXN0KTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG5cdFx0XHRcdGxpc3RbaV0gPSBuZXcgUGF0aCh7IHNlZ21lbnRzOiBpdGVtLCBpbnNlcnQ6IGZhbHNlIH0pO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG5cdFx0XHRcdGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIFtpLCAxXS5jb25jYXQoaXRlbS5yZW1vdmVDaGlsZHJlbigpKSk7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGxpc3QpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKG9wdGlvbnMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gY2hpbGRyZW5baV0ucmVkdWNlKG9wdGlvbnMpO1xuXHRcdFx0aWYgKHBhdGguaXNFbXB0eSgpKVxuXHRcdFx0XHRwYXRoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLmNvcHlBdHRyaWJ1dGVzKHRoaXMpO1xuXHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHJlZHVjZS5iYXNlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0aXNDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoIWNoaWxkcmVuW2ldLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0c2V0Q2xvc2VkOiBmdW5jdGlvbihjbG9zZWQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y2hpbGRyZW5baV0uc2V0Q2xvc2VkKGNsb3NlZCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0QmFzZS5wdXNoKGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVzO1xuXHR9LFxuXG5cdGdldEZpcnN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdHJldHVybiBmaXJzdCAmJiBmaXJzdC5nZXRGaXJzdEN1cnZlKCk7XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsZW5ndGggKz0gY2hpbGRyZW5baV0uZ2V0TGVuZ3RoKCk7XG5cdFx0cmV0dXJuIGxlbmd0aDtcblx0fSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGF0aHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpXG5cdFx0XHRcdFx0PyBfbWF0cml4LmFwcGVuZGVkKG14KSA6IF9tYXRyaXgsIF9wcmVjaXNpb24pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzLmpvaW4oJycpO1xuXHR9LFxuXG5cdF9oaXRUZXN0Q2hpbGRyZW46IGZ1bmN0aW9uIF9oaXRUZXN0Q2hpbGRyZW4ocG9pbnQsIG9wdGlvbnMsIHZpZXdNYXRyaXgpIHtcblx0XHRyZXR1cm4gX2hpdFRlc3RDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgcG9pbnQsXG5cdFx0XHRcdG9wdGlvbnMuY2xhc3MgPT09IFBhdGggfHwgb3B0aW9ucy50eXBlID09PSAncGF0aCcgPyBvcHRpb25zXG5cdFx0XHRcdFx0OiBCYXNlLnNldCh7fSwgb3B0aW9ucywgeyBmaWxsOiBmYWxzZSB9KSxcblx0XHRcdFx0dmlld01hdHJpeCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgsIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4ubGVuZ3RoKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXG5cdFx0aWYgKCFwYXJhbS5jbGlwKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4LCBwYXJhbSwgdmlld01hdHJpeCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0RmlsbFJ1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2VsZWN0aW9uSXRlbXMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdGlmICghc2VsZWN0aW9uSXRlbXNbY2hpbGQuX2lkXSkge1xuXHRcdFx0XHRjaGlsZC5fZHJhd1NlbGVjdGVkKGN0eCwgbXguaXNJZGVudGl0eSgpID8gbWF0cml4XG5cdFx0XHRcdFx0XHQ6IG1hdHJpeC5hcHBlbmRlZChteCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgIWNoaWxkcmVuLmxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiBCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsXG5cdFx0XHQnYXJjVG8nLCAnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLFxuXHRcdFx0J2FyY0J5J10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR0aGlzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdG1vdmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdDogbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0XHRwYXRoLm1vdmVUby5hcHBseShwYXRoLCBhcmd1bWVudHMpO1xuXHRcdFx0fSxcblxuXHRcdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKSxcblx0XHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMubW92ZVRvKGxhc3QgPyBwb2ludC5hZGQobGFzdC5fcG9pbnQpIDogcG9pbnQpO1xuXHRcdFx0fSxcblxuXHRcdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKHRvbGVyYW5jZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSwgQmFzZS5lYWNoKFsncmV2ZXJzZScsICdmbGF0dGVuJywgJ3NpbXBsaWZ5JywgJ3Ntb290aCddLCBmdW5jdGlvbihrZXkpIHtcblx0dGhpc1trZXldID0gZnVuY3Rpb24ocGFyYW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHJlcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0cmVzID0gY2hpbGRyZW5baV1ba2V5XShwYXJhbSkgfHwgcmVzO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9O1xufSwge30pKTtcblxuUGF0aEl0ZW0uaW5qZWN0KG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdG9wZXJhdG9ycyA9IHtcblx0XHRcdHVuaXRlOiAgICAgeyAnMSc6IHRydWUsICcyJzogdHJ1ZSB9LFxuXHRcdFx0aW50ZXJzZWN0OiB7ICcyJzogdHJ1ZSB9LFxuXHRcdFx0c3VidHJhY3Q6ICB7ICcxJzogdHJ1ZSB9LFxuXHRcdFx0ZXhjbHVkZTogICB7ICcxJzogdHJ1ZSwgJy0xJzogdHJ1ZSB9XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoLCByZXNvbHZlKSB7XG5cdFx0dmFyIHJlcyA9IHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSh7IHNpbXBsaWZ5OiB0cnVlIH0pXG5cdFx0XHRcdC50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHJlc29sdmVcblx0XHRcdFx0PyByZXMucmVzb2x2ZUNyb3NzaW5ncygpLnJlb3JpZW50KFxuXHRcdFx0XHRcdHJlcy5nZXRGaWxsUnVsZSgpID09PSAnbm9uemVybycsIHRydWUpXG5cdFx0XHRcdDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlUmVzdWx0KHBhdGhzLCBzaW1wbGlmeSwgcGF0aDEsIHBhdGgyLCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbihwYXRocywgdHJ1ZSk7XG5cdFx0cmVzdWx0ID0gcmVzdWx0LnJlZHVjZSh7IHNpbXBsaWZ5OiBzaW1wbGlmeSB9KTtcblx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuaW5zZXJ0ID09IGZhbHNlKSkge1xuXHRcdFx0cmVzdWx0Lmluc2VydEFib3ZlKHBhdGgyICYmIHBhdGgxLmlzU2libGluZyhwYXRoMilcblx0XHRcdFx0XHQmJiBwYXRoMS5nZXRJbmRleCgpIDwgcGF0aDIuZ2V0SW5kZXgoKSA/IHBhdGgyIDogcGF0aDEpO1xuXHRcdH1cblx0XHRyZXN1bHQuY29weUF0dHJpYnV0ZXMocGF0aDEsIHRydWUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFjZUJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50cmFjZSA9PSBmYWxzZSB8fCBvcHRpb25zLnN0cm9rZSkgJiZcblx0XHRcdFx0L14oc3VidHJhY3R8aW50ZXJzZWN0KSQvLnRlc3Qob3BlcmF0aW9uKSlcblx0XHRcdHJldHVybiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pO1xuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSwgdHJ1ZSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIsIHRydWUpLFxuXHRcdFx0b3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0aW9uXTtcblx0XHRvcGVyYXRvcltvcGVyYXRpb25dID0gdHJ1ZTtcblx0XHRpZiAoX3BhdGgyICYmIChvcGVyYXRvci5zdWJ0cmFjdCB8fCBvcGVyYXRvci5leGNsdWRlKVxuXHRcdFx0XHReIChfcGF0aDIuaXNDbG9ja3dpc2UoKSBeIF9wYXRoMS5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0dmFyIGNyb3NzaW5ncyA9IGRpdmlkZUxvY2F0aW9ucyhcblx0XHRcdFx0Q3VydmVMb2NhdGlvbi5leHBhbmQoX3BhdGgxLmdldENyb3NzaW5ncyhfcGF0aDIpKSksXG5cdFx0XHRwYXRoczEgPSBfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdLFxuXHRcdFx0cGF0aHMyID0gX3BhdGgyICYmIChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhdGhzO1xuXG5cdFx0ZnVuY3Rpb24gY29sbGVjdChwYXRocykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGggPSBwYXRoc1tpXTtcblx0XHRcdFx0QmFzZS5wdXNoKHNlZ21lbnRzLCBwYXRoLl9zZWdtZW50cyk7XG5cdFx0XHRcdEJhc2UucHVzaChjdXJ2ZXMsIHBhdGguZ2V0Q3VydmVzKCkpO1xuXHRcdFx0XHRwYXRoLl9vdmVybGFwc09ubHkgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjcm9zc2luZ3MubGVuZ3RoKSB7XG5cdFx0XHRjb2xsZWN0KHBhdGhzMSk7XG5cdFx0XHRpZiAocGF0aHMyKVxuXHRcdFx0XHRjb2xsZWN0KHBhdGhzMik7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNyb3NzaW5ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cHJvcGFnYXRlV2luZGluZyhjcm9zc2luZ3NbaV0uX3NlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZXMsXG5cdFx0XHRcdFx0XHRvcGVyYXRvcik7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRpZiAoIXNlZ21lbnQuX3dpbmRpbmcpIHtcblx0XHRcdFx0XHRwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBjdXJ2ZXMsIG9wZXJhdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIShpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCkpXG5cdFx0XHRcdFx0c2VnbWVudC5fcGF0aC5fb3ZlcmxhcHNPbmx5ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRwYXRocyA9IHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGF0aHMgPSByZW9yaWVudFBhdGhzKFxuXHRcdFx0XHRcdHBhdGhzMiA/IHBhdGhzMS5jb25jYXQocGF0aHMyKSA6IHBhdGhzMS5zbGljZSgpLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0XHRcdHJldHVybiAhIW9wZXJhdG9yW3ddO1xuXHRcdFx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVSZXN1bHQocGF0aHMsIHRydWUsIHBhdGgxLCBwYXRoMiwgb3B0aW9ucyk7XG5cdH1cblxuXHRmdW5jdGlvbiBzcGxpdEJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEpLFxuXHRcdFx0X3BhdGgyID0gcHJlcGFyZVBhdGgocGF0aDIpLFxuXHRcdFx0Y3Jvc3NpbmdzID0gX3BhdGgxLmdldENyb3NzaW5ncyhfcGF0aDIpLFxuXHRcdFx0c3VidHJhY3QgPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcsXG5cdFx0XHRkaXZpZGUgPSBvcGVyYXRpb24gPT09ICdkaXZpZGUnLFxuXHRcdFx0YWRkZWQgPSB7fSxcblx0XHRcdHBhdGhzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRQYXRoKHBhdGgpIHtcblx0XHRcdGlmICghYWRkZWRbcGF0aC5faWRdICYmIChkaXZpZGUgfHxcblx0XHRcdFx0XHRfcGF0aDIuY29udGFpbnMocGF0aC5nZXRQb2ludEF0KHBhdGguZ2V0TGVuZ3RoKCkgLyAyKSlcblx0XHRcdFx0XHRcdF4gc3VidHJhY3QpKSB7XG5cdFx0XHRcdHBhdGhzLnVuc2hpZnQocGF0aCk7XG5cdFx0XHRcdHJldHVybiBhZGRlZFtwYXRoLl9pZF0gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBjcm9zc2luZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gY3Jvc3NpbmdzW2ldLnNwbGl0KCk7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRpZiAoYWRkUGF0aChwYXRoKSlcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXHRcdFx0XHRfcGF0aDEuZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZFBhdGgoX3BhdGgxKTtcblx0XHRyZXR1cm4gY3JlYXRlUmVzdWx0KHBhdGhzLCBmYWxzZSwgcGF0aDEsIHBhdGgyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpbmtJbnRlcnNlY3Rpb25zKGZyb20sIHRvKSB7XG5cdFx0dmFyIHByZXYgPSBmcm9tO1xuXHRcdHdoaWxlIChwcmV2KSB7XG5cdFx0XHRpZiAocHJldiA9PT0gdG8pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXYgPSBwcmV2Ll9wcmV2aW91cztcblx0XHR9XG5cdFx0d2hpbGUgKGZyb20uX25leHQgJiYgZnJvbS5fbmV4dCAhPT0gdG8pXG5cdFx0XHRmcm9tID0gZnJvbS5fbmV4dDtcblx0XHRpZiAoIWZyb20uX25leHQpIHtcblx0XHRcdHdoaWxlICh0by5fcHJldmlvdXMpXG5cdFx0XHRcdHRvID0gdG8uX3ByZXZpb3VzO1xuXHRcdFx0ZnJvbS5fbmV4dCA9IHRvO1xuXHRcdFx0dG8uX3ByZXZpb3VzID0gZnJvbTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhckN1cnZlSGFuZGxlcyhjdXJ2ZXMpIHtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0Y3VydmVzW2ldLmNsZWFySGFuZGxlcygpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVvcmllbnRQYXRocyhwYXRocywgaXNJbnNpZGUsIGNsb2Nrd2lzZSkge1xuXHRcdHZhciBsZW5ndGggPSBwYXRocyAmJiBwYXRocy5sZW5ndGg7XG5cdFx0aWYgKGxlbmd0aCkge1xuXHRcdFx0dmFyIGxvb2t1cCA9IEJhc2UuZWFjaChwYXRocywgZnVuY3Rpb24gKHBhdGgsIGkpIHtcblx0XHRcdFx0XHR0aGlzW3BhdGguX2lkXSA9IHtcblx0XHRcdFx0XHRcdGNvbnRhaW5lcjogbnVsbCxcblx0XHRcdFx0XHRcdHdpbmRpbmc6IHBhdGguaXNDbG9ja3dpc2UoKSA/IDEgOiAtMSxcblx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSwge30pLFxuXHRcdFx0XHRzb3J0ZWQgPSBwYXRocy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYWJzKGIuZ2V0QXJlYSgpKSAtIGFicyhhLmdldEFyZWEoKSk7XG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRmaXJzdCA9IHNvcnRlZFswXTtcblx0XHRcdGlmIChjbG9ja3dpc2UgPT0gbnVsbClcblx0XHRcdFx0Y2xvY2t3aXNlID0gZmlyc3QuaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGgxID0gc29ydGVkW2ldLFxuXHRcdFx0XHRcdGVudHJ5MSA9IGxvb2t1cFtwYXRoMS5faWRdLFxuXHRcdFx0XHRcdHBvaW50ID0gcGF0aDEuZ2V0SW50ZXJpb3JQb2ludCgpLFxuXHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGgyID0gc29ydGVkW2pdO1xuXHRcdFx0XHRcdGlmIChwYXRoMi5jb250YWlucyhwb2ludCkpIHtcblx0XHRcdFx0XHRcdHZhciBlbnRyeTIgPSBsb29rdXBbcGF0aDIuX2lkXTtcblx0XHRcdFx0XHRcdGNvbnRhaW5lcldpbmRpbmcgPSBlbnRyeTIud2luZGluZztcblx0XHRcdFx0XHRcdGVudHJ5MS53aW5kaW5nICs9IGNvbnRhaW5lcldpbmRpbmc7XG5cdFx0XHRcdFx0XHRlbnRyeTEuY29udGFpbmVyID0gZW50cnkyLmV4Y2x1ZGUgPyBlbnRyeTIuY29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdFx0OiBwYXRoMjtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNJbnNpZGUoZW50cnkxLndpbmRpbmcpID09PSBpc0luc2lkZShjb250YWluZXJXaW5kaW5nKSkge1xuXHRcdFx0XHRcdGVudHJ5MS5leGNsdWRlID0gdHJ1ZTtcblx0XHRcdFx0XHRwYXRoc1tlbnRyeTEuaW5kZXhdID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY29udGFpbmVyID0gZW50cnkxLmNvbnRhaW5lcjtcblx0XHRcdFx0XHRwYXRoMS5zZXRDbG9ja3dpc2UoY29udGFpbmVyID8gIWNvbnRhaW5lci5pc0Nsb2Nrd2lzZSgpXG5cdFx0XHRcdFx0XHRcdDogY2xvY2t3aXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRmdW5jdGlvbiBkaXZpZGVMb2NhdGlvbnMobG9jYXRpb25zLCBpbmNsdWRlLCBjbGVhckxhdGVyKSB7XG5cdFx0dmFyIHJlc3VsdHMgPSBpbmNsdWRlICYmIFtdLFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRjbGVhckhhbmRsZXMgPSBmYWxzZSxcblx0XHRcdGNsZWFyQ3VydmVzID0gY2xlYXJMYXRlciB8fCBbXSxcblx0XHRcdGNsZWFyTG9va3VwID0gY2xlYXJMYXRlciAmJiB7fSxcblx0XHRcdHJlbm9ybWFsaXplTG9jcyxcblx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdHByZXZUaW1lO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0SWQoY3VydmUpIHtcblx0XHRcdHJldHVybiBjdXJ2ZS5fcGF0aC5faWQgKyAnLicgKyBjdXJ2ZS5fc2VnbWVudDEuX2luZGV4O1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAoY2xlYXJMYXRlciAmJiBjbGVhckxhdGVyLmxlbmd0aCkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY2xlYXJMYXRlcltpXTtcblx0XHRcdGlmIChjdXJ2ZS5fcGF0aClcblx0XHRcdFx0Y2xlYXJMb29rdXBbZ2V0SWQoY3VydmUpXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcblx0XHRcdFx0dGltZSA9IGxvYy5fdGltZSxcblx0XHRcdFx0b3JpZ1RpbWUgPSB0aW1lLFxuXHRcdFx0XHRleGNsdWRlID0gaW5jbHVkZSAmJiAhaW5jbHVkZShsb2MpLFxuXHRcdFx0XHRjdXJ2ZSA9IGxvYy5fY3VydmUsXG5cdFx0XHRcdHNlZ21lbnQ7XG5cdFx0XHRpZiAoY3VydmUpIHtcblx0XHRcdFx0aWYgKGN1cnZlICE9PSBwcmV2Q3VydmUpIHtcblx0XHRcdFx0XHRjbGVhckhhbmRsZXMgPSAhY3VydmUuaGFzSGFuZGxlcygpXG5cdFx0XHRcdFx0XHRcdHx8IGNsZWFyTG9va3VwICYmIGNsZWFyTG9va3VwW2dldElkKGN1cnZlKV07XG5cdFx0XHRcdFx0cmVub3JtYWxpemVMb2NzID0gW107XG5cdFx0XHRcdFx0cHJldlRpbWUgPSBudWxsO1xuXHRcdFx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHByZXZUaW1lID49IHRNaW4pIHtcblx0XHRcdFx0XHR0aW1lIC89IHByZXZUaW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhjbHVkZSkge1xuXHRcdFx0XHRpZiAocmVub3JtYWxpemVMb2NzKVxuXHRcdFx0XHRcdHJlbm9ybWFsaXplTG9jcy5wdXNoKGxvYyk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpbmNsdWRlKSB7XG5cdFx0XHRcdHJlc3VsdHMudW5zaGlmdChsb2MpO1xuXHRcdFx0fVxuXHRcdFx0cHJldlRpbWUgPSBvcmlnVGltZTtcblx0XHRcdGlmICh0aW1lIDwgdE1pbikge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmICh0aW1lID4gdE1heCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIG5ld0N1cnZlID0gY3VydmUuZGl2aWRlQXRUaW1lKHRpbWUsIHRydWUpO1xuXHRcdFx0XHRpZiAoY2xlYXJIYW5kbGVzKVxuXHRcdFx0XHRcdGNsZWFyQ3VydmVzLnB1c2goY3VydmUsIG5ld0N1cnZlKTtcblx0XHRcdFx0c2VnbWVudCA9IG5ld0N1cnZlLl9zZWdtZW50MTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IHJlbm9ybWFsaXplTG9jcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdHZhciBsID0gcmVub3JtYWxpemVMb2NzW2pdO1xuXHRcdFx0XHRcdGwuX3RpbWUgPSAobC5fdGltZSAtIHRpbWUpIC8gKDEgLSB0aW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bG9jLl9zZXRTZWdtZW50KHNlZ21lbnQpO1xuXHRcdFx0dmFyIGludGVyID0gc2VnbWVudC5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRkZXN0ID0gbG9jLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRpZiAoaW50ZXIpIHtcblx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMoaW50ZXIsIGRlc3QpO1xuXHRcdFx0XHR2YXIgb3RoZXIgPSBpbnRlcjtcblx0XHRcdFx0d2hpbGUgKG90aGVyKSB7XG5cdFx0XHRcdFx0bGlua0ludGVyc2VjdGlvbnMob3RoZXIuX2ludGVyc2VjdGlvbiwgaW50ZXIpO1xuXHRcdFx0XHRcdG90aGVyID0gb3RoZXIuX25leHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQuX2ludGVyc2VjdGlvbiA9IGRlc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghY2xlYXJMYXRlcilcblx0XHRcdGNsZWFyQ3VydmVIYW5kbGVzKGNsZWFyQ3VydmVzKTtcblx0XHRyZXR1cm4gcmVzdWx0cyB8fCBsb2NhdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGRpciwgY2xvc2VkLCBkb250RmxpcCkge1xuXHRcdHZhciBpYSA9IGRpciA/IDEgOiAwLFxuXHRcdFx0aW8gPSBpYSBeIDEsXG5cdFx0XHRwdiA9IFtwb2ludC54LCBwb2ludC55XSxcblx0XHRcdHBhID0gcHZbaWFdLFxuXHRcdFx0cG8gPSBwdltpb10sXG5cdFx0XHR3aW5kaW5nRXBzaWxvbiA9IDFlLTksXG5cdFx0XHRxdWFsaXR5RXBzaWxvbiA9IDFlLTYsXG5cdFx0XHRwYUwgPSBwYSAtIHdpbmRpbmdFcHNpbG9uLFxuXHRcdFx0cGFSID0gcGEgKyB3aW5kaW5nRXBzaWxvbixcblx0XHRcdHdpbmRpbmdMID0gMCxcblx0XHRcdHdpbmRpbmdSID0gMCxcblx0XHRcdHBhdGhXaW5kaW5nTCA9IDAsXG5cdFx0XHRwYXRoV2luZGluZ1IgPSAwLFxuXHRcdFx0b25QYXRoID0gZmFsc2UsXG5cdFx0XHRvbkFueVBhdGggPSBmYWxzZSxcblx0XHRcdHF1YWxpdHkgPSAxLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdHZQcmV2LFxuXHRcdFx0dkNsb3NlO1xuXG5cdFx0ZnVuY3Rpb24gYWRkV2luZGluZyh2KSB7XG5cdFx0XHR2YXIgbzAgPSB2W2lvICsgMF0sXG5cdFx0XHRcdG8zID0gdltpbyArIDZdO1xuXHRcdFx0aWYgKHBvIDwgbWluKG8wLCBvMykgfHwgcG8gPiBtYXgobzAsIG8zKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgYTAgPSB2W2lhICsgMF0sXG5cdFx0XHRcdGExID0gdltpYSArIDJdLFxuXHRcdFx0XHRhMiA9IHZbaWEgKyA0XSxcblx0XHRcdFx0YTMgPSB2W2lhICsgNl07XG5cdFx0XHRpZiAobzAgPT09IG8zKSB7XG5cdFx0XHRcdGlmIChhMCA8IHBhUiAmJiBhMyA+IHBhTCB8fCBhMyA8IHBhUiAmJiBhMCA+IHBhTCkge1xuXHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHQgPSAgIHBvID09PSBvMCA/IDBcblx0XHRcdFx0XHQ6IHBvID09PSBvMyA/IDFcblx0XHRcdFx0XHQ6IHBhTCA+IG1heChhMCwgYTEsIGEyLCBhMykgfHwgcGFSIDwgbWluKGEwLCBhMSwgYTIsIGEzKVxuXHRcdFx0XHRcdD8gMVxuXHRcdFx0XHRcdDogQ3VydmUuc29sdmVDdWJpYyh2LCBpbywgcG8sIHJvb3RzLCAwLCAxKSA+IDBcblx0XHRcdFx0XHRcdD8gcm9vdHNbMF1cblx0XHRcdFx0XHRcdDogMSxcblx0XHRcdFx0YSA9ICAgdCA9PT0gMCA/IGEwXG5cdFx0XHRcdFx0OiB0ID09PSAxID8gYTNcblx0XHRcdFx0XHQ6IEN1cnZlLmdldFBvaW50KHYsIHQpW2RpciA/ICd5JyA6ICd4J10sXG5cdFx0XHRcdHdpbmRpbmcgPSBvMCA+IG8zID8gMSA6IC0xLFxuXHRcdFx0XHR3aW5kaW5nUHJldiA9IHZQcmV2W2lvXSA+IHZQcmV2W2lvICsgNl0gPyAxIDogLTEsXG5cdFx0XHRcdGEzUHJldiA9IHZQcmV2W2lhICsgNl07XG5cdFx0XHRpZiAocG8gIT09IG8wKSB7XG5cdFx0XHRcdGlmIChhIDwgcGFMKSB7XG5cdFx0XHRcdFx0cGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYSA+IHBhUikge1xuXHRcdFx0XHRcdHBhdGhXaW5kaW5nUiArPSB3aW5kaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9uUGF0aCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGEgPiBwYSAtIHF1YWxpdHlFcHNpbG9uICYmIGEgPCBwYSArIHF1YWxpdHlFcHNpbG9uKVxuXHRcdFx0XHRcdHF1YWxpdHkgLz0gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh3aW5kaW5nICE9PSB3aW5kaW5nUHJldikge1xuXHRcdFx0XHRcdGlmIChhMCA8IHBhTCkge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdMICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhMCA+IHBhUikge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGEwICE9IGEzUHJldikge1xuXHRcdFx0XHRcdGlmIChhM1ByZXYgPCBwYVIgJiYgYSA+IHBhUikge1xuXHRcdFx0XHRcdFx0cGF0aFdpbmRpbmdSICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRvblBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYTNQcmV2ID4gcGFMICYmIGEgPCBwYUwpIHtcblx0XHRcdFx0XHRcdHBhdGhXaW5kaW5nTCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0b25QYXRoID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cXVhbGl0eSA9IDA7XG5cdFx0XHR9XG5cdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRyZXR1cm4gIWRvbnRGbGlwICYmIGEgPiBwYUwgJiYgYSA8IHBhUlxuXHRcdFx0XHRcdCYmIEN1cnZlLmdldFRhbmdlbnQodiwgdClbZGlyID8gJ3gnIDogJ3knXSA9PT0gMFxuXHRcdFx0XHRcdCYmIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgIWRpciwgY2xvc2VkLCB0cnVlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG5cdFx0XHR2YXIgbzAgPSB2W2lvICsgMF0sXG5cdFx0XHRcdG8xID0gdltpbyArIDJdLFxuXHRcdFx0XHRvMiA9IHZbaW8gKyA0XSxcblx0XHRcdFx0bzMgPSB2W2lvICsgNl07XG5cdFx0XHRpZiAocG8gPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSAmJiBwbyA+PSBtaW4obzAsIG8xLCBvMiwgbzMpKSB7XG5cdFx0XHRcdHZhciBhMCA9IHZbaWEgKyAwXSxcblx0XHRcdFx0XHRhMSA9IHZbaWEgKyAyXSxcblx0XHRcdFx0XHRhMiA9IHZbaWEgKyA0XSxcblx0XHRcdFx0XHRhMyA9IHZbaWEgKyA2XSxcblx0XHRcdFx0XHRtb25vQ3VydmVzID0gcGFMID4gbWF4KGEwLCBhMSwgYTIsIGEzKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCBwYVIgPCBtaW4oYTAsIGExLCBhMiwgYTMpXG5cdFx0XHRcdFx0XHRcdD8gW3ZdIDogQ3VydmUuZ2V0TW9ub0N1cnZlcyh2LCBkaXIpLFxuXHRcdFx0XHRcdHJlcztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtb25vQ3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChyZXMgPSBhZGRXaW5kaW5nKG1vbm9DdXJ2ZXNbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdHYgPSBjdXJ2ZS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKCFpIHx8IGN1cnZlc1tpIC0gMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0dlByZXYgPSBudWxsO1xuXHRcdFx0XHRpZiAoIXBhdGguX2Nsb3NlZCkge1xuXHRcdFx0XHRcdHZDbG9zZSA9IEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRcdFx0cGF0aC5nZXRMYXN0Q3VydmUoKS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdFx0XHRjdXJ2ZS5nZXRTZWdtZW50MSgpLFxuXHRcdFx0XHRcdFx0XHRudWxsLCAhY2xvc2VkKTtcblx0XHRcdFx0XHRpZiAodkNsb3NlW2lvXSAhPT0gdkNsb3NlW2lvICsgNl0pIHtcblx0XHRcdFx0XHRcdHZQcmV2ID0gdkNsb3NlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghdlByZXYpIHtcblx0XHRcdFx0XHR2UHJldiA9IHY7XG5cdFx0XHRcdFx0dmFyIHByZXYgPSBwYXRoLmdldExhc3RDdXJ2ZSgpO1xuXHRcdFx0XHRcdHdoaWxlIChwcmV2ICYmIHByZXYgIT09IGN1cnZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgdjIgPSBwcmV2LmdldFZhbHVlcygpO1xuXHRcdFx0XHRcdFx0aWYgKHYyW2lvXSAhPT0gdjJbaW8gKyA2XSkge1xuXHRcdFx0XHRcdFx0XHR2UHJldiA9IHYyO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHByZXYgPSBwcmV2LmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZXMgPSBoYW5kbGVDdXJ2ZSh2KSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0aWYgKGkgKyAxID09PSBsIHx8IGN1cnZlc1tpICsgMV0uX3BhdGggIT09IHBhdGgpIHtcblx0XHRcdFx0aWYgKHZDbG9zZSAmJiAocmVzID0gaGFuZGxlQ3VydmUodkNsb3NlKSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0aWYgKG9uUGF0aCAmJiAhcGF0aFdpbmRpbmdMICYmICFwYXRoV2luZGluZ1IpIHtcblx0XHRcdFx0XHRwYXRoV2luZGluZ0wgPSBwYXRoV2luZGluZ1IgPSBwYXRoLmlzQ2xvY2t3aXNlKGNsb3NlZCkgXiBkaXJcblx0XHRcdFx0XHRcdFx0PyAxIDogLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2luZGluZ0wgKz0gcGF0aFdpbmRpbmdMO1xuXHRcdFx0XHR3aW5kaW5nUiArPSBwYXRoV2luZGluZ1I7XG5cdFx0XHRcdHBhdGhXaW5kaW5nTCA9IHBhdGhXaW5kaW5nUiA9IDA7XG5cdFx0XHRcdGlmIChvblBhdGgpIHtcblx0XHRcdFx0XHRvbkFueVBhdGggPSB0cnVlO1xuXHRcdFx0XHRcdG9uUGF0aCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZDbG9zZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdpbmRpbmdMID0gYWJzKHdpbmRpbmdMKTtcblx0XHR3aW5kaW5nUiA9IGFicyh3aW5kaW5nUik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpbmRpbmc6IG1heCh3aW5kaW5nTCwgd2luZGluZ1IpLFxuXHRcdFx0d2luZGluZ0w6IHdpbmRpbmdMLFxuXHRcdFx0d2luZGluZ1I6IHdpbmRpbmdSLFxuXHRcdFx0cXVhbGl0eTogcXVhbGl0eSxcblx0XHRcdG9uUGF0aDogb25BbnlQYXRoXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgcGF0aDEsIHBhdGgyLCBjdXJ2ZXMsIG9wZXJhdG9yKSB7XG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHRzdGFydCA9IHNlZ21lbnQsXG5cdFx0XHR0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHR3aW5kaW5nO1xuXHRcdGRvIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHNlZ21lbnQuZ2V0Q3VydmUoKSxcblx0XHRcdFx0bGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRjaGFpbi5wdXNoKHsgc2VnbWVudDogc2VnbWVudCwgY3VydmU6IGN1cnZlLCBsZW5ndGg6IGxlbmd0aCB9KTtcblx0XHRcdHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblx0XHRcdHNlZ21lbnQgPSBzZWdtZW50LmdldE5leHQoKTtcblx0XHR9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnQpO1xuXHRcdHZhciBvZmZzZXRzID0gWzAuNSwgMC4yNSwgMC43NV0sXG5cdFx0XHR3aW5kaW5nID0geyB3aW5kaW5nOiAwLCBxdWFsaXR5OiAtMSB9LFxuXHRcdFx0dE1pbiA9IDFlLTgsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAmJiB3aW5kaW5nLnF1YWxpdHkgPCAwLjU7IGkrKykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogb2Zmc2V0c1tpXTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBsID0gY2hhaW4ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IGNoYWluW2pdLFxuXHRcdFx0XHRcdGN1cnZlTGVuZ3RoID0gZW50cnkubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGN1cnZlID0gZW50cnkuY3VydmUsXG5cdFx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBwYXRoLl9wYXJlbnQsXG5cdFx0XHRcdFx0XHRvcGVyYW5kID0gcGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogcGF0aCxcblx0XHRcdFx0XHRcdHQgPSBOdW1lcmljYWwuY2xhbXAoY3VydmUuZ2V0VGltZUF0KGxlbmd0aCksIHRNaW4sIHRNYXgpLFxuXHRcdFx0XHRcdFx0cHQgPSBjdXJ2ZS5nZXRQb2ludEF0VGltZSh0KSxcblx0XHRcdFx0XHRcdGRpciA9IGFicyhjdXJ2ZS5nZXRUYW5nZW50QXRUaW1lKHQpLnkpIDwgTWF0aC5TUVJUMV8yO1xuXHRcdFx0XHRcdHZhciB3aW5kID0gbnVsbDtcblx0XHRcdFx0XHRpZiAob3BlcmF0b3Iuc3VidHJhY3QgJiYgcGF0aDIpIHtcblx0XHRcdFx0XHRcdHZhciBwYXRoV2luZGluZyA9IG9wZXJhbmQgPT09IHBhdGgxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgPyBwYXRoMi5fZ2V0V2luZGluZyhwdCwgZGlyLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgIDogcGF0aDEuX2dldFdpbmRpbmcocHQsIGRpciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAob3BlcmFuZCA9PT0gcGF0aDEgJiYgcGF0aFdpbmRpbmcud2luZGluZyB8fFxuXHRcdFx0XHRcdFx0XHRvcGVyYW5kID09PSBwYXRoMiAmJiAhcGF0aFdpbmRpbmcud2luZGluZykge1xuXHRcdFx0XHRcdFx0XHRpZiAocGF0aFdpbmRpbmcucXVhbGl0eSA8IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kID0geyB3aW5kaW5nOiAwLCBxdWFsaXR5OiAxIH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2luZCA9IHdpbmQgfHwgZ2V0V2luZGluZyhwdCwgY3VydmVzLCBkaXIsIHRydWUpO1xuXHRcdFx0XHRcdGlmICh3aW5kLnF1YWxpdHkgPiB3aW5kaW5nLnF1YWxpdHkpXG5cdFx0XHRcdFx0XHR3aW5kaW5nID0gd2luZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZW5ndGggLT0gY3VydmVMZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0Y2hhaW5bal0uc2VnbWVudC5fd2luZGluZyA9IHdpbmRpbmc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0b3IpIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHN0YXJ0cztcblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWQoc2VnKSB7XG5cdFx0XHR2YXIgd2luZGluZztcblx0XHRcdHJldHVybiAhIShzZWcgJiYgIXNlZy5fdmlzaXRlZCAmJiAoIW9wZXJhdG9yXG5cdFx0XHRcdFx0fHwgb3BlcmF0b3JbKHdpbmRpbmcgPSBzZWcuX3dpbmRpbmcgfHwge30pLndpbmRpbmddXG5cdFx0XHRcdFx0XHQmJiAhKG9wZXJhdG9yLnVuaXRlICYmIHdpbmRpbmcud2luZGluZyA9PT0gMlxuXHRcdFx0XHRcdFx0XHQmJiB3aW5kaW5nLndpbmRpbmdMICYmIHdpbmRpbmcud2luZGluZ1IpKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTdGFydChzZWcpIHtcblx0XHRcdGlmIChzZWcpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHNlZyA9PT0gc3RhcnRzW2ldKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB2aXNpdFBhdGgocGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRzZWdtZW50c1tpXS5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3Jvc3NpbmdTZWdtZW50cyhzZWdtZW50LCBjb2xsZWN0U3RhcnRzKSB7XG5cdFx0XHR2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0ID0gaW50ZXIsXG5cdFx0XHRcdGNyb3NzaW5ncyA9IFtdO1xuXHRcdFx0aWYgKGNvbGxlY3RTdGFydHMpXG5cdFx0XHRcdHN0YXJ0cyA9IFtzZWdtZW50XTtcblxuXHRcdFx0ZnVuY3Rpb24gY29sbGVjdChpbnRlciwgZW5kKSB7XG5cdFx0XHRcdHdoaWxlIChpbnRlciAmJiBpbnRlciAhPT0gZW5kKSB7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gaW50ZXIuX3NlZ21lbnQsXG5cdFx0XHRcdFx0XHRwYXRoID0gb3RoZXIgJiYgb3RoZXIuX3BhdGg7XG5cdFx0XHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0XHRcdHZhciBuZXh0ID0gb3RoZXIuZ2V0TmV4dCgpIHx8IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRcdFx0XHRcdG5leHRJbnRlciA9IG5leHQuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0XHRcdGlmIChvdGhlciAhPT0gc2VnbWVudCAmJiAoaXNTdGFydChvdGhlcilcblx0XHRcdFx0XHRcdFx0fHwgaXNTdGFydChuZXh0KVxuXHRcdFx0XHRcdFx0XHR8fCBuZXh0ICYmIChpc1ZhbGlkKG90aGVyKSAmJiAoaXNWYWxpZChuZXh0KVxuXHRcdFx0XHRcdFx0XHRcdHx8IG5leHRJbnRlciAmJiBpc1ZhbGlkKG5leHRJbnRlci5fc2VnbWVudCkpKSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjcm9zc2luZ3MucHVzaChvdGhlcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY29sbGVjdFN0YXJ0cylcblx0XHRcdFx0XHRcdFx0c3RhcnRzLnB1c2gob3RoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnRlciA9IGludGVyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbnRlcikge1xuXHRcdFx0XHRjb2xsZWN0KGludGVyKTtcblx0XHRcdFx0d2hpbGUgKGludGVyICYmIGludGVyLl9wcmV2KVxuXHRcdFx0XHRcdGludGVyID0gaW50ZXIuX3ByZXY7XG5cdFx0XHRcdGNvbGxlY3QoaW50ZXIsIHN0YXJ0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcm9zc2luZ3M7XG5cdFx0fVxuXG5cdFx0c2VnbWVudHMuc29ydChmdW5jdGlvbihzZWcxLCBzZWcyKSB7XG5cdFx0XHR2YXIgaW50ZXIxID0gc2VnMS5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRpbnRlcjIgPSBzZWcyLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdG92ZXIxID0gISEoaW50ZXIxICYmIGludGVyMS5fb3ZlcmxhcCksXG5cdFx0XHRcdG92ZXIyID0gISEoaW50ZXIyICYmIGludGVyMi5fb3ZlcmxhcCksXG5cdFx0XHRcdHBhdGgxID0gc2VnMS5fcGF0aCxcblx0XHRcdFx0cGF0aDIgPSBzZWcyLl9wYXRoO1xuXHRcdFx0cmV0dXJuIG92ZXIxIF4gb3ZlcjJcblx0XHRcdFx0XHQ/IG92ZXIxID8gMSA6IC0xXG5cdFx0XHRcdFx0OiAhaW50ZXIxIF4gIWludGVyMlxuXHRcdFx0XHRcdFx0PyBpbnRlcjEgPyAxIDogLTFcblx0XHRcdFx0XHRcdDogcGF0aDEgIT09IHBhdGgyXG5cdFx0XHRcdFx0XHRcdD8gcGF0aDEuX2lkIC0gcGF0aDIuX2lkXG5cdFx0XHRcdFx0XHRcdDogc2VnMS5faW5kZXggLSBzZWcyLl9pbmRleDtcblx0XHR9KTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHZhbGlkID0gaXNWYWxpZChzZWcpLFxuXHRcdFx0XHRwYXRoID0gbnVsbCxcblx0XHRcdFx0ZmluaXNoZWQgPSBmYWxzZSxcblx0XHRcdFx0Y2xvc2VkID0gdHJ1ZSxcblx0XHRcdFx0YnJhbmNoZXMgPSBbXSxcblx0XHRcdFx0YnJhbmNoLFxuXHRcdFx0XHR2aXNpdGVkLFxuXHRcdFx0XHRoYW5kbGVJbjtcblx0XHRcdGlmICh2YWxpZCAmJiBzZWcuX3BhdGguX292ZXJsYXBzT25seSkge1xuXHRcdFx0XHR2YXIgcGF0aDEgPSBzZWcuX3BhdGgsXG5cdFx0XHRcdFx0cGF0aDIgPSBzZWcuX2ludGVyc2VjdGlvbi5fc2VnbWVudC5fcGF0aDtcblx0XHRcdFx0aWYgKHBhdGgxLmNvbXBhcmUocGF0aDIpKSB7XG5cdFx0XHRcdFx0aWYgKHBhdGgxLmdldEFyZWEoKSlcblx0XHRcdFx0XHRcdHBhdGhzLnB1c2gocGF0aDEuY2xvbmUoZmFsc2UpKTtcblx0XHRcdFx0XHR2aXNpdFBhdGgocGF0aDEpO1xuXHRcdFx0XHRcdHZpc2l0UGF0aChwYXRoMik7XG5cdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKHZhbGlkKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9ICFwYXRoLFxuXHRcdFx0XHRcdGNyb3NzaW5ncyA9IGdldENyb3NzaW5nU2VnbWVudHMoc2VnLCBmaXJzdCksXG5cdFx0XHRcdFx0b3RoZXIgPSBjcm9zc2luZ3Muc2hpZnQoKSxcblx0XHRcdFx0XHRmaW5pc2hlZCA9ICFmaXJzdCAmJiAoaXNTdGFydChzZWcpIHx8IGlzU3RhcnQob3RoZXIpKSxcblx0XHRcdFx0XHRjcm9zcyA9ICFmaW5pc2hlZCAmJiBvdGhlcjtcblx0XHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdFx0XHRicmFuY2ggPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmaW5pc2hlZCkge1xuXHRcdFx0XHRcdGlmIChzZWcuaXNGaXJzdCgpIHx8IHNlZy5pc0xhc3QoKSlcblx0XHRcdFx0XHRcdGNsb3NlZCA9IHNlZy5fcGF0aC5fY2xvc2VkO1xuXHRcdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNyb3NzICYmIGJyYW5jaCkge1xuXHRcdFx0XHRcdGJyYW5jaGVzLnB1c2goYnJhbmNoKTtcblx0XHRcdFx0XHRicmFuY2ggPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYnJhbmNoKSB7XG5cdFx0XHRcdFx0aWYgKGNyb3NzKVxuXHRcdFx0XHRcdFx0Y3Jvc3NpbmdzLnB1c2goc2VnKTtcblx0XHRcdFx0XHRicmFuY2ggPSB7XG5cdFx0XHRcdFx0XHRzdGFydDogcGF0aC5fc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0Y3Jvc3NpbmdzOiBjcm9zc2luZ3MsXG5cdFx0XHRcdFx0XHR2aXNpdGVkOiB2aXNpdGVkID0gW10sXG5cdFx0XHRcdFx0XHRoYW5kbGVJbjogaGFuZGxlSW5cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjcm9zcylcblx0XHRcdFx0XHRzZWcgPSBvdGhlcjtcblx0XHRcdFx0aWYgKCFpc1ZhbGlkKHNlZykpIHtcblx0XHRcdFx0XHRwYXRoLnJlbW92ZVNlZ21lbnRzKGJyYW5jaC5zdGFydCk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGsgPSB2aXNpdGVkLmxlbmd0aDsgaiA8IGs7IGorKykge1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtqXS5fdmlzaXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2aXNpdGVkLmxlbmd0aCA9IDA7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0c2VnID0gYnJhbmNoICYmIGJyYW5jaC5jcm9zc2luZ3Muc2hpZnQoKTtcblx0XHRcdFx0XHRcdGlmICghc2VnIHx8ICFzZWcuX3BhdGgpIHtcblx0XHRcdFx0XHRcdFx0c2VnID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0YnJhbmNoID0gYnJhbmNoZXMucG9wKCk7XG5cdFx0XHRcdFx0XHRcdGlmIChicmFuY2gpIHtcblx0XHRcdFx0XHRcdFx0XHR2aXNpdGVkID0gYnJhbmNoLnZpc2l0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0aGFuZGxlSW4gPSBicmFuY2guaGFuZGxlSW47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChicmFuY2ggJiYgIWlzVmFsaWQoc2VnKSk7XG5cdFx0XHRcdFx0aWYgKCFzZWcpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbmV4dCA9IHNlZy5nZXROZXh0KCk7XG5cdFx0XHRcdHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGhhbmRsZUluLFxuXHRcdFx0XHRcdFx0bmV4dCAmJiBzZWcuX2hhbmRsZU91dCkpO1xuXHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHR2aXNpdGVkLnB1c2goc2VnKTtcblx0XHRcdFx0c2VnID0gbmV4dCB8fCBzZWcuX3BhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGhhbmRsZUluID0gbmV4dCAmJiBuZXh0Ll9oYW5kbGVJbjtcblx0XHRcdH1cblx0XHRcdGlmIChmaW5pc2hlZCkge1xuXHRcdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdFx0cGF0aC5nZXRGaXJzdFNlZ21lbnQoKS5zZXRIYW5kbGVJbihoYW5kbGVJbik7XG5cdFx0XHRcdFx0cGF0aC5zZXRDbG9zZWQoY2xvc2VkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGF0aC5nZXRBcmVhKCkgIT09IDApIHtcblx0XHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBkaXIsIGNsb3NlZCkge1xuXHRcdFx0cmV0dXJuIGdldFdpbmRpbmcocG9pbnQsIHRoaXMuZ2V0Q3VydmVzKCksIGRpciwgY2xvc2VkKTtcblx0XHR9LFxuXG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0cmFjZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRyYWNlQm9vbGVhbih0aGlzLCBwYXRoLCAnaW50ZXJzZWN0Jywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdzdWJ0cmFjdCcsIG9wdGlvbnMpO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdHJhY2VCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgKG9wdGlvbnMudHJhY2UgPT0gZmFsc2UgfHwgb3B0aW9ucy5zdHJva2UpXG5cdFx0XHRcdFx0PyBzcGxpdEJvb2xlYW4odGhpcywgcGF0aCwgJ2RpdmlkZScpXG5cdFx0XHRcdFx0OiBjcmVhdGVSZXN1bHQoW1xuXHRcdFx0XHRcdFx0dGhpcy5zdWJ0cmFjdChwYXRoLCBvcHRpb25zKSxcblx0XHRcdFx0XHRcdHRoaXMuaW50ZXJzZWN0KHBhdGgsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XSwgdHJ1ZSwgdGhpcywgcGF0aCwgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdHJlc29sdmVDcm9zc2luZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRcdHBhdGhzID0gY2hpbGRyZW4gfHwgW3RoaXNdO1xuXG5cdFx0XHRmdW5jdGlvbiBoYXNPdmVybGFwKHNlZywgcGF0aCkge1xuXHRcdFx0XHR2YXIgaW50ZXIgPSBzZWcgJiYgc2VnLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRcdHJldHVybiBpbnRlciAmJiBpbnRlci5fb3ZlcmxhcCAmJiBpbnRlci5fcGF0aCA9PT0gcGF0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGhhc092ZXJsYXBzID0gZmFsc2UsXG5cdFx0XHRcdGhhc0Nyb3NzaW5ncyA9IGZhbHNlLFxuXHRcdFx0XHRpbnRlcnNlY3Rpb25zID0gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKG51bGwsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVyLmhhc092ZXJsYXAoKSAmJiAoaGFzT3ZlcmxhcHMgPSB0cnVlKSB8fFxuXHRcdFx0XHRcdFx0XHRpbnRlci5pc0Nyb3NzaW5nKCkgJiYgKGhhc0Nyb3NzaW5ncyA9IHRydWUpO1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0Y2xlYXJDdXJ2ZXMgPSBoYXNPdmVybGFwcyAmJiBoYXNDcm9zc2luZ3MgJiYgW107XG5cdFx0XHRpbnRlcnNlY3Rpb25zID0gQ3VydmVMb2NhdGlvbi5leHBhbmQoaW50ZXJzZWN0aW9ucyk7XG5cdFx0XHRpZiAoaGFzT3ZlcmxhcHMpIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBzID0gZGl2aWRlTG9jYXRpb25zKGludGVyc2VjdGlvbnMsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVyLmhhc092ZXJsYXAoKTtcblx0XHRcdFx0fSwgY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gb3ZlcmxhcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHR2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldLFxuXHRcdFx0XHRcdFx0cGF0aCA9IG92ZXJsYXAuX3BhdGgsXG5cdFx0XHRcdFx0XHRzZWcgPSBvdmVybGFwLl9zZWdtZW50LFxuXHRcdFx0XHRcdFx0cHJldiA9IHNlZy5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0bmV4dCA9IHNlZy5nZXROZXh0KCk7XG5cdFx0XHRcdFx0aWYgKGhhc092ZXJsYXAocHJldiwgcGF0aCkgJiYgaGFzT3ZlcmxhcChuZXh0LCBwYXRoKSkge1xuXHRcdFx0XHRcdFx0c2VnLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0cHJldi5faGFuZGxlT3V0Ll9zZXQoMCwgMCk7XG5cdFx0XHRcdFx0XHRuZXh0Ll9oYW5kbGVJbi5fc2V0KDAsIDApO1xuXHRcdFx0XHRcdFx0aWYgKHByZXYgIT09IHNlZyAmJiAhcHJldi5nZXRDdXJ2ZSgpLmhhc0xlbmd0aCgpKSB7XG5cdFx0XHRcdFx0XHRcdG5leHQuX2hhbmRsZUluLnNldChwcmV2Ll9oYW5kbGVJbik7XG5cdFx0XHRcdFx0XHRcdHByZXYucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzQ3Jvc3NpbmdzKSB7XG5cdFx0XHRcdGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zLCBoYXNPdmVybGFwcyAmJiBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRcdHZhciBjdXJ2ZTEgPSBpbnRlci5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdFx0c2VnMSA9IGludGVyLmdldFNlZ21lbnQoKSxcblx0XHRcdFx0XHRcdG90aGVyID0gaW50ZXIuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0XHRcdGN1cnZlMiA9IG90aGVyLl9jdXJ2ZSxcblx0XHRcdFx0XHRcdHNlZzIgPSBvdGhlci5fc2VnbWVudDtcblx0XHRcdFx0XHRpZiAoY3VydmUxICYmIGN1cnZlMiAmJiBjdXJ2ZTEuX3BhdGggJiYgY3VydmUyLl9wYXRoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0aWYgKHNlZzEpXG5cdFx0XHRcdFx0XHRzZWcxLl9pbnRlcnNlY3Rpb24gPSBudWxsO1xuXHRcdFx0XHRcdGlmIChzZWcyKVxuXHRcdFx0XHRcdFx0c2VnMi5faW50ZXJzZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0fSwgY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRpZiAoY2xlYXJDdXJ2ZXMpXG5cdFx0XHRcdFx0Y2xlYXJDdXJ2ZUhhbmRsZXMoY2xlYXJDdXJ2ZXMpO1xuXHRcdFx0XHRwYXRocyA9IHRyYWNlUGF0aHMoQmFzZS5lYWNoKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRcdFx0QmFzZS5wdXNoKHRoaXMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0fSwgW10pKTtcblx0XHRcdH1cblx0XHRcdHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG5cdFx0XHRcdGl0ZW07XG5cdFx0XHRpZiAobGVuZ3RoID4gMSAmJiBjaGlsZHJlbikge1xuXHRcdFx0XHRpZiAocGF0aHMgIT09IGNoaWxkcmVuKVxuXHRcdFx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4ocGF0aHMpO1xuXHRcdFx0XHRpdGVtID0gdGhpcztcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoID09PSAxICYmICFjaGlsZHJlbikge1xuXHRcdFx0XHRpZiAocGF0aHNbMF0gIT09IHRoaXMpXG5cdFx0XHRcdFx0dGhpcy5zZXRTZWdtZW50cyhwYXRoc1swXS5yZW1vdmVTZWdtZW50cygpKTtcblx0XHRcdFx0aXRlbSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWl0ZW0pIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBDb21wb3VuZFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRpdGVtLmFkZENoaWxkcmVuKHBhdGhzKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVkdWNlKCk7XG5cdFx0XHRcdGl0ZW0uY29weUF0dHJpYnV0ZXModGhpcyk7XG5cdFx0XHRcdHRoaXMucmVwbGFjZVdpdGgoaXRlbSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9LFxuXG5cdFx0cmVvcmllbnQ6IGZ1bmN0aW9uKG5vblplcm8sIGNsb2Nrd2lzZSkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2hpbGRyZW4ocmVvcmllbnRQYXRocyh0aGlzLnJlbW92ZUNoaWxkcmVuKCksXG5cdFx0XHRcdFx0XHRmdW5jdGlvbih3KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAhIShub25aZXJvID8gdyA6IHcgJiAxKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjbG9ja3dpc2UpKTtcblx0XHRcdH0gZWxzZSBpZiAoY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9ja3dpc2UoY2xvY2t3aXNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0XHRwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRcdHkgPSBwb2ludC55LFxuXHRcdFx0XHRcdGludGVyY2VwdHMgPSBbXSxcblx0XHRcdFx0XHRyb290cyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdiA9IGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0XHRcdG8wID0gdlsxXSxcblx0XHRcdFx0XHRcdG8xID0gdlszXSxcblx0XHRcdFx0XHRcdG8yID0gdls1XSxcblx0XHRcdFx0XHRcdG8zID0gdls3XTtcblx0XHRcdFx0XHRpZiAoeSA+PSBtaW4obzAsIG8xLCBvMiwgbzMpICYmIHkgPD0gbWF4KG8wLCBvMSwgbzIsIG8zKSkge1xuXHRcdFx0XHRcdFx0dmFyIG1vbm9DdXJ2ZXMgPSBDdXJ2ZS5nZXRNb25vQ3VydmVzKHYpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIG0gPSBtb25vQ3VydmVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbXYgPSBtb25vQ3VydmVzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdG1vMCA9IG12WzFdLFxuXHRcdFx0XHRcdFx0XHRcdG1vMyA9IG12WzddO1xuXHRcdFx0XHRcdFx0XHRpZiAoKG1vMCAhPT0gbW8zKSAmJlxuXHRcdFx0XHRcdFx0XHRcdCh5ID49IG1vMCAmJiB5IDw9IG1vMyB8fCB5ID49IG1vMyAmJiB5IDw9IG1vMCkpe1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4ID0geSA9PT0gbW8wID8gbXZbMF1cblx0XHRcdFx0XHRcdFx0XHRcdDogeSA9PT0gbW8zID8gbXZbNl1cblx0XHRcdFx0XHRcdFx0XHRcdDogQ3VydmUuc29sdmVDdWJpYyhtdiwgMSwgeSwgcm9vdHMsIDAsIDEpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdD09PSAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdD8gQ3VydmUuZ2V0UG9pbnQobXYsIHJvb3RzWzBdKS54XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDogKG12WzBdICsgbXZbNl0pIC8gMjtcblx0XHRcdFx0XHRcdFx0XHRpbnRlcmNlcHRzLnB1c2goeCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGludGVyY2VwdHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGludGVyY2VwdHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cdFx0XHRcdFx0cG9pbnQueCA9IChpbnRlcmNlcHRzWzBdICsgaW50ZXJjZXB0c1sxXSkgLyAyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcG9pbnQ7XG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBQYXRoRmxhdHRlbmVyID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoRmxhdHRlbmVyJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBmbGF0bmVzcywgbWF4UmVjdXJzaW9uLCBpZ25vcmVTdHJhaWdodCwgbWF0cml4KSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdGxlbmd0aCA9IDAsXG5cdFx0XHRtaW5TcGFuID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG5cdFx0XHRzZWdtZW50MjtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcblx0XHRcdGN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCB0MSwgdDIpIHtcblx0XHRcdGlmICgodDIgLSB0MSkgPiBtaW5TcGFuXG5cdFx0XHRcdFx0JiYgIShpZ25vcmVTdHJhaWdodCAmJiBDdXJ2ZS5pc1N0cmFpZ2h0KGN1cnZlKSlcblx0XHRcdFx0XHQmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCBmbGF0bmVzcyB8fCAwLjI1KSkge1xuXHRcdFx0XHR2YXIgaGFsdmVzID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlLCAwLjUpLFxuXHRcdFx0XHRcdHRNaWQgPSAodDEgKyB0MikgLyAyO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoaGFsdmVzWzBdLCBpbmRleCwgdDEsIHRNaWQpO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoaGFsdmVzWzFdLCBpbmRleCwgdE1pZCwgdDIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGR4ID0gY3VydmVbNl0gLSBjdXJ2ZVswXSxcblx0XHRcdFx0XHRkeSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHRcdGlmIChkaXN0ID4gMCkge1xuXHRcdFx0XHRcdGxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0b2Zmc2V0OiBsZW5ndGgsXG5cdFx0XHRcdFx0XHRjdXJ2ZTogY3VydmUsXG5cdFx0XHRcdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRcdFx0XHR0aW1lOiB0Mixcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzZWdtZW50MiA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKTtcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudDI7XG5cdFx0fVxuXHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MiB8fCBzZWdtZW50MSwgc2VnbWVudHNbMF0pO1xuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRfZ2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgcGFydHMgPSB0aGlzLnBhcnRzLFxuXHRcdFx0bGVuZ3RoID0gcGFydHMubGVuZ3RoLFxuXHRcdFx0c3RhcnQsXG5cdFx0XHRpLCBqID0gdGhpcy5pbmRleDtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpID0gajtcblx0XHRcdGlmICghaiB8fCBwYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHBhcnRzW2kgLSAxXSxcblx0XHRcdFx0XHRwcmV2VGltZSA9IHByZXYgJiYgcHJldi5pbmRleCA9PT0gcGFydC5pbmRleCA/IHByZXYudGltZSA6IDAsXG5cdFx0XHRcdFx0cHJldk9mZnNldCA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aW5kZXg6IHBhcnQuaW5kZXgsXG5cdFx0XHRcdFx0dGltZTogcHJldlRpbWUgKyAocGFydC50aW1lIC0gcHJldlRpbWUpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2T2Zmc2V0KSAvIChwYXJ0Lm9mZnNldCAtIHByZXZPZmZzZXQpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRpbmRleDogcGFydHNbbGVuZ3RoIC0gMV0uaW5kZXgsXG5cdFx0XHR0aW1lOiAxXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdHZhciBzdGFydCA9IHRoaXMuX2dldChmcm9tKSxcblx0XHRcdGVuZCA9IHRoaXMuX2dldCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0LmluZGV4LCBsID0gZW5kLmluZGV4OyBpIDw9IGw7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09PSBzdGFydC5pbmRleCA/IHN0YXJ0LnRpbWUgOiAwLFxuXHRcdFx0XHRcdGkgPT09IGVuZC5pbmRleCA/IGVuZC50aW1lIDogMSk7XG5cdFx0XHRpZiAoaSA9PT0gc3RhcnQuaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLl9ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5fZ2V0KG9mZnNldCk7XG5cdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS50aW1lKTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzID0gW10sXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0Y2xvc2VkID0gcGF0aC5fY2xvc2VkO1xuXHRcdGZvciAodmFyIGkgPSAwLCBwcmV2LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludDtcblx0XHRcdGlmICghcHJldiB8fCAhcHJldi5lcXVhbHMocG9pbnQpKSB7XG5cdFx0XHRcdHBvaW50cy5wdXNoKHByZXYgPSBwb2ludC5jbG9uZSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0cG9pbnRzLnVuc2hpZnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cdFx0XHRwb2ludHMucHVzaChwb2ludHNbMV0pO1xuXHRcdH1cblx0XHR0aGlzLmNsb3NlZCA9IGNsb3NlZDtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gbnVsbDtcblx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0c2VnbWVudHMgPSBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV07XG5cdFx0XHRpZiAobGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLmZpdEN1YmljKHNlZ21lbnRzLCBlcnJvciwgMCwgbGVuZ3RoIC0gMSxcblx0XHRcdFx0XHRcdHBvaW50c1sxXS5zdWJ0cmFjdChwb2ludHNbMF0pLFxuXHRcdFx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAodGhpcy5jbG9zZWQpIHtcblx0XHRcdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0XHRcdHNlZ21lbnRzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBzZWdtZW50cztcblx0fSxcblxuXHRmaXRDdWJpYzogZnVuY3Rpb24oc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRpZiAobGFzdCAtIGZpcnN0ID09PSAxKSB7XG5cdFx0XHR2YXIgcHQxID0gcG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gcG9pbnRzW2xhc3RdLFxuXHRcdFx0XHRkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuXHRcdFx0dGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgW3B0MSwgcHQxLmFkZCh0YW4xLm5vcm1hbGl6ZShkaXN0KSksXG5cdFx0XHRcdFx0cHQyLmFkZCh0YW4yLm5vcm1hbGl6ZShkaXN0KSksIHB0Ml0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgdVByaW1lID0gdGhpcy5jaG9yZExlbmd0aFBhcmFtZXRlcml6ZShmaXJzdCwgbGFzdCksXG5cdFx0XHRtYXhFcnJvciA9IE1hdGgubWF4KGVycm9yLCBlcnJvciAqIGVycm9yKSxcblx0XHRcdHNwbGl0LFxuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0cnVlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDQ7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZW5lcmF0ZUJlemllcihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKTtcblx0XHRcdHZhciBtYXggPSB0aGlzLmZpbmRNYXhFcnJvcihmaXJzdCwgbGFzdCwgY3VydmUsIHVQcmltZSk7XG5cdFx0XHRpZiAobWF4LmVycm9yIDwgZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShzZWdtZW50cywgY3VydmUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzcGxpdCA9IG1heC5pbmRleDtcblx0XHRcdGlmIChtYXguZXJyb3IgPj0gbWF4RXJyb3IpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgdGFuQ2VudGVyID0gcG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QocG9pbnRzW3NwbGl0ICsgMV0pO1xuXHRcdHRoaXMuZml0Q3ViaWMoc2VnbWVudHMsIGVycm9yLCBmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzZWdtZW50cywgZXJyb3IsIHNwbGl0LCBsYXN0LCB0YW5DZW50ZXIubmVnYXRlKCksIHRhbjIpO1xuXHR9LFxuXG5cdGFkZEN1cnZlOiBmdW5jdGlvbihzZWdtZW50cywgY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHRcdHByZXYuc2V0SGFuZGxlT3V0KGN1cnZlWzFdLnN1YnRyYWN0KGN1cnZlWzBdKSk7XG5cdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChjdXJ2ZVszXSwgY3VydmVbMl0uc3VidHJhY3QoY3VydmVbM10pKSk7XG5cdH0sXG5cblx0Z2VuZXJhdGVCZXppZXI6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdHB0MSA9IHBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSBwb2ludHNbbGFzdF0sXG5cdFx0XHRDID0gW1swLCAwXSwgWzAsIDBdXSxcblx0XHRcdFggPSBbMCwgMF07XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxhc3QgLSBmaXJzdCArIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciB1ID0gdVByaW1lW2ldLFxuXHRcdFx0XHR0ID0gMSAtIHUsXG5cdFx0XHRcdGIgPSAzICogdSAqIHQsXG5cdFx0XHRcdGIwID0gdCAqIHQgKiB0LFxuXHRcdFx0XHRiMSA9IGIgKiB0LFxuXHRcdFx0XHRiMiA9IGIgKiB1LFxuXHRcdFx0XHRiMyA9IHUgKiB1ICogdSxcblx0XHRcdFx0YTEgPSB0YW4xLm5vcm1hbGl6ZShiMSksXG5cdFx0XHRcdGEyID0gdGFuMi5ub3JtYWxpemUoYjIpLFxuXHRcdFx0XHR0bXAgPSBwb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSxcblx0XHRcdGFscGhhMjtcblx0XHRpZiAoYWJzKGRldEMwQzEpID4gZXBzaWxvbikge1xuXHRcdFx0dmFyIGRldEMwWCA9IENbMF1bMF0gKiBYWzFdICAgIC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMSA9IFhbMF0gICAgKiBDWzFdWzFdIC0gWFsxXSAgICAqIENbMF1bMV07XG5cdFx0XHRhbHBoYTEgPSBkZXRYQzEgLyBkZXRDMEMxO1xuXHRcdFx0YWxwaGEyID0gZGV0QzBYIC8gZGV0QzBDMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGMwID0gQ1swXVswXSArIENbMF1bMV0sXG5cdFx0XHRcdGMxID0gQ1sxXVswXSArIENbMV1bMV07XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBhYnMoYzApID4gZXBzaWxvbiA/IFhbMF0gLyBjMFxuXHRcdFx0XHRcdFx0XHQ6IGFicyhjMSkgPiBlcHNpbG9uID8gWFsxXSAvIGMxXG5cdFx0XHRcdFx0XHRcdDogMDtcblx0XHR9XG5cblx0XHR2YXIgc2VnTGVuZ3RoID0gcHQyLmdldERpc3RhbmNlKHB0MSksXG5cdFx0XHRlcHMgPSBlcHNpbG9uICogc2VnTGVuZ3RoLFxuXHRcdFx0aGFuZGxlMSxcblx0XHRcdGhhbmRsZTI7XG5cdFx0aWYgKGFscGhhMSA8IGVwcyB8fCBhbHBoYTIgPCBlcHMpIHtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaW5lID0gcHQyLnN1YnRyYWN0KHB0MSk7XG5cdFx0XHRoYW5kbGUxID0gdGFuMS5ub3JtYWxpemUoYWxwaGExKTtcblx0XHRcdGhhbmRsZTIgPSB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpO1xuXHRcdFx0aWYgKGhhbmRsZTEuZG90KGxpbmUpIC0gaGFuZGxlMi5kb3QobGluZSkgPiBzZWdMZW5ndGggKiBzZWdMZW5ndGgpIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcblx0XHRcdFx0aGFuZGxlMSA9IGhhbmRsZTIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLFxuXHRcdFx0XHRwdDEuYWRkKGhhbmRsZTEgfHwgdGFuMS5ub3JtYWxpemUoYWxwaGExKSksXG5cdFx0XHRcdHB0Mi5hZGQoaGFuZGxlMiB8fCB0YW4yLm5vcm1hbGl6ZShhbHBoYTIpKSxcblx0XHRcdFx0cHQyXTtcblx0fSxcblxuXHRyZXBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHUsIGN1cnZlKSB7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0OyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdGhpcy5maW5kUm9vdChjdXJ2ZSwgdGhpcy5wb2ludHNbaV0sIHVbaSAtIGZpcnN0XSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gdS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICh1W2ldIDw9IHVbaSAtIDFdKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGZpbmRSb290OiBmdW5jdGlvbihjdXJ2ZSwgcG9pbnQsIHUpIHtcblx0XHR2YXIgY3VydmUxID0gW10sXG5cdFx0XHRjdXJ2ZTIgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAyOyBpKyspIHtcblx0XHRcdGN1cnZlMVtpXSA9IGN1cnZlW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZVtpXSkubXVsdGlwbHkoMyk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDE7IGkrKykge1xuXHRcdFx0Y3VydmUyW2ldID0gY3VydmUxW2kgKyAxXS5zdWJ0cmFjdChjdXJ2ZTFbaV0pLm11bHRpcGx5KDIpO1xuXHRcdH1cblx0XHR2YXIgcHQgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1KSxcblx0XHRcdHB0MSA9IHRoaXMuZXZhbHVhdGUoMiwgY3VydmUxLCB1KSxcblx0XHRcdHB0MiA9IHRoaXMuZXZhbHVhdGUoMSwgY3VydmUyLCB1KSxcblx0XHRcdGRpZmYgPSBwdC5zdWJ0cmFjdChwb2ludCksXG5cdFx0XHRkZiA9IHB0MS5kb3QocHQxKSArIGRpZmYuZG90KHB0Mik7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8oZGYpID8gdSA6IHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKGRlZ3JlZSwgY3VydmUsIHQpIHtcblx0XHR2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG5cdFx0XHRcdHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG1wWzBdO1xuXHR9LFxuXG5cdGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCkge1xuXHRcdHZhciB1ID0gWzBdO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdXG5cdFx0XHRcdFx0KyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcblx0XHRcdHVbaV0gLz0gdVttXTtcblx0XHR9XG5cdFx0cmV0dXJuIHU7XG5cdH0sXG5cblx0ZmluZE1heEVycm9yOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuXHRcdFx0bWF4RGlzdCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuXHRcdFx0dmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuXHRcdFx0dmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcblx0XHRcdHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55O1xuXHRcdFx0aWYgKGRpc3QgPj0gbWF4RGlzdCkge1xuXHRcdFx0XHRtYXhEaXN0ID0gZGlzdDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXJyb3I6IG1heERpc3QsXG5cdFx0XHRpbmRleDogaW5kZXhcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFRleHRJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUZXh0SXRlbScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNPcHRpb25zOiB7IHN0cm9rZTogZmFsc2UsIGhhbmRsZTogZmFsc2UgfSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJyc7XG5cdFx0dGhpcy5fbGluZXMgPSBbXTtcblx0XHR2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0JiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG5cdH0sXG5cblx0Y29weUNvbnRlbnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHRoaXMuc2V0Q29udGVudChzb3VyY2UuX2NvbnRlbnQpO1xuXHR9LFxuXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuXHRcdHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXHRcdHRoaXMuX2NoYW5nZWQoNTIxKTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0Z2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cblx0Z2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbn0pO1xuXG52YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG5cdFx0VGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCwgcGFyYW0sIHZpZXdNYXRyaXgpO1xuXHRcdHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcblx0XHRjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1N0cm9rZSlcblx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihtYXRyaXgsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcblx0XHRcdGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0d2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcblx0XHRcdHggPSAwO1xuXHRcdGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpXG5cdFx0XHR4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMjogMSk7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCkgOiByZWN0O1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0Z3JheTogWydncmF5J10sXG5cdFx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdFx0aHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcblx0XHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdFx0Z3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG5cdH07XG5cblx0dmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcblx0XHRuYW1lZENvbG9ycyA9IHtcblx0XHRcdHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF1cblx0XHR9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKFxuXHRcdFx0XHQvXiMoW1xcZGEtZl17Mn0pKFtcXGRhLWZdezJ9KShbXFxkYS1mXXsyfSkoW1xcZGEtZl17Mn0pPyQvaVxuXHRcdFx0KSB8fCBzdHJpbmcubWF0Y2goXG5cdFx0XHRcdC9eIyhbXFxkYS1mXSkoW1xcZGEtZl0pKFtcXGRhLWZdKShbXFxkYS1mXSk/JC9pXG5cdFx0XHQpLFxuXHRcdFx0dHlwZSA9ICdyZ2InLFxuXHRcdFx0Y29tcG9uZW50cztcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdHZhciBhbW91bnQgPSBtYXRjaFs0XSA/IDQgOiAzO1xuXHRcdFx0Y29tcG9uZW50cyA9IG5ldyBBcnJheShhbW91bnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuXHRcdFx0XHRcdFx0PyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKHJnYnxoc2wpYT9cXCgoLiopXFwpJC8pKSB7XG5cdFx0XHR0eXBlID0gbWF0Y2hbMV07XG5cdFx0XHRjb21wb25lbnRzID0gbWF0Y2hbMl0udHJpbSgpLnNwbGl0KC9bLFxcc10rL2cpO1xuXHRcdFx0dmFyIGlzSFNMID0gdHlwZSA9PT0gJ2hzbCc7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGNvbXBvbmVudHMubGVuZ3RoLCA0KTsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdChjb21wb25lbnQpO1xuXHRcdFx0XHRpZiAoaXNIU0wpIHtcblx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0dmFyIHVuaXQgPSBjb21wb25lbnQubWF0Y2goLyhbYS16XSopJC8pWzFdO1xuXHRcdFx0XHRcdFx0dmFsdWUgKj0gKHtcblx0XHRcdFx0XHRcdFx0dHVybjogMzYwLFxuXHRcdFx0XHRcdFx0XHRyYWQ6IDE4MCAvIE1hdGguUEksXG5cdFx0XHRcdFx0XHRcdGdyYWQ6IDAuOVxuXHRcdFx0XHRcdFx0fVt1bml0XSB8fCAxKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGkgPCAzKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPCAzKSB7XG5cdFx0XHRcdFx0dmFsdWUgLz0gMjU1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXTtcblx0XHRcdGlmICghY29sb3IpIHtcblx0XHRcdFx0aWYgKHdpbmRvdykge1xuXHRcdFx0XHRcdGlmICghY29sb3JDdHgpIHtcblx0XHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRcdGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcblx0XHRcdFx0XHRjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRcdGNvbG9yID0gbmFtZWRDb2xvcnNbc3RyaW5nXSA9IFtcblx0XHRcdFx0XHRcdGRhdGFbMF0gLyAyNTUsXG5cdFx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdFx0ZGF0YVsyXSAvIDI1NVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29sb3IgPSBbMCwgMCwgMF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjb2xvci5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gW3R5cGUsIGNvbXBvbmVudHNdO1xuXHR9XG5cblx0dmFyIGhzYkluZGljZXMgPSBbXG5cdFx0WzAsIDMsIDFdLFxuXHRcdFsyLCAwLCAxXSxcblx0XHRbMSwgMCwgM10sXG5cdFx0WzEsIDIsIDBdLFxuXHRcdFszLCAxLCAwXSxcblx0XHRbMCwgMSwgMl1cblx0XTtcblxuXHR2YXIgY29udmVydGVycyA9IHtcblx0XHQncmdiLWhzYic6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRoID0gZGVsdGEgPT09IDAgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDtcblx0XHRcdHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuXHRcdH0sXG5cblx0XHQnaHNiLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGIpIHtcblx0XHRcdGggPSAoKChoIC8gNjApICUgNikgKyA2KSAlIDY7XG5cdFx0XHR2YXIgaSA9IE1hdGguZmxvb3IoaCksXG5cdFx0XHRcdGYgPSBoIC0gaSxcblx0XHRcdFx0aSA9IGhzYkluZGljZXNbaV0sXG5cdFx0XHRcdHYgPSBbXG5cdFx0XHRcdFx0Yixcblx0XHRcdFx0XHRiICogKDEgLSBzKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogZiksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqICgxIC0gZikpXG5cdFx0XHRcdF07XG5cdFx0XHRyZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuXHRcdH0sXG5cblx0XHQncmdiLWhzbCc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG5cdFx0XHRcdGggPSBhY2hyb21hdGljID8gMFxuXHRcdFx0XHRcdDogICAoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0OiAgICAgICAgICAgIChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsXG5cdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDIsXG5cdFx0XHRcdHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjVcblx0XHRcdFx0XHRcdD8gZGVsdGEgLyAobWF4ICsgbWluKVxuXHRcdFx0XHRcdFx0OiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0XHRcdHJldHVybiBbaCwgcywgbF07XG5cdFx0fSxcblxuXHRcdCdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuXHRcdFx0aCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG5cdFx0XHRpZiAocyA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtsLCBsLCBsXTtcblx0XHRcdHZhciB0M3MgPSBbIGggKyAxIC8gMywgaCwgaCAtIDEgLyAzIF0sXG5cdFx0XHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcblx0XHRcdFx0dDEgPSAyICogbCAtIHQyLFxuXHRcdFx0XHRjID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdDMgPSB0M3NbaV07XG5cdFx0XHRcdGlmICh0MyA8IDApIHQzICs9IDE7XG5cdFx0XHRcdGlmICh0MyA+IDEpIHQzIC09IDE7XG5cdFx0XHRcdGNbaV0gPSA2ICogdDMgPCAxXG5cdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1xuXHRcdFx0XHRcdDogMiAqIHQzIDwgMVxuXHRcdFx0XHRcdFx0PyB0MlxuXHRcdFx0XHRcdFx0OiAzICogdDMgPCAyXG5cdFx0XHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzKSAqIDZcblx0XHRcdFx0XHRcdFx0OiB0MTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHRyZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1yZ2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gW2csIGcsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdFx0Y29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuXHRcdEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuXHRcdFx0XHRwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHQ/IG5hbWUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IEdyYWRpZW50LnJlYWQoXG5cdFx0XHRcdFx0XHRcdFx0QXJyYXkuaXNBcnJheSh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdDogYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogK3ZhbHVlO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cmVhZGluZyA9IHRoaXMuX19yZWFkLFxuXHRcdFx0XHRyZWFkID0gMCxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0Y29tcG9uZW50cyxcblx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdHZhbHVlcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0YXJncyA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1swXTtcblx0XHRcdH1cblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcblx0XHRcdFx0dHlwZSA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1sxXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmc7XG5cdFx0XHRcdFx0YWxwaGEgPSBhcmdzWzJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChyZWFkaW5nKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdFx0YXJncyA9IEJhc2Uuc2xpY2UoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAocmVhZGluZykge1xuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiBsZW5ndGgpXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBCYXNlLnNsaWNlKHZhbHVlcywgMCwgbGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhciBjb252ZXJ0ZWQgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0dHlwZSA9IGNvbnZlcnRlZFswXTtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gY29udmVydGVkWzFdO1xuXHRcdFx0XHRcdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0dHlwZSA9IGFyZy5fdHlwZTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmcuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLl9hbHBoYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwb2ludClcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IEdyYWRpZW50KSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGFyZ3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnaHVlJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0PyAnbGlnaHRuZXNzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdoc2wnXG5cdFx0XHRcdFx0XHRcdFx0OiAnaHNiJ1xuXHRcdFx0XHRcdFx0XHQ6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCAncmFkaWFsJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5JyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdD8gJ2dyYXknXG5cdFx0XHRcdFx0XHRcdFx0XHQ6ICdyZ2InO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRcdFx0cGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV07XG5cdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVhZGluZyAmJiB0eXBlKVxuXHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgJ3JnYic7XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0dmFyIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3RoaXMuX3R5cGVdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlcyAmJiB2YWx1ZXNbaV0pO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0aGlzLl90eXBlXTtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAocmVhZGluZylcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHNldDogJyNpbml0aWFsaXplJyxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcikge1xuXHRcdFx0XHRpZiAodGhpcy5fc2V0dGVyKSB7XG5cdFx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCgxMjkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY29udmVydGVyO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKVxuXHRcdFx0XHRcdDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKVxuXHRcdFx0XHRcdFx0PyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cylcblx0XHRcdFx0XHRcdDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLXJnYiddLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cykpO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIHRoaXMuX2NvbnZlcnQodHlwZSksIHRoaXMuX2FscGhhKTtcblx0XHR9LFxuXG5cdFx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0XHR9LFxuXG5cdFx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR9LFxuXG5cdFx0Z2V0Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2godGhpcy5fYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdFx0fSxcblxuXHRcdGdldEFscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuXHRcdH0sXG5cblx0XHRzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGEgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1pbihNYXRoLm1heChhbHBoYSwgMCksIDEpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH0sXG5cblx0XHRoYXNBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbDtcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0dmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yLCB0cnVlKVxuXHRcdFx0XHRcdD8gQ29sb3IucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdFx0OiBjb2xvcjtcblx0XHRcdHJldHVybiBjb2wgPT09IHRoaXMgfHwgY29sICYmIHRoaXMuX2NsYXNzID09PSBjb2wuX2NsYXNzXG5cdFx0XHRcdFx0JiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlXG5cdFx0XHRcdFx0JiYgdGhpcy5nZXRBbHBoYSgpID09PSBjb2wuZ2V0QWxwaGEoKVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM10sXG5cdFx0XHRcdGludmVyc2UgPSBtYXRyaXggJiYgbWF0cml4LmludmVydGVkKCksXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGludmVyc2UpIHtcblx0XHRcdFx0b3JpZ2luID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQob3JpZ2luKTtcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBpbnZlcnNlLl90cmFuc2Zvcm1Qb2ludChkZXN0aW5hdGlvbik7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gaW52ZXJzZS5fdHJhbnNmb3JtUG9pbnQoaGlnaGxpZ2h0KTtcblx0XHRcdH1cblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IGhpZ2hsaWdodC5zdWJ0cmFjdChvcmlnaW4pO1xuXHRcdFx0XHRcdGlmICh2ZWN0b3IuZ2V0TGVuZ3RoKCkgPiByYWRpdXMpXG5cdFx0XHRcdFx0XHRoaWdobGlnaHQgPSBvcmlnaW4uYWRkKHZlY3Rvci5ub3JtYWxpemUocmFkaXVzIC0gMC4xKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSxcblx0XHRcdFx0XHRcdDAsIG9yaWdpbi54LCBvcmlnaW4ueSwgcmFkaXVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG9yaWdpbi54LCBvcmlnaW4ueSxcblx0XHRcdFx0XHRcdGRlc3RpbmF0aW9uLngsIGRlc3RpbmF0aW9uLnkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRvZmZzZXQgPSBzdG9wLl9vZmZzZXQ7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChcblx0XHRcdFx0XHRcdG9mZnNldCA9PSBudWxsID8gaSAvIChsIC0gMSkgOiBvZmZzZXQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH0sXG5cblx0XHRcdF9zZXRPd25lcjogZnVuY3Rpb24oY29sb3IsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0aWYgKGNvbG9yLl9vd25lciAmJiBvd25lciAmJiBjb2xvci5fb3duZXIgIT09IG93bmVyKSB7XG5cdFx0XHRcdFx0XHRjb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghY29sb3IuX293bmVyIF4gIW93bmVyKSB7XG5cdFx0XHRcdFx0XHRjb2xvci5fb3duZXIgPSBvd25lciB8fCBudWxsO1xuXHRcdFx0XHRcdFx0Y29sb3IuX3NldHRlciA9IHNldHRlciB8fCBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29sb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0YWRkOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSArIGI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAqIGI7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLyBiO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKG9wZXJhdG9ycywgZnVuY3Rpb24ob3BlcmF0b3IsIG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzMSA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29tcG9uZW50czJbaV0gPSBvcGVyYXRvcihjb21wb25lbnRzMVtpXSwgY29tcG9uZW50czJbaV0pO1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzMixcblx0XHRcdFx0XHR0aGlzLl9hbHBoYSAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gb3BlcmF0b3IodGhpcy5fYWxwaGEsIGNvbG9yLmdldEFscGhhKCkpXG5cdFx0XHRcdFx0XHRcdDogbnVsbCk7XG5cdFx0fTtcblx0fSwge1xuXHR9KTtcbn0pO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0aWYgKHN0b3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChzdG9wcykpIHtcblx0XHRcdHRoaXMuc2V0KHN0b3BzKTtcblx0XHRcdHN0b3BzID0gcmFkaWFsID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3N0b3BzID09IG51bGwpIHtcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAoIXRoaXMuX293bmVycy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdG9wcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgR3JhZGllbnQoc3RvcHMsIHRoaXMuX3JhZGlhbCk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAoc3RvcHMubGVuZ3RoIDwgMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0fVxuXHRcdHZhciBfc3RvcHMgPSB0aGlzLl9zdG9wcztcblx0XHRpZiAoX3N0b3BzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IF9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdF9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdF9zdG9wcyA9IHRoaXMuX3N0b3BzID0gR3JhZGllbnRTdG9wLnJlYWRMaXN0KHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdF9zdG9wc1tpXS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzcykge1xuXHRcdFx0dmFyIHN0b3BzMSA9IHRoaXMuX3N0b3BzLFxuXHRcdFx0XHRzdG9wczIgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdGxlbmd0aCA9IHN0b3BzMS5sZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoID09PSBzdG9wczIubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIXN0b3BzMVtpXS5lcXVhbHMoc3RvcHMyW2ldKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxudmFyIEdyYWRpZW50U3RvcCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnRTdG9wJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudFN0b3AoYXJnMCwgYXJnMSkge1xuXHRcdHZhciBjb2xvciA9IGFyZzAsXG5cdFx0XHRvZmZzZXQgPSBhcmcxO1xuXHRcdGlmICh0eXBlb2YgYXJnMCA9PT0gJ29iamVjdCcgJiYgYXJnMSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSAmJiB0eXBlb2YgYXJnMFswXSAhPT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRvZmZzZXQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmICgnY29sb3InIGluIGFyZzAgfHwgJ29mZnNldCcgaW4gYXJnMFxuXHRcdFx0XHRcdHx8ICdyYW1wUG9pbnQnIGluIGFyZzApIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwLmNvbG9yO1xuXHRcdFx0XHRvZmZzZXQgPSBhcmcwLm9mZnNldCB8fCBhcmcwLnJhbXBQb2ludCB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHR0aGlzLnNldE9mZnNldChvZmZzZXQpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9vZmZzZXQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgY29sb3IgPSB0aGlzLl9jb2xvcixcblx0XHRcdG9mZnNldCA9IHRoaXMuX29mZnNldDtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUob2Zmc2V0ID09IG51bGwgPyBbY29sb3JdIDogW2NvbG9yLCBvZmZzZXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoMTI5KTtcblx0fSxcblxuXHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9vZmZzZXQ7XG5cdH0sXG5cblx0c2V0T2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogJyNnZXRPZmZzZXQnLFxuXHRzZXRSYW1wUG9pbnQ6ICcjc2V0T2Zmc2V0JyxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRDb2xvci5fc2V0T3duZXIodGhpcy5fY29sb3IsIG51bGwpO1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IuX3NldE93bmVyKENvbG9yLnJlYWQoYXJndW1lbnRzLCAwKSwgdGhpcyxcblx0XHRcdFx0J3NldENvbG9yJyk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3RvcCkge1xuXHRcdHJldHVybiBzdG9wID09PSB0aGlzIHx8IHN0b3AgJiYgdGhpcy5fY2xhc3MgPT09IHN0b3AuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX2NvbG9yLmVxdWFscyhzdG9wLl9jb2xvcilcblx0XHRcdFx0JiYgdGhpcy5fb2Zmc2V0ID09IHN0b3AuX29mZnNldFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBTdHlsZSA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGl0ZW1EZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IG51bGwsXG5cdFx0ZmlsbFJ1bGU6ICdub256ZXJvJyxcblx0XHRzdHJva2VDb2xvcjogbnVsbCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHNoYWRvd0NvbG9yOiBudWxsLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiBudWxsXG5cdH0sXG5cdGdyb3VwRGVmYXVsdHMgPSBCYXNlLnNldCh7fSwgaXRlbURlZmF1bHRzLCB7XG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRsZWFkaW5nOiBudWxsLFxuXHRcdGp1c3RpZmljYXRpb246ICdsZWZ0J1xuXHR9KSxcblx0dGV4dERlZmF1bHRzID0gQmFzZS5zZXQoe30sIGdyb3VwRGVmYXVsdHMsIHtcblx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdH0pLFxuXHRmbGFncyA9IHtcblx0XHRzdHJva2VXaWR0aDogMTkzLFxuXHRcdHN0cm9rZUNhcDogMTkzLFxuXHRcdHN0cm9rZUpvaW46IDE5Myxcblx0XHRzdHJva2VTY2FsaW5nOiAyMDEsXG5cdFx0bWl0ZXJMaW1pdDogMTkzLFxuXHRcdGZvbnRGYW1pbHk6IDksXG5cdFx0Zm9udFdlaWdodDogOSxcblx0XHRmb250U2l6ZTogOSxcblx0XHRmb250OiA5LFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9LFxuXHRpdGVtID0ge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH0sXG5cdGZpZWxkcyA9IHtcblx0XHRfY2xhc3M6ICdTdHlsZScsXG5cdFx0YmVhbnM6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuXHRcdFx0dGhpcy5fdmFsdWVzID0ge307XG5cdFx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHRcdHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0XG5cdFx0XHRcdFx0fHwgcGFwZXIucHJvamVjdDtcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gIV9vd25lciB8fCBfb3duZXIgaW5zdGFuY2VvZiBHcm91cCA/IGdyb3VwRGVmYXVsdHNcblx0XHRcdFx0XHQ6IF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtID8gdGV4dERlZmF1bHRzXG5cdFx0XHRcdFx0OiBpdGVtRGVmYXVsdHM7XG5cdFx0XHRpZiAoc3R5bGUpXG5cdFx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0XHR9XG5cdH07XG5cblx0QmFzZS5lYWNoKGdyb3VwRGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKTtcblx0XHRcdGlmIChhcHBseVRvQ2hpbGRyZW4pIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0Y2hpbGRyZW5baV0uX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKChrZXkgPT09ICdzZWxlY3RlZENvbG9yJyB8fCAhYXBwbHlUb0NoaWxkcmVuKVxuXHRcdFx0XHRcdCYmIGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdGlmIChvbGQpIHtcblx0XHRcdFx0XHRcdFx0Q29sb3IuX3NldE93bmVyKG9sZCwgbnVsbCk7XG5cdFx0XHRcdFx0XHRcdG9sZC5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHRhcHBseVRvQ2hpbGRyZW4gJiYgc2V0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAob3duZXIpXG5cdFx0XHRcdFx0XHRvd25lci5fY2hhbmdlZChmbGFnIHx8IDEyOSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZmllbGRzW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdGFwcGx5VG9DaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSxcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRpZiAoYXBwbHlUb0NoaWxkcmVuICYmICFfZG9udE1lcmdlKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRcdGlmICghaSkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBjaGlsZFZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoa2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGN0b3IgPSBpc0NvbG9yID8gQ29sb3IgOiBpc1BvaW50ID8gUG9pbnQgOiBudWxsO1xuXHRcdFx0XHRcdGlmIChjdG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IGN0b3IpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlID0gY3Rvci5yZWFkKFt2YWx1ZV0sIDAsXG5cdFx0XHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSwgY2xvbmU6IHRydWUgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgJiYgaXNDb2xvcikge1xuXHRcdFx0XHR2YWx1ZSA9IENvbG9yLl9zZXRPd25lcih2YWx1ZSwgb3duZXIsIGFwcGx5VG9DaGlsZHJlbiAmJiBzZXQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEJhc2UuZWFjaCh7XG5cdFx0Rm9udDogJ0ZvbnRGYW1pbHknLFxuXHRcdFdpbmRpbmdSdWxlOiAnRmlsbFJ1bGUnXG5cdH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgZ2V0ID0gJ2dldCcgKyBrZXksXG5cdFx0XHRzZXQgPSAnc2V0JyArIGtleTtcblx0XHRmaWVsZHNbZ2V0XSA9IGl0ZW1bZ2V0XSA9ICcjZ2V0JyArIHZhbHVlO1xuXHRcdGZpZWxkc1tzZXRdID0gaXRlbVtzZXRdID0gJyNzZXQnICsgdmFsdWU7XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRmdW5jdGlvbiBjb21wYXJlKHN0eWxlMSwgc3R5bGUyLCBzZWNvbmRhcnkpIHtcblx0XHRcdHZhciB2YWx1ZXMxID0gc3R5bGUxLl92YWx1ZXMsXG5cdFx0XHRcdHZhbHVlczIgPSBzdHlsZTIuX3ZhbHVlcyxcblx0XHRcdFx0ZGVmYXVsdHMyID0gc3R5bGUyLl9kZWZhdWx0cztcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMxKSB7XG5cdFx0XHRcdHZhciB2YWx1ZTEgPSB2YWx1ZXMxW2tleV0sXG5cdFx0XHRcdFx0dmFsdWUyID0gdmFsdWVzMltrZXldO1xuXHRcdFx0XHRpZiAoIShzZWNvbmRhcnkgJiYga2V5IGluIHZhbHVlczIpICYmICFCYXNlLmVxdWFscyh2YWx1ZTEsXG5cdFx0XHRcdFx0XHR2YWx1ZTIgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzMltrZXldIDogdmFsdWUyKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBjb21wYXJlKHRoaXMsIHN0eWxlKVxuXHRcdFx0XHQmJiBjb21wYXJlKHN0eWxlLCB0aGlzLCB0cnVlKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZGlzcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvbG9yO1xuXHRcdGNvbG9yID0gdGhpcy5nZXRGaWxsQ29sb3IoKTtcblx0XHRpZiAoY29sb3IpIGNvbG9yLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0Y29sb3IgPSB0aGlzLmdldFN0cm9rZUNvbG9yKCk7XG5cdFx0aWYgKGNvbG9yKSBjb2xvci5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdGNvbG9yID0gdGhpcy5nZXRTaGFkb3dDb2xvcigpO1xuXHRcdGlmIChjb2xvcikgY29sb3IuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sb3IgPSB0aGlzLmdldEZpbGxDb2xvcigpO1xuXHRcdHJldHVybiAhIWNvbG9yICYmIGNvbG9yLmFscGhhID4gMDtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U3Ryb2tlQ29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRyZXR1cm4gISFjb2xvciAmJiBjb2xvci5hbHBoYSA+IDAgJiYgKHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMFxuXHRcdFx0XHR8fCAhdGhpcy5nZXRTaGFkb3dPZmZzZXQoKS5pc1plcm8oKSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblx0XHRcdGlmICghdmlld3BvcnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcblx0XHRcdFx0dmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuXHRcdH0sXG5cblx0XHRnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG5cdFx0fSxcblxuXHRcdGlzSW52aXNpYmxlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcblx0XHR9LFxuXG5cdFx0aXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG5cdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsICYmIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGlmIChlbCkge1xuXHRcdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gcGFydHNbaV07XG5cdFx0XHRcdFx0dmFyIG9wdGlvbnMgPSAoXG5cdFx0XHRcdFx0XHRlbCA9PT0gZG9jdW1lbnRcblx0XHRcdFx0XHRcdCYmIChuYW1lID09PSAndG91Y2hzdGFydCcgfHwgbmFtZSA9PT0gJ3RvdWNobW92ZScpXG5cdFx0XHRcdFx0KSA/IHsgcGFzc2l2ZTogZmFsc2UgfSA6IGZhbHNlO1xuXHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuYywgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0aWYgKGVsKSB7XG5cdFx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG5hdGl2ZVJlcXVlc3QgPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuXHRcdHJlcXVlc3RlZCA9IGZhbHNlLFxuXHRcdGNhbGxiYWNrcyA9IFtdLFxuXHRcdHRpbWVyO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHR2YXIgZnVuY3Rpb25zID0gY2FsbGJhY2tzO1xuXHRcdGNhbGxiYWNrcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gZnVuY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGZ1bmN0aW9uc1tpXSgpO1xuXHRcdHJlcXVlc3RlZCA9IG5hdGl2ZVJlcXVlc3QgJiYgY2FsbGJhY2tzLmxlbmd0aDtcblx0XHRpZiAocmVxdWVzdGVkKVxuXHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoIXJlcXVlc3RlZCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHRcdHJlcXVlc3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghdGltZXIpIHtcblx0XHRcdHRpbWVyID0gc2V0SW50ZXJ2YWwoaGFuZGxlQ2FsbGJhY2tzLCAxMDAwIC8gNjApO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBWaWV3ID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBWaWV3KHByb2plY3QsIGVsZW1lbnQpIHtcblxuXHRcdGZ1bmN0aW9uIGdldFNpemUobmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRbbmFtZV0gfHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuXHRcdFx0dmFyIHNpemUgPSBEb21FbGVtZW50LmdldFNpemUoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gc2l6ZS5pc05hTigpIHx8IHNpemUuaXNaZXJvKClcblx0XHRcdFx0XHQ/IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKVxuXHRcdFx0XHRcdDogc2l6ZTtcblx0XHR9XG5cblx0XHR2YXIgc2l6ZTtcblx0XHRpZiAod2luZG93ICYmIGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5faWQgPSAndmlldy0nICsgVmlldy5faWQrKyk7XG5cdFx0XHREb21FdmVudC5hZGQoZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHRcdERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0XHR1c2VyRHJhZzogbm9uZSxcblx0XHRcdFx0dXNlclNlbGVjdDogbm9uZSxcblx0XHRcdFx0dG91Y2hDYWxsb3V0OiBub25lLFxuXHRcdFx0XHRjb250ZW50Wm9vbWluZzogbm9uZSxcblx0XHRcdFx0dGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG5cdFx0XHRcdFx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoYXQuc2V0Vmlld1NpemUoZ2V0Q2FudmFzU2l6ZSgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRzaXplID0gZ2V0Q2FudmFzU2l6ZSgpO1xuXG5cdFx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0YXRzJylcblx0XHRcdFx0XHQmJiB0eXBlb2YgU3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHRcdHZhciBzdGF0cyA9IHRoaXMuX3N0YXRzLmRvbUVsZW1lbnQsXG5cdFx0XHRcdFx0c3R5bGUgPSBzdGF0cy5zdHlsZSxcblx0XHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHRzdHlsZS5sZWZ0ID0gb2Zmc2V0LnggKyAncHgnO1xuXHRcdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZWxlbWVudCk7XG5cdFx0XHRlbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0dGhpcy5fc2NvcGUgPSBwcm9qZWN0Ll9zY29wZTtcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblx0XHRpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdCh0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCkpLl9vd25lciA9IHRoaXM7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRoaXM7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX2ZyYW1lSXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl9pdGVtRXZlbnRzID0geyBuYXRpdmU6IHt9LCB2aXJ0dWFsOiB7fSB9O1xuXHRcdHRoaXMuX2F1dG9VcGRhdGUgPSAhcGFwZXIuYWdlbnQubm9kZTtcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAocHJvamVjdC5fdmlldyA9PT0gdGhpcylcblx0XHRcdHByb2plY3QuX3ZpZXcgPSBudWxsO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHREb21FdmVudC5yZW1vdmUod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLm9mZignZnJhbWUnKTtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9ldmVudHM6IEJhc2UuZWFjaChcblx0XHRJdGVtLl9pdGVtSGFuZGxlcnMuY29uY2F0KFsnb25SZXNpemUnLCAnb25LZXlEb3duJywgJ29uS2V5VXAnXSksXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHt9O1xuXHRcdH0sIHtcblx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdCksXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdGdldEF1dG9VcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuXHR9LFxuXG5cdHNldEF1dG9VcGRhdGU6IGZ1bmN0aW9uKGF1dG9VcGRhdGUpIHtcblx0XHR0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZTtcblx0XHRpZiAoYXV0b1VwZGF0ZSlcblx0XHRcdHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRyZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZCkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0RG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHRoYXQuX2FuaW1hdGUpIHtcblx0XHRcdFx0XHR0aGF0LnJlcXVlc3RVcGRhdGUoKTtcblx0XHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoYXQuX2VsZW1lbnQ7XG5cdFx0XHRcdFx0aWYgKCghRG9tRWxlbWVudC5nZXRQcmVmaXhlZChkb2N1bWVudCwgJ2hpZGRlbicpXG5cdFx0XHRcdFx0XHRcdHx8IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsZW1lbnQsICdrZWVwYWxpdmUnKVxuXHRcdFx0XHRcdFx0XHRcdD09PSAndHJ1ZScpICYmIERvbUVsZW1lbnQuaXNJblZpZXcoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRcdHRoYXQuX2hhbmRsZUZyYW1lKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGF0Ll9hdXRvVXBkYXRlKVxuXHRcdFx0XHRcdHRoYXQudXBkYXRlKCk7XG5cdFx0XHR9KTtcblx0XHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdHBsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2FuaW1hdGUgPSB0cnVlO1xuXHRcdHRoaXMucmVxdWVzdFVwZGF0ZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fbGFzdCA/IG5vdyAtIHRoaXMuX2xhc3QgOiAwO1xuXHRcdHRoaXMuX2xhc3QgPSBub3c7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9jaGFuZ2VkKDQwOTcpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX2RlY29tcG9zZWQgPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxSYXRpbzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gKiA3Mjtcblx0fSxcblxuXHRnZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRWaWV3U2l6ZScpO1xuXHR9LFxuXG5cdHNldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0ZGVsdGEgPSBzaXplLnN1YnRyYWN0KHRoaXMuX3ZpZXdTaXplKTtcblx0XHRpZiAoZGVsdGEuaXNaZXJvKCkpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0RWxlbWVudFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0dGhpcy5lbWl0KCdyZXNpemUnLCB7IHNpemU6IHNpemUsIGRlbHRhOiBkZWx0YSB9KTtcblx0XHRpZiAodGhpcy5fYXV0b1VwZGF0ZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3NldEVsZW1lbnRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRpZiAoZWxlbWVudC53aWR0aCAhPT0gd2lkdGgpXG5cdFx0XHRcdGVsZW1lbnQud2lkdGggPSB3aWR0aDtcblx0XHRcdGlmIChlbGVtZW50LmhlaWdodCAhPT0gaGVpZ2h0KVxuXHRcdFx0XHRlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG5cdFx0XHRcdFx0bmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5zZXJ0ZWQodGhpcy5fZWxlbWVudCk7XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0cGl4ZWxzO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuXHRcdFx0XHR0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHR0ZW1wLnN0eWxlLmZvbnRTaXplID0gc2l6ZTtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZCh0ZW1wKTtcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQoRG9tRWxlbWVudC5nZXRTdHlsZXModGVtcCkuZm9udFNpemUpO1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHRlbXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KHBpeGVscyk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbHM7XG5cdH0sXG5cblx0Z2V0VGV4dFdpZHRoOiBmdW5jdGlvbihmb250LCBsaW5lcykge1xuXHRcdHJldHVybiAwO1xuXHR9XG59LCBCYXNlLmVhY2goWydyb3RhdGUnLCAnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbihrZXkpIHtcblx0dmFyIHJvdGF0ZSA9IGtleSA9PT0gJ3JvdGF0ZSc7XG5cdHRoaXNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWx1ZSA9IChyb3RhdGUgPyBCYXNlIDogUG9pbnQpLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClba2V5XSh2YWx1ZSxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyKHRydWUpKSk7XG5cdH07XG59LCB7XG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkIHx8ICh0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpKTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZSh0aGlzLmdldENlbnRlcigpLnN1YnRyYWN0KGNlbnRlcikpO1xuXHR9LFxuXG5cdGdldFpvb206IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsaW5nID0gdGhpcy5fZGVjb21wb3NlKCkuc2NhbGluZztcblx0XHRyZXR1cm4gKHNjYWxpbmcueCArIHNjYWxpbmcueSkgLyAyO1xuXHR9LFxuXG5cdHNldFpvb206IGZ1bmN0aW9uKHpvb20pIHtcblx0XHR0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuZ2V0Wm9vbSgpLFxuXHRcdFx0dGhpcy5nZXRDZW50ZXIoKSkpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVjb21wb3NlKCkucm90YXRpb247XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGluZyA9IHRoaXMuX2RlY29tcG9zZSgpLnNjYWxpbmc7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpLFxuXHRcdFx0c2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY3VycmVudCAmJiBzY2FsaW5nKSB7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeDtcblx0XHRtYXRyaXguaW5pdGlhbGl6ZS5hcHBseShtYXRyaXgsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguYXBwZW5kKG1hdHJpeCk7XG5cdH0sXG5cblx0c2Nyb2xsQnk6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5uZWdhdGUoKSk7XG5cdH1cbn0pLCB7XG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0RXZlbnRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gdGhpcy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdGhpcy5fZWxlbWVudCkpO1xuXHR9LFxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKGRvY3VtZW50ICYmIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0dmFyIGN0b3IgPSB3aW5kb3cgPyBDYW52YXNWaWV3IDogVmlldztcblx0XHRcdHJldHVybiBuZXcgY3Rvcihwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGlmICghd2luZG93KVxuXHRcdHJldHVybjtcblx0dmFyIHByZXZGb2N1cyxcblx0XHR0ZW1wRm9jdXMsXG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZSxcblx0XHRtb3VzZURvd24gPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBnZXRWaWV3KGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldCA9IERvbUV2ZW50LmdldFRhcmdldChldmVudCk7XG5cdFx0cmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgVmlldy5fdmlld3NCeUlkW1xuXHRcdFx0XHR0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIXZpZXcgfHwgIXZpZXcuaXNWaXNpYmxlKCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gVmlldy5fdmlld3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICgodmlldyA9IFZpZXcuX3ZpZXdzW2ldKS5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCBwb2ludCkge1xuXHRcdHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCk7XG5cdH1cblxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0XHRtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcblx0aWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuXHRcdG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcblx0XHRtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG5cdFx0bW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuXHR9IGVsc2Uge1xuXHRcdG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0Jztcblx0XHRtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcblx0XHRtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblx0XHRpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcblx0XHRcdFx0L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuXHRcdFx0bW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcblx0XHRcdG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG5cdFx0XHRtb3VzZXVwICs9ICcgbW91c2V1cCc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHZpZXdFdmVudHMgPSB7fSxcblx0XHRkb2NFdmVudHMgPSB7XG5cdFx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0XHRcdHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXHRcdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpIHtcblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB2aWV3Ll9lbGVtZW50KSxcblx0XHRcdFx0XHRcdHggPSBvZmZzZXQueCxcblx0XHRcdFx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRcdFx0YXggPSBhYnMoeCksXG5cdFx0XHRcdFx0XHRtYXggPSAxIDw8IDI1LFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGF4IC0gbWF4O1xuXHRcdFx0XHRcdG9mZnNldC54ID0gYWJzKGRpZmYpIDwgYXggPyBkaWZmICogKHggPCAwID8gLTEgOiAxKSA6IHg7XG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIGV2ZW50LCB2aWV3LnZpZXdUb1Byb2plY3Qob2Zmc2V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdHNjcm9sbDogdXBkYXRlRm9jdXNcblx0XHR9O1xuXG5cdHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCk7XG5cdFx0aWYgKCFkcmFnZ2luZykge1xuXHRcdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdFx0dmlldy5faGFuZGxlTW91c2VFdmVudCgnbW91c2Vkb3duJywgZXZlbnQpO1xuXHRcdH1cblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2Vtb3ZlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghbW91c2VEb3duKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0XHRpZiAodmlldylcblx0XHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCk7XG5cdFx0XHRcdFx0aWYgKCFwcmV2Rm9jdXMpXG5cdFx0XHRcdFx0XHRwcmV2Rm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHRlbXBGb2N1cyAmJiB0ZW1wRm9jdXMgPT09IHZpZXcpIHtcblx0XHRcdFx0aWYgKHByZXZGb2N1cyAmJiAhcHJldkZvY3VzLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0XHRwcmV2Rm9jdXMgPSBudWxsO1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcblx0XHRcdFx0cHJldkZvY3VzID0gbnVsbDtcblx0XHRcdFx0dXBkYXRlRm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZpZXcpXG5cdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQpO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oKSB7XG5cdFx0bW91c2VEb3duID0gdHJ1ZTtcblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2V1cF0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAodmlldyAmJiBkcmFnZ2luZylcblx0XHRcdHZpZXcuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdXNldXAnLCBldmVudCk7XG5cdFx0bW91c2VEb3duID0gZHJhZ2dpbmcgPSBmYWxzZTtcblx0fTtcblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGxvYWQ6IHVwZGF0ZUZvY3VzXG5cdH0pO1xuXG5cdHZhciBjYWxsZWQgPSBmYWxzZSxcblx0XHRwcmV2ZW50ZWQgPSBmYWxzZSxcblx0XHRmYWxsYmFja3MgPSB7XG5cdFx0XHRkb3VibGVjbGljazogJ2NsaWNrJyxcblx0XHRcdG1vdXNlZHJhZzogJ21vdXNlbW92ZSdcblx0XHR9LFxuXHRcdHdhc0luVmlldyA9IGZhbHNlLFxuXHRcdG92ZXJWaWV3LFxuXHRcdGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0ZG93bkl0ZW0sXG5cdFx0b3Zlckl0ZW0sXG5cdFx0ZHJhZ0l0ZW0sXG5cdFx0Y2xpY2tJdGVtLFxuXHRcdGNsaWNrVGltZSxcblx0XHRkYmxDbGljaztcblxuXHRmdW5jdGlvbiBlbWl0TW91c2VFdmVudChvYmosIHRhcmdldCwgdHlwZSwgZXZlbnQsIHBvaW50LCBwcmV2UG9pbnQsXG5cdFx0XHRzdG9wSXRlbSkge1xuXHRcdHZhciBzdG9wcGVkID0gZmFsc2UsXG5cdFx0XHRtb3VzZUV2ZW50O1xuXG5cdFx0ZnVuY3Rpb24gZW1pdChvYmosIHR5cGUpIHtcblx0XHRcdGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0aWYgKCFtb3VzZUV2ZW50KSB7XG5cdFx0XHRcdFx0bW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0dGFyZ2V0IHx8IG9iaixcblx0XHRcdFx0XHRcdFx0cHJldlBvaW50ID8gcG9pbnQuc3VidHJhY3QocHJldlBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSkge1xuXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0aWYgKG1vdXNlRXZlbnQucHJldmVudGVkKVxuXHRcdFx0XHRcdFx0cHJldmVudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRpZiAobW91c2VFdmVudC5zdG9wcGVkKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbdHlwZV07XG5cdFx0XHRcdGlmIChmYWxsYmFjaylcblx0XHRcdFx0XHRyZXR1cm4gZW1pdChvYmosIGZhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAob2JqICYmIG9iaiAhPT0gc3RvcEl0ZW0pIHtcblx0XHRcdGlmIChlbWl0KG9iaiwgdHlwZSkpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0b2JqID0gb2JqLl9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBzdG9wcGVkO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW1pdE1vdXNlRXZlbnRzKHZpZXcsIGhpdEl0ZW0sIHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50KSB7XG5cdFx0dmlldy5fcHJvamVjdC5yZW1vdmVPbih0eXBlKTtcblx0XHRwcmV2ZW50ZWQgPSBjYWxsZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gKGRyYWdJdGVtICYmIGVtaXRNb3VzZUV2ZW50KGRyYWdJdGVtLCBudWxsLCB0eXBlLCBldmVudCxcblx0XHRcdFx0XHRwb2ludCwgcHJldlBvaW50KVxuXHRcdFx0fHwgaGl0SXRlbSAmJiBoaXRJdGVtICE9PSBkcmFnSXRlbVxuXHRcdFx0XHQmJiAhaGl0SXRlbS5pc0Rlc2NlbmRhbnQoZHJhZ0l0ZW0pXG5cdFx0XHRcdCYmIGVtaXRNb3VzZUV2ZW50KGhpdEl0ZW0sIG51bGwsIHR5cGUgPT09ICdtb3VzZWRyYWcnID9cblx0XHRcdFx0XHQnbW91c2Vtb3ZlJyA6IHR5cGUsIGV2ZW50LCBwb2ludCwgcHJldlBvaW50LCBkcmFnSXRlbSlcblx0XHRcdHx8IGVtaXRNb3VzZUV2ZW50KHZpZXcsIGRyYWdJdGVtIHx8IGhpdEl0ZW0gfHwgdmlldywgdHlwZSwgZXZlbnQsXG5cdFx0XHRcdFx0cG9pbnQsIHByZXZQb2ludCkpO1xuXHR9XG5cblx0dmFyIGl0ZW1FdmVudHNNYXAgPSB7XG5cdFx0bW91c2Vkb3duOiB7XG5cdFx0XHRtb3VzZWRvd246IDEsXG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRjbGljazogMSxcblx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0fSxcblx0XHRtb3VzZXVwOiB7XG5cdFx0XHRtb3VzZXVwOiAxLFxuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRkb3VibGVjbGljazogMVxuXHRcdH0sXG5cdFx0bW91c2Vtb3ZlOiB7XG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRtb3VzZW1vdmU6IDEsXG5cdFx0XHRtb3VzZWVudGVyOiAxLFxuXHRcdFx0bW91c2VsZWF2ZTogMVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdF92aWV3RXZlbnRzOiB2aWV3RXZlbnRzLFxuXG5cdFx0X2hhbmRsZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50LCBwb2ludCkge1xuXHRcdFx0dmFyIGl0ZW1FdmVudHMgPSB0aGlzLl9pdGVtRXZlbnRzLFxuXHRcdFx0XHRoaXRJdGVtcyA9IGl0ZW1FdmVudHMubmF0aXZlW3R5cGVdLFxuXHRcdFx0XHRuYXRpdmVNb3ZlID0gdHlwZSA9PT0gJ21vdXNlbW92ZScsXG5cdFx0XHRcdHRvb2wgPSB0aGlzLl9zY29wZS50b29sLFxuXHRcdFx0XHR2aWV3ID0gdGhpcztcblxuXHRcdFx0ZnVuY3Rpb24gcmVzcG9uZHModHlwZSkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbUV2ZW50cy52aXJ0dWFsW3R5cGVdIHx8IHZpZXcucmVzcG9uZHModHlwZSlcblx0XHRcdFx0XHRcdHx8IHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5hdGl2ZU1vdmUgJiYgZHJhZ2dpbmcgJiYgcmVzcG9uZHMoJ21vdXNlZHJhZycpKVxuXHRcdFx0XHR0eXBlID0gJ21vdXNlZHJhZyc7XG5cdFx0XHRpZiAoIXBvaW50KVxuXHRcdFx0XHRwb2ludCA9IHRoaXMuZ2V0RXZlbnRQb2ludChldmVudCk7XG5cblx0XHRcdHZhciBpblZpZXcgPSB0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50KSxcblx0XHRcdFx0aGl0ID0gaGl0SXRlbXMgJiYgaW5WaWV3ICYmIHZpZXcuX3Byb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogMCxcblx0XHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRcdHN0cm9rZTogdHJ1ZVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0aGl0SXRlbSA9IGhpdCAmJiBoaXQuaXRlbSB8fCBudWxsLFxuXHRcdFx0XHRoYW5kbGUgPSBmYWxzZSxcblx0XHRcdFx0bW91c2UgPSB7fTtcblx0XHRcdG1vdXNlW3R5cGUuc3Vic3RyKDUpXSA9IHRydWU7XG5cblx0XHRcdGlmIChoaXRJdGVtcyAmJiBoaXRJdGVtICE9PSBvdmVySXRlbSkge1xuXHRcdFx0XHRpZiAob3Zlckl0ZW0pIHtcblx0XHRcdFx0XHRlbWl0TW91c2VFdmVudChvdmVySXRlbSwgbnVsbCwgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoaXRJdGVtKSB7XG5cdFx0XHRcdFx0ZW1pdE1vdXNlRXZlbnQoaGl0SXRlbSwgbnVsbCwgJ21vdXNlZW50ZXInLCBldmVudCwgcG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG92ZXJJdGVtID0gaGl0SXRlbTtcblx0XHRcdH1cblx0XHRcdGlmICh3YXNJblZpZXcgXiBpblZpZXcpIHtcblx0XHRcdFx0ZW1pdE1vdXNlRXZlbnQodGhpcywgbnVsbCwgaW5WaWV3ID8gJ21vdXNlZW50ZXInIDogJ21vdXNlbGVhdmUnLFxuXHRcdFx0XHRcdFx0ZXZlbnQsIHBvaW50KTtcblx0XHRcdFx0b3ZlclZpZXcgPSBpblZpZXcgPyB0aGlzIDogbnVsbDtcblx0XHRcdFx0aGFuZGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICgoaW5WaWV3IHx8IG1vdXNlLmRyYWcpICYmICFwb2ludC5lcXVhbHMobGFzdFBvaW50KSkge1xuXHRcdFx0XHRlbWl0TW91c2VFdmVudHModGhpcywgaGl0SXRlbSwgbmF0aXZlTW92ZSA/IHR5cGUgOiAnbW91c2Vtb3ZlJyxcblx0XHRcdFx0XHRcdGV2ZW50LCBwb2ludCwgbGFzdFBvaW50KTtcblx0XHRcdFx0aGFuZGxlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHdhc0luVmlldyA9IGluVmlldztcblx0XHRcdGlmIChtb3VzZS5kb3duICYmIGluVmlldyB8fCBtb3VzZS51cCAmJiBkb3duUG9pbnQpIHtcblx0XHRcdFx0ZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIHR5cGUsIGV2ZW50LCBwb2ludCwgZG93blBvaW50KTtcblx0XHRcdFx0aWYgKG1vdXNlLmRvd24pIHtcblx0XHRcdFx0XHRkYmxDbGljayA9IGhpdEl0ZW0gPT09IGNsaWNrSXRlbVxuXHRcdFx0XHRcdFx0JiYgKERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDApO1xuXHRcdFx0XHRcdGRvd25JdGVtID0gY2xpY2tJdGVtID0gaGl0SXRlbTtcblx0XHRcdFx0XHRpZiAoIXByZXZlbnRlZCAmJiBoaXRJdGVtKSB7XG5cdFx0XHRcdFx0XHR2YXIgaXRlbSA9IGhpdEl0ZW07XG5cdFx0XHRcdFx0XHR3aGlsZSAoaXRlbSAmJiAhaXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdFx0XHRcdGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdFx0XHRpZiAoaXRlbSlcblx0XHRcdFx0XHRcdFx0ZHJhZ0l0ZW0gPSBoaXRJdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb3duUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0fSBlbHNlIGlmIChtb3VzZS51cCkge1xuXHRcdFx0XHRcdGlmICghcHJldmVudGVkICYmIGhpdEl0ZW0gPT09IGRvd25JdGVtKSB7XG5cdFx0XHRcdFx0XHRjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdFx0ZW1pdE1vdXNlRXZlbnRzKHRoaXMsIGhpdEl0ZW0sIGRibENsaWNrID8gJ2RvdWJsZWNsaWNrJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2NsaWNrJywgZXZlbnQsIHBvaW50LCBkb3duUG9pbnQpO1xuXHRcdFx0XHRcdFx0ZGJsQ2xpY2sgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FzSW5WaWV3ID0gZmFsc2U7XG5cdFx0XHRcdGhhbmRsZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRsYXN0UG9pbnQgPSBwb2ludDtcblx0XHRcdGlmIChoYW5kbGUgJiYgdG9vbCkge1xuXHRcdFx0XHRjYWxsZWQgPSB0b29sLl9oYW5kbGVNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgbW91c2UpXG5cdFx0XHRcdFx0fHwgY2FsbGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlXG5cdFx0XHRcdCYmIChjYWxsZWQgJiYgIW1vdXNlLm1vdmUgfHwgbW91c2UuZG93biAmJiByZXNwb25kcygnbW91c2V1cCcpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oYW5kbGVLZXlFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSB0aGlzLl9zY29wZSxcblx0XHRcdFx0dG9vbCA9IHNjb3BlLnRvb2wsXG5cdFx0XHRcdGtleUV2ZW50O1xuXG5cdFx0XHRmdW5jdGlvbiBlbWl0KG9iaikge1xuXHRcdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdFx0XHRvYmouZW1pdCh0eXBlLCBrZXlFdmVudCA9IGtleUV2ZW50XG5cdFx0XHRcdFx0XHRcdHx8IG5ldyBLZXlFdmVudCh0eXBlLCBldmVudCwga2V5LCBjaGFyYWN0ZXIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRlbWl0KHRoaXMpO1xuXHRcdFx0XHRpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKVxuXHRcdFx0XHRcdGVtaXQodG9vbCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jb3VudEl0ZW1FdmVudDogZnVuY3Rpb24odHlwZSwgc2lnbikge1xuXHRcdFx0dmFyIGl0ZW1FdmVudHMgPSB0aGlzLl9pdGVtRXZlbnRzLFxuXHRcdFx0XHRuYXRpdmUgPSBpdGVtRXZlbnRzLm5hdGl2ZSxcblx0XHRcdFx0dmlydHVhbCA9IGl0ZW1FdmVudHMudmlydHVhbDtcblx0XHRcdGZvciAodmFyIGtleSBpbiBpdGVtRXZlbnRzTWFwKSB7XG5cdFx0XHRcdG5hdGl2ZVtrZXldID0gKG5hdGl2ZVtrZXldIHx8IDApXG5cdFx0XHRcdFx0XHQrIChpdGVtRXZlbnRzTWFwW2tleV1bdHlwZV0gfHwgMCkgKiBzaWduO1xuXHRcdFx0fVxuXHRcdFx0dmlydHVhbFt0eXBlXSA9ICh2aXJ0dWFsW3R5cGVdIHx8IDApICsgc2lnbjtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0dXBkYXRlRm9jdXM6IHVwZGF0ZUZvY3VzLFxuXG5cdFx0XHRfcmVzZXRTdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRyYWdnaW5nID0gbW91c2VEb3duID0gY2FsbGVkID0gd2FzSW5WaWV3ID0gZmFsc2U7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHRlbXBGb2N1cyA9IG92ZXJWaWV3ID0gZG93blBvaW50ID0gbGFzdFBvaW50ID1cblx0XHRcdFx0XHRkb3duSXRlbSA9IG92ZXJJdGVtID0gZHJhZ0l0ZW0gPSBjbGlja0l0ZW0gPSBjbGlja1RpbWUgPVxuXHRcdFx0XHRcdGRibENsaWNrID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59KTtcblxudmFyIENhbnZhc1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cdF9jbGFzczogJ0NhbnZhc1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG5cdFx0aWYgKCEoY2FudmFzIGluc3RhbmNlb2Ygd2luZG93LkhUTUxDYW52YXNFbGVtZW50KSkge1xuXHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHRcdGlmIChzaXplLmlzWmVybygpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBDYW52YXNWaWV3IHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50OiAnXG5cdFx0XHRcdFx0XHQrIEJhc2Uuc2xpY2UoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSk7XG5cdFx0fVxuXHRcdHZhciBjdHggPSB0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHRpZiAoIS9eb2ZmfGZhbHNlJC8udGVzdChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShjYW52YXMsICdoaWRwaScpKSkge1xuXHRcdFx0dmFyIGRldmljZVJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdFx0YmFja2luZ1N0b3JlUmF0aW8gPSBEb21FbGVtZW50LmdldFByZWZpeGVkKGN0eCxcblx0XHRcdFx0XHRcdCdiYWNraW5nU3RvcmVQaXhlbFJhdGlvJykgfHwgMTtcblx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBkZXZpY2VSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXHRcdH1cblx0XHRWaWV3LmNhbGwodGhpcywgcHJvamVjdCwgY2FudmFzKTtcblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0dGhpcy5fY29udGV4dC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHJlbW92ZS5iYXNlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X3NldEVsZW1lbnRTaXplOiBmdW5jdGlvbiBfc2V0RWxlbWVudFNpemUod2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciBwaXhlbFJhdGlvID0gdGhpcy5fcGl4ZWxSYXRpbztcblx0XHRfc2V0RWxlbWVudFNpemUuYmFzZS5jYWxsKHRoaXMsIHdpZHRoICogcGl4ZWxSYXRpbywgaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG5cdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdFx0Y3R4ID0gdGhpcy5fY29udGV4dDtcblx0XHRcdGlmICghUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZXh0O1xuXHR9LFxuXG5cdGdldFBpeGVsU2l6ZTogZnVuY3Rpb24gZ2V0UGl4ZWxTaXplKHNpemUpIHtcblx0XHR2YXIgYWdlbnQgPSBwYXBlci5hZ2VudCxcblx0XHRcdHBpeGVscztcblx0XHRpZiAoYWdlbnQgJiYgYWdlbnQuZmlyZWZveCkge1xuXHRcdFx0cGl4ZWxzID0gZ2V0UGl4ZWxTaXplLmJhc2UuY2FsbCh0aGlzLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQ7XG5cdFx0XHRjdHguZm9udCA9IHNpemUgKyAnIHNlcmlmJztcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQoY3R4LmZvbnQpO1xuXHRcdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVscztcblx0fSxcblxuXHRnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGZvbnQsIGxpbmVzKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250LFxuXHRcdFx0d2lkdGggPSAwO1xuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGgpO1xuXHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0cmV0dXJuIHdpZHRoO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9uZWVkc1VwZGF0ZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRjdHggPSB0aGlzLl9jb250ZXh0LFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCArIDEsIHNpemUuaGVpZ2h0ICsgMSk7XG5cdFx0aWYgKHByb2plY3QpXG5cdFx0XHRwcm9qZWN0LmRyYXcoY3R4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX3BpeGVsUmF0aW8pO1xuXHRcdHRoaXMuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0V2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHR0aGlzLnR5cGUgPSBldmVudCAmJiBldmVudC50eXBlO1xuXHR9LFxuXG5cdHByZXZlbnRlZDogZmFsc2UsXG5cdHN0b3BwZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnByZXZlbnRlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zdG9wcGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdGdldFRpbWVTdGFtcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXZlbnQudGltZVN0YW1wO1xuXHR9LFxuXG5cdGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEtleS5tb2RpZmllcnM7XG5cdH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdLZXlFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQodHlwZSwgZXZlbnQsIGtleSwgY2hhcmFjdGVyKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG5cdFx0XHRcdCsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyXG5cdFx0XHRcdCsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrIFwiIH1cIjtcblx0fVxufSk7XG5cbnZhciBLZXkgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBrZXlMb29rdXAgPSB7XG5cdFx0XHQnXFx0JzogJ3RhYicsXG5cdFx0XHQnICc6ICdzcGFjZScsXG5cdFx0XHQnXFxiJzogJ2JhY2tzcGFjZScsXG5cdFx0XHQnXFx4N2YnOiAnZGVsZXRlJyxcblx0XHRcdCdTcGFjZWJhcic6ICdzcGFjZScsXG5cdFx0XHQnRGVsJzogJ2RlbGV0ZScsXG5cdFx0XHQnV2luJzogJ21ldGEnLFxuXHRcdFx0J0VzYyc6ICdlc2NhcGUnXG5cdFx0fSxcblxuXHRcdGNoYXJMb29rdXAgPSB7XG5cdFx0XHQndGFiJzogJ1xcdCcsXG5cdFx0XHQnc3BhY2UnOiAnICcsXG5cdFx0XHQnZW50ZXInOiAnXFxyJ1xuXHRcdH0sXG5cblx0XHRrZXlNYXAgPSB7fSxcblx0XHRjaGFyTWFwID0ge30sXG5cdFx0bWV0YUZpeE1hcCxcblx0XHRkb3duS2V5LFxuXG5cdFx0bW9kaWZpZXJzID0gbmV3IEJhc2Uoe1xuXHRcdFx0c2hpZnQ6IGZhbHNlLFxuXHRcdFx0Y29udHJvbDogZmFsc2UsXG5cdFx0XHRhbHQ6IGZhbHNlLFxuXHRcdFx0bWV0YTogZmFsc2UsXG5cdFx0XHRjYXBzTG9jazogZmFsc2UsXG5cdFx0XHRzcGFjZTogZmFsc2Vcblx0XHR9KS5pbmplY3Qoe1xuXHRcdFx0b3B0aW9uOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRjb21tYW5kOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGFnZW50ID0gcGFwZXIgJiYgcGFwZXIuYWdlbnQ7XG5cdFx0XHRcdFx0cmV0dXJuIGFnZW50ICYmIGFnZW50Lm1hYyA/IHRoaXMubWV0YSA6IHRoaXMuY29udHJvbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEtleShldmVudCkge1xuXHRcdHZhciBrZXkgPSBldmVudC5rZXkgfHwgZXZlbnQua2V5SWRlbnRpZmllcjtcblx0XHRrZXkgPSAvXlVcXCsvLnRlc3Qoa2V5KVxuXHRcdFx0XHQ/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2V5LnN1YnN0cigyKSwgMTYpKVxuXHRcdFx0XHQ6IC9eQXJyb3dbQS1aXS8udGVzdChrZXkpID8ga2V5LnN1YnN0cig1KVxuXHRcdFx0XHQ6IGtleSA9PT0gJ1VuaWRlbnRpZmllZCcgIHx8IGtleSA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0PyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmtleUNvZGUpXG5cdFx0XHRcdFx0OiBrZXk7XG5cdFx0cmV0dXJuIGtleUxvb2t1cFtrZXldIHx8XG5cdFx0XHRcdChrZXkubGVuZ3RoID4gMSA/IEJhc2UuaHlwaGVuYXRlKGtleSkgOiBrZXkudG9Mb3dlckNhc2UoKSk7XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG5cdFx0dmFyIHR5cGUgPSBkb3duID8gJ2tleWRvd24nIDogJ2tleXVwJyxcblx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0bmFtZTtcblx0XHRrZXlNYXBba2V5XSA9IGRvd247XG5cdFx0aWYgKGRvd24pIHtcblx0XHRcdGNoYXJNYXBba2V5XSA9IGNoYXJhY3Rlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGNoYXJNYXBba2V5XTtcblx0XHR9XG5cdFx0aWYgKGtleS5sZW5ndGggPiAxICYmIChuYW1lID0gQmFzZS5jYW1lbGl6ZShrZXkpKSBpbiBtb2RpZmllcnMpIHtcblx0XHRcdG1vZGlmaWVyc1tuYW1lXSA9IGRvd247XG5cdFx0XHR2YXIgYWdlbnQgPSBwYXBlciAmJiBwYXBlci5hZ2VudDtcblx0XHRcdGlmIChuYW1lID09PSAnbWV0YScgJiYgYWdlbnQgJiYgYWdlbnQubWFjKSB7XG5cdFx0XHRcdGlmIChkb3duKSB7XG5cdFx0XHRcdFx0bWV0YUZpeE1hcCA9IHt9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGsgaW4gbWV0YUZpeE1hcCkge1xuXHRcdFx0XHRcdFx0aWYgKGsgaW4gY2hhck1hcClcblx0XHRcdFx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBrLCBtZXRhRml4TWFwW2tdLCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1ldGFGaXhNYXAgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkb3duICYmIG1ldGFGaXhNYXApIHtcblx0XHRcdG1ldGFGaXhNYXBba2V5XSA9IGNoYXJhY3Rlcjtcblx0XHR9XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdHZpZXcuX2hhbmRsZUtleUV2ZW50KGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLCBldmVudCwga2V5LFxuXHRcdFx0XHRcdGNoYXJhY3Rlcik7XG5cdFx0fVxuXHR9XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpLFxuXHRcdFx0XHRhZ2VudCA9IHBhcGVyICYmIHBhcGVyLmFnZW50O1xuXHRcdFx0aWYgKGtleS5sZW5ndGggPiAxIHx8IGFnZW50ICYmIChhZ2VudC5jaHJvbWUgJiYgKGV2ZW50LmFsdEtleVxuXHRcdFx0XHRcdFx0fHwgYWdlbnQubWFjICYmIGV2ZW50Lm1ldGFLZXlcblx0XHRcdFx0XHRcdHx8ICFhZ2VudC5tYWMgJiYgZXZlbnQuY3RybEtleSkpKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBrZXksXG5cdFx0XHRcdFx0XHRjaGFyTG9va3VwW2tleV0gfHwgKGtleS5sZW5ndGggPiAxID8gJycgOiBrZXkpLCBldmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb3duS2V5ID0ga2V5O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXlwcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkb3duS2V5KSB7XG5cdFx0XHRcdHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpLFxuXHRcdFx0XHRcdGNvZGUgPSBldmVudC5jaGFyQ29kZSxcblx0XHRcdFx0XHRjaGFyYWN0ZXIgPSBjb2RlID49IDMyID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKVxuXHRcdFx0XHRcdFx0OiBrZXkubGVuZ3RoID4gMSA/ICcnIDoga2V5O1xuXHRcdFx0XHRpZiAoa2V5ICE9PSBkb3duS2V5KSB7XG5cdFx0XHRcdFx0a2V5ID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGtleSwgY2hhcmFjdGVyLCBldmVudCk7XG5cdFx0XHRcdGRvd25LZXkgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBrZXkgPSBnZXRLZXkoZXZlbnQpO1xuXHRcdFx0aWYgKGtleSBpbiBjaGFyTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGtleSwgY2hhck1hcFtrZXldLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Ymx1cjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBjaGFyTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGtleSwgY2hhck1hcFtrZXldLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG5cdFx0aXNEb3duOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHJldHVybiAhIWtleU1hcFtrZXldO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTW91c2VFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0XHR0aGlzLnBvaW50ID0gcG9pbnQ7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywgcG9pbnQ6IFwiICsgdGhpcy5wb2ludFxuXHRcdFx0XHQrICcsIHRhcmdldDogJyArIHRoaXMudGFyZ2V0XG5cdFx0XHRcdCsgKHRoaXMuZGVsdGEgPyAnLCBkZWx0YTogJyArIHRoaXMuZGVsdGEgOiAnJylcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sRXZlbnQnLFxuXHRfaXRlbTogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpIHtcblx0XHR0aGlzLnRvb2wgPSB0b29sO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9LFxuXG5cdF9jaG9vc2VQb2ludDogZnVuY3Rpb24ocG9pbnQsIHRvb2xQb2ludCkge1xuXHRcdHJldHVybiBwb2ludCA/IHBvaW50IDogdG9vbFBvaW50ID8gdG9vbFBvaW50LmNsb25lKCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fcG9pbnQsIHRoaXMudG9vbC5fcG9pbnQpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdH0sXG5cblx0Z2V0TGFzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fbGFzdFBvaW50LCB0aGlzLnRvb2wuX2xhc3RQb2ludCk7XG5cdH0sXG5cblx0c2V0TGFzdFBvaW50OiBmdW5jdGlvbihsYXN0UG9pbnQpIHtcblx0XHR0aGlzLl9sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG5cdH0sXG5cblx0Z2V0RG93blBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fZG93blBvaW50LCB0aGlzLnRvb2wuX2Rvd25Qb2ludCk7XG5cdH0sXG5cblx0c2V0RG93blBvaW50OiBmdW5jdGlvbihkb3duUG9pbnQpIHtcblx0XHR0aGlzLl9kb3duUG9pbnQgPSBkb3duUG9pbnQ7XG5cdH0sXG5cblx0Z2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fbWlkZGxlUG9pbnQgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvb2wuX3BvaW50LmFkZCh0aGlzLnRvb2wuX2xhc3RQb2ludCkuZGl2aWRlKDIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0c2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKG1pZGRsZVBvaW50KSB7XG5cdFx0dGhpcy5fbWlkZGxlUG9pbnQgPSBtaWRkbGVQb2ludDtcblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9kZWx0YSAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludFxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fcG9pbnQuc3VidHJhY3QodGhpcy50b29sLl9sYXN0UG9pbnQpXG5cdFx0XHRcdDogdGhpcy5fZGVsdGE7XG5cdH0sXG5cblx0c2V0RGVsdGE6IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0dGhpcy5fZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHRnZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpXG5cdFx0XHRcdD8gJ19kb3duQ291bnQnIDogJ19tb3ZlQ291bnQnXTtcblx0fSxcblxuXHRzZXRDb3VudDogZnVuY3Rpb24oY291bnQpIHtcblx0XHR0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cblx0XHRcdD0gY291bnQ7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcblx0XHRcdFx0XHRwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuXHRcdFx0XHRcdGl0ZW0gPSBwYXJlbnQ7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuXHRcdFx0XHQrICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2wnLFxuXHRfbGlzdDogJ3Rvb2xzJyxcblx0X3JlZmVyZW5jZTogJ3Rvb2wnLFxuXHRfZXZlbnRzOiBbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbk1vdXNlTW92ZScsXG5cdFx0XHQnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsICdvbktleURvd24nLFxuXHRcdFx0J29uS2V5VXAnXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sKHByb3BzKSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9tb3ZlQ291bnQgPSAtMTtcblx0XHR0aGlzLl9kb3duQ291bnQgPSAtMTtcblx0XHR0aGlzLnNldChwcm9wcyk7XG5cdH0sXG5cblx0Z2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24obWluRGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgbWluRGlzdGFuY2UgPiB0aGlzLl9tYXhEaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhEaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgbWF4RGlzdGFuY2UgPCB0aGlzLl9taW5EaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlID09IHRoaXMuX21heERpc3RhbmNlXG5cdFx0XHQ/IHRoaXMuX21pbkRpc3RhbmNlIDogbnVsbDtcblx0fSxcblxuXHRzZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbihkaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gdGhpcy5fbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0fSxcblxuXHRfaGFuZGxlTW91c2VFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQsIHBvaW50LCBtb3VzZSkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0aWYgKG1vdXNlLmRyYWcgJiYgIXRoaXMucmVzcG9uZHModHlwZSkpXG5cdFx0XHR0eXBlID0gJ21vdXNlbW92ZSc7XG5cdFx0dmFyIG1vdmUgPSBtb3VzZS5tb3ZlIHx8IG1vdXNlLmRyYWcsXG5cdFx0XHRyZXNwb25kcyA9IHRoaXMucmVzcG9uZHModHlwZSksXG5cdFx0XHRtaW5EaXN0YW5jZSA9IHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRtYXhEaXN0YW5jZSA9IHRoaXMubWF4RGlzdGFuY2UsXG5cdFx0XHRjYWxsZWQgPSBmYWxzZSxcblx0XHRcdHRvb2wgPSB0aGlzO1xuXHRcdGZ1bmN0aW9uIHVwZGF0ZShtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UpIHtcblx0XHRcdHZhciBwdCA9IHBvaW50LFxuXHRcdFx0XHR0b29sUG9pbnQgPSBtb3ZlID8gdG9vbC5fcG9pbnQgOiAodG9vbC5fZG93blBvaW50IHx8IHB0KTtcblx0XHRcdGlmIChtb3ZlKSB7XG5cdFx0XHRcdGlmICh0b29sLl9tb3ZlQ291bnQgPj0gMCAmJiBwdC5lcXVhbHModG9vbFBvaW50KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodG9vbFBvaW50ICYmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpKSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IHB0LnN1YnRyYWN0KHRvb2xQb2ludCksXG5cdFx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPCAobWluRGlzdGFuY2UgfHwgMCkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKG1heERpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRwdCA9IHRvb2xQb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShcblx0XHRcdFx0XHRcdFx0XHRNYXRoLm1pbihkaXN0YW5jZSwgbWF4RGlzdGFuY2UpKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRvb2wuX21vdmVDb3VudCsrO1xuXHRcdFx0fVxuXHRcdFx0dG9vbC5fcG9pbnQgPSBwdDtcblx0XHRcdHRvb2wuX2xhc3RQb2ludCA9IHRvb2xQb2ludCB8fCBwdDtcblx0XHRcdGlmIChtb3VzZS5kb3duKSB7XG5cdFx0XHRcdHRvb2wuX21vdmVDb3VudCA9IC0xO1xuXHRcdFx0XHR0b29sLl9kb3duUG9pbnQgPSBwdDtcblx0XHRcdFx0dG9vbC5fZG93bkNvdW50Kys7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbWl0KCkge1xuXHRcdFx0aWYgKHJlc3BvbmRzKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRvb2wuZW1pdCh0eXBlLCBuZXcgVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSlcblx0XHRcdFx0XHRcdHx8IGNhbGxlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobW91c2UuZG93bikge1xuXHRcdFx0dXBkYXRlKCk7XG5cdFx0XHRlbWl0KCk7XG5cdFx0fSBlbHNlIGlmIChtb3VzZS51cCkge1xuXHRcdFx0dXBkYXRlKG51bGwsIG1heERpc3RhbmNlKTtcblx0XHRcdGVtaXQoKTtcblx0XHR9IGVsc2UgaWYgKHJlc3BvbmRzKSB7XG5cdFx0XHR3aGlsZSAodXBkYXRlKG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSkpXG5cdFx0XHRcdGVtaXQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIFR3ZWVuID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRfY2xhc3M6ICdUd2VlbicsXG5cblx0c3RhdGljczoge1xuXHRcdGVhc2luZ3M6IHtcblx0XHRcdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgKiAoMiAtIHQpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCA8IDAuNVxuXHRcdFx0XHRcdD8gMiAqIHQgKiB0XG5cdFx0XHRcdFx0OiAtMSArIDIgKiAoMiAtIHQpICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJbkN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0IDwgMC41XG5cdFx0XHRcdFx0PyA0ICogdCAqIHQgKiB0XG5cdFx0XHRcdFx0OiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG5cdFx0XHR9LFxuXG5cdFx0XHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdFx0XHRyZXR1cm4gMSAtICgtLXQpICogdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgPCAwLjVcblx0XHRcdFx0XHQ/IDggKiB0ICogdCAqIHQgKiB0XG5cdFx0XHRcdFx0OiAxIC0gOCAqICgtLXQpICogdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZUluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRcdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdFx0fSxcblxuXHRcdFx0ZWFzZU91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcblx0XHRcdH0sXG5cblx0XHRcdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0XHRcdHJldHVybiB0IDwgMC41XG5cdFx0XHRcdFx0PyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0XG5cdFx0XHRcdFx0OiAxICsgMTYgKiAoLS10KSAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFR3ZWVuKG9iamVjdCwgZnJvbSwgdG8sIGR1cmF0aW9uLCBlYXNpbmcsIHN0YXJ0KSB7XG5cdFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgZWFzaW5nO1xuXHRcdHZhciBpc0Z1bmN0aW9uID0gdHlwZSA9PT0gJ2Z1bmN0aW9uJztcblx0XHR0aGlzLnR5cGUgPSBpc0Z1bmN0aW9uXG5cdFx0XHQ/IHR5cGVcblx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZydcblx0XHRcdFx0PyBlYXNpbmdcblx0XHRcdFx0OiAnbGluZWFyJztcblx0XHR0aGlzLmVhc2luZyA9IGlzRnVuY3Rpb24gPyBlYXNpbmcgOiBUd2Vlbi5lYXNpbmdzW3RoaXMudHlwZV07XG5cdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fdGhlbiA9IG51bGw7XG5cdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcblx0XHR2YXIgc3RhdGUgPSBmcm9tIHx8IHRvO1xuXHRcdHRoaXMuX2tleXMgPSBzdGF0ZSA/IE9iamVjdC5rZXlzKHN0YXRlKSA6IFtdO1xuXHRcdHRoaXMuX3BhcnNlZEtleXMgPSB0aGlzLl9wYXJzZUtleXModGhpcy5fa2V5cyk7XG5cdFx0dGhpcy5fZnJvbSA9IHN0YXRlICYmIHRoaXMuX2dldFN0YXRlKGZyb20pO1xuXHRcdHRoaXMuX3RvID0gc3RhdGUgJiYgdGhpcy5fZ2V0U3RhdGUodG8pO1xuXHRcdGlmIChzdGFydCAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc3RhcnQoKTtcblx0XHR9XG5cdH0sXG5cblx0dGhlbjogZnVuY3Rpb24odGhlbikge1xuXHRcdHRoaXMuX3RoZW4gPSB0aGVuO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xuXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihwcm9ncmVzcykge1xuXHRcdGlmICh0aGlzLnJ1bm5pbmcpIHtcblx0XHRcdGlmIChwcm9ncmVzcyA+IDEpIHtcblx0XHRcdFx0cHJvZ3Jlc3MgPSAxO1xuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGZhY3RvciA9IHRoaXMuZWFzaW5nKHByb2dyZXNzKSxcblx0XHRcdFx0a2V5cyA9IHRoaXMuX2tleXMsXG5cdFx0XHRcdGdldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHZhbHVlKGZhY3RvciwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzICYmIGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRcdGZyb20gPSBnZXRWYWx1ZSh0aGlzLl9mcm9tW2tleV0pLFxuXHRcdFx0XHRcdHRvID0gZ2V0VmFsdWUodGhpcy5fdG9ba2V5XSksXG5cdFx0XHRcdFx0dmFsdWUgPSAoZnJvbSAmJiB0byAmJiBmcm9tLl9fYWRkICYmIHRvLl9fYWRkKVxuXHRcdFx0XHRcdFx0PyB0by5fX3N1YnRyYWN0KGZyb20pLl9fbXVsdGlwbHkoZmFjdG9yKS5fX2FkZChmcm9tKVxuXHRcdFx0XHRcdFx0OiAoKHRvIC0gZnJvbSkgKiBmYWN0b3IpICsgZnJvbTtcblx0XHRcdFx0dGhpcy5fc2V0UHJvcGVydHkodGhpcy5fcGFyc2VkS2V5c1trZXldLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5ydW5uaW5nICYmIHRoaXMuX3RoZW4pIHtcblx0XHRcdFx0dGhpcy5fdGhlbih0aGlzLm9iamVjdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5yZXNwb25kcygndXBkYXRlJykpIHtcblx0XHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgQmFzZSh7XG5cdFx0XHRcdFx0cHJvZ3Jlc3M6IHByb2dyZXNzLFxuXHRcdFx0XHRcdGZhY3RvcjogZmFjdG9yXG5cdFx0XHRcdH0pKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X2V2ZW50czoge1xuXHRcdG9uVXBkYXRlOiB7fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZTogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBzdGFydFRpbWUgPSB0aGlzLl9zdGFydFRpbWUsXG5cdFx0XHRwcm9ncmVzcyA9IHN0YXJ0VGltZVxuXHRcdFx0XHQ/ICh0aW1lIC0gc3RhcnRUaW1lKSAvIHRoaXMuZHVyYXRpb25cblx0XHRcdFx0OiAwO1xuXHRcdGlmICghc3RhcnRUaW1lKSB7XG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZShwcm9ncmVzcyk7XG5cdH0sXG5cblx0X2dldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHZhciBrZXlzID0gdGhpcy5fa2V5cyxcblx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5fcGFyc2VkS2V5c1trZXldLFxuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5fZ2V0UHJvcGVydHkocGF0aCksXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0aWYgKHN0YXRlKSB7XG5cdFx0XHRcdHZhciByZXNvbHZlZCA9IHRoaXMuX3Jlc29sdmVWYWx1ZShjdXJyZW50LCBzdGF0ZVtrZXldKTtcblx0XHRcdFx0dGhpcy5fc2V0UHJvcGVydHkocGF0aCwgcmVzb2x2ZWQpO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2dldFByb3BlcnR5KHBhdGgpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLmNsb25lID8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9wZXJ0eShwYXRoLCBjdXJyZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gY3VycmVudCAmJiBjdXJyZW50LmNsb25lID8gY3VycmVudC5jbG9uZSgpIDogY3VycmVudDtcblx0XHRcdH1cblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0X3Jlc29sdmVWYWx1ZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWUpIHtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0dmFyIG9wZXJhdG9yID0gdmFsdWVbMF07XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0b3BlcmF0b3IgJiZcblx0XHRcdFx0XHRvcGVyYXRvci5tYXRjaCAmJlxuXHRcdFx0XHRcdG9wZXJhdG9yLm1hdGNoKC9eWytcXC1cXCpcXC9dPS8pXG5cdFx0XHRcdClcblx0XHRcdFx0XHQ/IHRoaXMuX2NhbGN1bGF0ZShjdXJyZW50LCBvcGVyYXRvclswXSwgdmFsdWVbMV0pXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXlsrXFwtKi9dPSguKikvKTtcblx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0dmFyIHBhcnNlZCA9IEpTT04ucGFyc2UobWF0Y2hbMV0ucmVwbGFjZShcblx0XHRcdFx0XHRcdC8oWydcIl0pPyhbYS16QS1aMC05X10rKShbJ1wiXSk/Oi9nLFxuXHRcdFx0XHRcdFx0J1wiJDJcIjogJ1xuXHRcdFx0XHRcdCkpO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9jYWxjdWxhdGUoY3VycmVudCwgdmFsdWVbMF0sIHBhcnNlZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXG5cdF9jYWxjdWxhdGU6IGZ1bmN0aW9uKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHJldHVybiBwYXBlci5QYXBlclNjcmlwdC5jYWxjdWxhdGVCaW5hcnkobGVmdCwgb3BlcmF0b3IsIHJpZ2h0KTtcblx0fSxcblxuXHRfcGFyc2VLZXlzOiBmdW5jdGlvbihrZXlzKSB7XG5cdFx0dmFyIHBhcnNlZCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldLFxuXHRcdFx0XHRwYXRoID0ga2V5XG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcLihbXi5dKikvZywgJy8kMScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcW1snXCJdPyhbXidcIlxcXV0qKVsnXCJdP1xcXS9nLCAnLyQxJyk7XG5cdFx0XHRwYXJzZWRba2V5XSA9IHBhdGguc3BsaXQoJy8nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlZDtcblx0fSxcblxuXHRfZ2V0UHJvcGVydHk6IGZ1bmN0aW9uKHBhdGgsIG9mZnNldCkge1xuXHRcdHZhciBvYmogPSB0aGlzLm9iamVjdDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoIC0gKG9mZnNldCB8fCAwKTsgaSA8IGwgJiYgb2JqOyBpKyspIHtcblx0XHRcdG9iaiA9IG9ialtwYXRoW2ldXTtcblx0XHR9XG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHRfc2V0UHJvcGVydHk6IGZ1bmN0aW9uKHBhdGgsIHZhbHVlKSB7XG5cdFx0dmFyIGRlc3QgPSB0aGlzLl9nZXRQcm9wZXJ0eShwYXRoLCAxKTtcblx0XHRpZiAoZGVzdCkge1xuXHRcdFx0ZGVzdFtwYXRoW3BhdGgubGVuZ3RoIC0gMV1dID0gdmFsdWU7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgeGhyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR4aHIub3Blbigob3B0aW9ucy5tZXRob2QgfHwgJ2dldCcpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMudXJsLFxuXHRcdFx0XHRCYXNlLnBpY2sob3B0aW9ucy5hc3luYywgdHJ1ZSkpO1xuXHRcdGlmIChvcHRpb25zLm1pbWVUeXBlKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XG5cdFx0eGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLm9uTG9hZCkge1xuXHRcdFx0XHRcdG9wdGlvbnMub25Mb2FkLmNhbGwoeGhyLCB4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eGhyLm9uZXJyb3IoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RhdHVzID0geGhyLnN0YXR1cyxcblx0XHRcdFx0bWVzc2FnZSA9ICdDb3VsZCBub3QgbG9hZCBcIicgKyBvcHRpb25zLnVybCArICdcIiAoU3RhdHVzOiAnXG5cdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJztcblx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3IpIHtcblx0XHRcdFx0b3B0aW9ucy5vbkVycm9yKG1lc3NhZ2UsIHN0YXR1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4geGhyLnNlbmQobnVsbCk7XG5cdH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IHtcblx0Y2FudmFzZXM6IFtdLFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICghd2luZG93KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdGNsZWFyID0gZmFsc2U7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW52YXMgJyArIGNhbnZhcyArXG5cdFx0XHRcdFx0JyBpcyB1bmFibGUgdG8gcHJvdmlkZSBhIDJEIGNvbnRleHQuJyk7XG5cdFx0fVxuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIDogbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqICYmIG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGlmIChjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLFxuXHRcdGJyLCBiZywgYmIsIGJhLFxuXHRcdGRyLCBkZywgZGI7XG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSxcblx0XHRcdG1uID0gbWluKHIsIGcsIGIpLFxuXHRcdFx0bWQ7XG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdGlmIChjdHgpIHtcblx0XHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW5cblx0XHRcdFx0XHRcdFx0PyAxNzAgOiA1MTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHRcdH0pO1xuXHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0fVxuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHRcdHNyID0gc3JjW2ldO1xuXHRcdFx0XHRiciA9IGRzdFtpXTtcblx0XHRcdFx0c2cgPSBzcmNbaSArIDFdO1xuXHRcdFx0XHRiZyA9IGRzdFtpICsgMV07XG5cdFx0XHRcdHNiID0gc3JjW2kgKyAyXTtcblx0XHRcdFx0YmIgPSBkc3RbaSArIDJdO1xuXHRcdFx0XHRzYSA9IHNyY1tpICsgM107XG5cdFx0XHRcdGJhID0gZHN0W2kgKyAzXTtcblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHR2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuXHRcdFx0XHRcdGEyID0gMSAtIGExO1xuXHRcdFx0XHRkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcblx0XHRcdFx0ZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuXHRcdFx0XHRkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG5cdFx0XHRcdGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcblx0XHRcdH1cblx0XHRcdGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFN2Z0VsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBzdmcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnLFxuXHRcdHhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHtcblx0XHRcdGhyZWY6IHhsaW5rLFxuXHRcdFx0eGxpbms6IHhtbG5zLFxuXHRcdFx0eG1sbnM6IHhtbG5zICsgJy8nLFxuXHRcdFx0J3htbG5zOnhsaW5rJzogeG1sbnMgKyAnLydcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZSh0YWcsIGF0dHJpYnV0ZXMsIGZvcm1hdHRlcikge1xuXHRcdHJldHVybiBzZXQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2ZywgdGFnKSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldChub2RlLCBuYW1lKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IGF0dHJpYnV0ZU5hbWVzcGFjZVtuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbnVsbCcgPyBudWxsIDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobm9kZSwgYXR0cmlidXRlcywgZm9ybWF0dGVyKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2VbbmFtZV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBmb3JtYXR0ZXIpXG5cdFx0XHRcdHZhbHVlID0gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdmc6IHN2Zyxcblx0XHR4bWxuczogeG1sbnMsXG5cdFx0eGxpbms6IHhsaW5rLFxuXG5cdFx0Y3JlYXRlOiBjcmVhdGUsXG5cdFx0Z2V0OiBnZXQsXG5cdFx0c2V0OiBzZXRcblx0fTtcbn07XG5cbnZhciBTdmdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRmaWxsUnVsZTogWydmaWxsLXJ1bGUnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0eWxlJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRsb29rdXAgPSBlbnRyeVsyXTtcblx0dGhpc1trZXldID0ge1xuXHRcdHR5cGU6IGVudHJ5WzFdLFxuXHRcdHByb3BlcnR5OiBrZXksXG5cdFx0YXR0cmlidXRlOiBlbnRyeVswXSxcblx0XHR0b1NWRzogbG9va3VwLFxuXHRcdGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0dGhpc1t2YWx1ZV0gPSBuYW1lO1xuXHRcdH0sIHt9KSxcblx0XHRleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHR2YXIgcG9pbnQ7XG5cdFx0XHRpZiAobWF0cml4LmlzSW52ZXJ0aWJsZSgpKSB7XG5cdFx0XHRcdG1hdHJpeCA9IG1hdHJpeC5fc2hpZnRsZXNzKCk7XG5cdFx0XHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcblx0XHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBuZXcgUG9pbnQoKTtcblx0XHRcdH1cblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcblx0XHR9XG5cdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRcdGlmIChkZWNvbXBvc2VkKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0XHRcdGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcblx0XHRcdFx0XHRzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZyxcblx0XHRcdFx0XHRza2V3ID0gZGVjb21wb3NlZC5za2V3aW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmIChhbmdsZSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRpZiAoc2tldy54KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdYKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueCkgKyAnKScpO1xuXHRcdFx0XHRpZiAoc2tldy55KVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NrZXdZKCcgKyBmb3JtYXR0ZXIubnVtYmVyKHNrZXcueSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gU3ZnRWxlbWVudC5jcmVhdGUoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0U3ZnRWxlbWVudC5zZXQobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKSxcblx0XHRcdGltYWdlID0gaXRlbS5nZXRJbWFnZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBvcHRpb25zLmVtYmVkSW1hZ2VzID09IGZhbHNlICYmIGltYWdlICYmIGltYWdlLnNyY1xuXHRcdFx0XHR8fCBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBTdmdFbGVtZW50LmNyZWF0ZSgnaW1hZ2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBtYXRjaFNoYXBlcyA9IG9wdGlvbnMubWF0Y2hTaGFwZXM7XG5cdFx0aWYgKG1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiBsZW5ndGggPj0gMiAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChsZW5ndGggPiAyKSB7XG5cdFx0XHRcdHR5cGUgPSBpdGVtLl9jbG9zZWQgPyAncG9seWdvbicgOiAncG9seWxpbmUnO1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBzdGFydCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRlbmQgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IHN0YXJ0LngsXG5cdFx0XHRcdFx0eTE6IHN0YXJ0LnksXG5cdFx0XHRcdFx0eDI6IGVuZC54LFxuXHRcdFx0XHRcdHkyOiBlbmQueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKHR5cGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCdwYXRoJywgYXR0cnMsIGZvcm1hdHRlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTeW1ib2xJdGVtKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdGRlZmluaXRpb24gPSBpdGVtLl9kZWZpbml0aW9uLFxuXHRcdFx0bm9kZSA9IGdldERlZmluaXRpb24oZGVmaW5pdGlvbiwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbkl0ZW0gPSBkZWZpbml0aW9uLl9pdGVtLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbkl0ZW0uZ2V0U3Ryb2tlQm91bmRzKCk7XG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb25JdGVtLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKGRlZmluaXRpb24sIG5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIG5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gYm91bmRzLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG5cdFx0YXR0cnMub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuY3JlYXRlKCd1c2UnLCBhdHRycywgZm9ybWF0dGVyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJylcblx0XHRcdFx0XHQrICdHcmFkaWVudCcsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpLFxuXHRcdFx0XHRcdG9mZnNldCA9IHN0b3AuX29mZnNldDtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBvZmZzZXQgPT0gbnVsbCA/IGkgLyAobCAtIDEpIDogb2Zmc2V0XG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChzdG9wQ29sb3IpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3BDb2xvci50b0NTUyh0cnVlKTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKFxuXHRcdFx0XHRcdFx0U3ZnRWxlbWVudC5jcmVhdGUoJ3N0b3AnLCBhdHRycywgZm9ybWF0dGVyKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gU3ZnRWxlbWVudC5jcmVhdGUoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdFx0Zm9ybWF0dGVyKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRTeW1ib2xJdGVtOiBleHBvcnRTeW1ib2xJdGVtLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCksXG5cdFx0XHRzdHlsZSA9IFtdO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTdmdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdHN0eWxlLnB1c2goZW50cnkuYXR0cmlidXRlICsgJzogJyArIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbCA/ICdub25lJ1xuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcicgPyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheScgPyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJyA/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoc3R5bGUubGVuZ3RoKVxuXHRcdFx0YXR0cnMuc3R5bGUgPSBzdHlsZS5qb2luKCc7Jyk7XG5cblx0XHRpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSlcblx0XHRcdGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuXG5cdFx0aWYgKCFpdGVtLl92aXNpYmxlKVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIFN2Z0VsZW1lbnQuc2V0KG5vZGUsIGF0dHJzLCBmb3JtYXR0ZXIpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nXG5cdFx0XHRcdCsgKGl0ZW0uX2lkIHx8IGl0ZW0uX19pZCB8fCAoaXRlbS5fX2lkID0gVUlELmdldCgnc3ZnJykpKV07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciB0eXBlSWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIHR5cGVJZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyAoaXRlbS5faWQgfHwgaXRlbS5fX2lkKV0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IFN2Z0VsZW1lbnQuY3JlYXRlKCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoU3ZnRWxlbWVudC5jcmVhdGUoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IHNlbGYuWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0Ym91bmRzID0gQmFzZS5waWNrKG9wdGlvbnMuYm91bmRzLCAndmlldycpLFxuXHRcdFx0XHRteCA9IG9wdGlvbnMubWF0cml4IHx8IGJvdW5kcyA9PT0gJ3ZpZXcnICYmIHZpZXcuX21hdHJpeCxcblx0XHRcdFx0bWF0cml4ID0gbXggJiYgTWF0cml4LnJlYWQoW214XSksXG5cdFx0XHRcdHJlY3QgPSBib3VuZHMgPT09ICd2aWV3J1xuXHRcdFx0XHRcdD8gbmV3IFJlY3RhbmdsZShbMCwgMF0sIHZpZXcuZ2V0Vmlld1NpemUoKSlcblx0XHRcdFx0XHQ6IGJvdW5kcyA9PT0gJ2NvbnRlbnQnXG5cdFx0XHRcdFx0XHQ/IEl0ZW0uX2dldEJvdW5kcyhjaGlsZHJlbiwgbWF0cml4LCB7IHN0cm9rZTogdHJ1ZSB9KVxuXHRcdFx0XHRcdFx0XHQucmVjdFxuXHRcdFx0XHRcdFx0OiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSwgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6IFN2Z0VsZW1lbnQuc3ZnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6IFN2Z0VsZW1lbnQueGxpbmssXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocmVjdCkge1xuXHRcdFx0XHRhdHRycy53aWR0aCA9IHJlY3Qud2lkdGg7XG5cdFx0XHRcdGF0dHJzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXHRcdFx0XHRpZiAocmVjdC54IHx8IHJlY3QueCA9PT0gMCB8fCByZWN0LnkgfHwgcmVjdC55ID09PSAwKVxuXHRcdFx0XHRcdGF0dHJzLnZpZXdCb3ggPSBmb3JtYXR0ZXIucmVjdGFuZ2xlKHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5vZGUgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywgYXR0cnMsIGZvcm1hdHRlciksXG5cdFx0XHRcdHBhcmVudCA9IG5vZGU7XG5cdFx0XHRpZiAobWF0cml4ICYmICFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHRcdHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoU3ZnRWxlbWVudC5jcmVhdGUoJ2cnLFxuXHRcdFx0XHRcdFx0Z2V0VHJhbnNmb3JtKG1hdHJpeCksIGZvcm1hdHRlcikpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhjaGlsZHJlbltpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGRlZmluaXRpb25zID0ge30sXG5cdFx0cm9vdFNpemU7XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LFxuXHRcdFx0ZGVmYXVsdFZhbHVlKSB7XG5cdFx0dmFyIHZhbHVlID0gU3ZnRWxlbWVudC5nZXQobm9kZSwgbmFtZSkgfHwgZGVmYXVsdFZhbHVlLFxuXHRcdFx0cmVzID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmcgPyAnJyA6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdHJldHVybiAvJVxccyokLy50ZXN0KHZhbHVlKVxuXHRcdFx0PyAocmVzIC8gMTAwKSAqIChhbGxvd1BlcmNlbnQgPyAxXG5cdFx0XHRcdDogcm9vdFNpemVbL3h8XndpZHRoLy50ZXN0KG5hbWUpID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSlcblx0XHRcdDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRYLCBkZWZhdWx0WSkge1xuXHRcdHggPSBnZXRWYWx1ZShub2RlLCB4IHx8ICd4JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50LCBkZWZhdWx0WCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHkgfHwgJ3knLCBmYWxzZSwgYWxsb3dOdWxsLCBhbGxvd1BlcmNlbnQsIGRlZmF1bHRZKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KSB7XG5cdFx0dyA9IGdldFZhbHVlKG5vZGUsIHcgfHwgJ3dpZHRoJywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCB8fCAnaGVpZ2h0JywgZmFsc2UsIGFsbG93TnVsbCwgYWxsb3dQZXJjZW50KTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgU2l6ZSh3LCBoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbm9uZScgPyBudWxsXG5cdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheScgP1xuXHRcdFx0XHRcdHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW11cblx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InID8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWVcblx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJyA/IGxvb2t1cFt2YWx1ZV1cblx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpc0RlZnMgPSB0eXBlID09PSAnZGVmcycsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXAgJiYgIWlzRGVmcykge1xuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcblx0XHR9XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0dmFyIGRlZnMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2RlZnMnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZGVmcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0aW1wb3J0Tm9kZShkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmICEvXmRlZnMkL2kudGVzdChjaGlsZE5vZGUubm9kZU5hbWUpXG5cdFx0XHRcdFx0JiYgKGNoaWxkID0gaW1wb3J0Tm9kZShjaGlsZE5vZGUsIG9wdGlvbnMsIGZhbHNlKSlcblx0XHRcdFx0XHQmJiAhKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IGlzRGVmcykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0cmV0dXJuIFBhdGhJdGVtLmNyZWF0ZShub2RlLmdldEF0dHJpYnV0ZSgnZCcpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyYWRpZW50KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgaWQgPSAoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSB8fCAnJykuc3Vic3RyaW5nKDEpLFxuXHRcdFx0cmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsIF4gcmFkaWFsKSB7XG5cdFx0XHRcdGdyYWRpZW50ID0gZ3JhZGllbnQuY2xvbmUoKTtcblx0XHRcdFx0Z3JhZGllbnQuX3JhZGlhbCA9IHJhZGlhbDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgcmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCxcblx0XHRcdHNjYWxlVG9Cb3VuZHMgPSBnZXRWYWx1ZShub2RlLCAnZ3JhZGllbnRVbml0cycsIHRydWUpICE9PVxuXHRcdFx0XHQndXNlclNwYWNlT25Vc2UnO1xuXHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScsIGZhbHNlLCBzY2FsZVRvQm91bmRzLFxuXHRcdFx0XHQnNTAlJywgJzUwJScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKFxuXHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicsIGZhbHNlLCBmYWxzZSwgc2NhbGVUb0JvdW5kcywgJzUwJScpLCAwKTtcblx0XHRcdGhpZ2hsaWdodCA9IGdldFBvaW50KG5vZGUsICdmeCcsICdmeScsIHRydWUsIHNjYWxlVG9Cb3VuZHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcmlnaW4gPSBnZXRQb2ludChub2RlLCAneDEnLCAneTEnLCBmYWxzZSwgc2NhbGVUb0JvdW5kcyxcblx0XHRcdFx0JzAlJywgJzAlJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicsIGZhbHNlLCBzY2FsZVRvQm91bmRzLFxuXHRcdFx0XHQnMTAwJScsICcwJScpO1xuXHRcdH1cblx0XHR2YXIgY29sb3IgPSBhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRcdG5ldyBDb2xvcihncmFkaWVudCwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0KSwgbm9kZSk7XG5cdFx0Y29sb3IuX3NjYWxlVG9Cb3VuZHMgPSBzY2FsZVRvQm91bmRzO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRyZXR1cm4gaW1wb3J0Tm9kZShjaGlsZCwgb3B0aW9ucywgaXNSb290KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGc6IGltcG9ydEdyb3VwLFxuXHRcdHN2ZzogaW1wb3J0R3JvdXAsXG5cdFx0Y2xpcHBhdGg6IGltcG9ydEdyb3VwLFxuXHRcdHBvbHlnb246IGltcG9ydFBvbHksXG5cdFx0cG9seWxpbmU6IGltcG9ydFBvbHksXG5cdFx0cGF0aDogaW1wb3J0UGF0aCxcblx0XHRsaW5lYXJncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cdFx0cmFkaWFsZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXG5cdFx0aW1hZ2U6IGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpKTtcblx0XHRcdHJhc3Rlci5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IGdldFNpemUobm9kZSk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldFBvaW50KG5vZGUpLmFkZChzaXplLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHRoaXMuX21hdHJpeC5hcHBlbmQobmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sRGVmaW5pdGlvbihcblx0XHRcdFx0XHRpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbERlZmluaXRpb25cblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuUmVjdGFuZ2xlKG5ldyBSZWN0YW5nbGUoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlKSxcblx0XHRcdFx0XHRcdGdldFNpemUobm9kZSlcblx0XHRcdFx0XHQpLCBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpKTtcblx0XHRcdH0sXG5cblx0XHRsaW5lOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBhdGguTGluZShcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDEnLCAneTEnKSxcblx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneDInLCAneTInKSk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciB0ZXh0ID0gbmV3IFBvaW50VGV4dChnZXRQb2ludChub2RlKS5hZGQoXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9LFxuXG5cdFx0c3dpdGNoOiBpbXBvcnRHcm91cFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlKSB7XG5cdFx0aWYgKGl0ZW0udHJhbnNmb3JtKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcblx0XHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdFx0diA9IHBhcnRzWzFdLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0XHRtYXRyaXguYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0gfHwgMCwgdlsyXSB8fCAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0gfHwgMCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBrZXkgPSBuYW1lID09PSAnZmlsbC1vcGFjaXR5JyA/ICdnZXRGaWxsQ29sb3InIDogJ2dldFN0cm9rZUNvbG9yJyxcblx0XHRcdGNvbG9yID0gaXRlbVtrZXldICYmIGl0ZW1ba2V5XSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5zZXQoQmFzZS5lYWNoKFN2Z1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW1bZW50cnkuc2V0XSkge1xuXHRcdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRcdGlmIChlbnRyeS50eXBlID09PSAnY29sb3InKSB7XG5cdFx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdFx0aWYgKGNvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29sb3IuX3NjYWxlVG9Cb3VuZHMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGl0ZW0uZ2V0Qm91bmRzKCk7XG5cdFx0XHRcdFx0XHRcdGNvbG9yLnRyYW5zZm9ybShuZXcgTWF0cml4KClcblx0XHRcdFx0XHRcdFx0XHQudHJhbnNsYXRlKGJvdW5kcy5nZXRQb2ludCgpKVxuXHRcdFx0XHRcdFx0XHRcdC5zY2FsZShib3VuZHMuZ2V0U2l6ZSgpKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSwge30pLCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldFZpc2libGUpXG5cdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0ZGlzcGxheTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldFZpc2libGUpXG5cdFx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uc2V0T2Zmc2V0KSB7XG5cdFx0XHRcdHZhciBwZXJjZW50ID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuXHRcdFx0XHRpdGVtLnNldE9mZnNldChwZXJjZW50ID8gcGVyY2VudFsxXSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0dmlld0JveDogZnVuY3Rpb24oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuXHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCBudWxsLCBudWxsLCB0cnVlKSxcblx0XHRcdFx0Z3JvdXAsXG5cdFx0XHRcdG1hdHJpeDtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gc2l6ZSA/IHNpemUuZGl2aWRlKHJlY3QuZ2V0U2l6ZSgpKSA6IDEsXG5cdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSlcblx0XHRcdFx0XHRcdC50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpLm5lZ2F0ZSgpKTtcblx0XHRcdFx0Z3JvdXAgPSBpdGVtO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sRGVmaW5pdGlvbikge1xuXHRcdFx0XHRpZiAoc2l6ZSlcblx0XHRcdFx0XHRyZWN0LnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdGdyb3VwID0gaXRlbS5faXRlbTtcblx0XHRcdH1cblx0XHRcdGlmIChncm91cCkgIHtcblx0XHRcdFx0aWYgKGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9PSAndmlzaWJsZScpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCk7XG5cdFx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0XHRncm91cC5hZGRDaGlsZChjbGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWF0cml4KVxuXHRcdFx0XHRcdGdyb3VwLnRyYW5zZm9ybShtYXRyaXgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuXHRcdHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cdFx0aWYgKCF2YWx1ZSAmJiBub2RlLnN0eWxlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWUgPyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnID8gbnVsbFxuXHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG5cdFx0XHRzdHlsZXMgPSB7XG5cdFx0XHRcdG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuXHRcdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgIS9eZGVmcyQvaS50ZXN0KHBhcmVudC50YWdOYW1lKVxuXHRcdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRTdHlsZXMocGFyZW50KSB8fCB7fVxuXHRcdFx0fTtcblx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuXHRcdFx0aXRlbSA9IHZhbHVlICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQmJiBhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB8fCBpdGVtO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzpbXCInI10qKShbXlwiJyldKykvKSxcblx0XHRcdG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXSxcblx0XHRcdHJlcyA9IG5hbWUgJiYgZGVmaW5pdGlvbnNbd2luZG93XG5cdFx0XHRcdFx0PyBuYW1lLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVswXSArICcjJywgJycpXG5cdFx0XHRcdFx0OiBuYW1lXTtcblx0XHRpZiAocmVzICYmIHJlcy5fc2NhbGVUb0JvdW5kcykge1xuXHRcdFx0cmVzID0gcmVzLmNsb25lKCk7XG5cdFx0XHRyZXMuX3NjYWxlVG9Cb3VuZHMgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0Tm9kZShub2RlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGlzRWxlbWVudCA9IHR5cGUgIT09ICcjZG9jdW1lbnQnLFxuXHRcdFx0Ym9keSA9IGRvY3VtZW50LmJvZHksXG5cdFx0XHRjb250YWluZXIsXG5cdFx0XHRwYXJlbnQsXG5cdFx0XHRuZXh0O1xuXHRcdGlmIChpc1Jvb3QgJiYgaXNFbGVtZW50KSB7XG5cdFx0XHRyb290U2l6ZSA9IHBhcGVyLmdldFZpZXcoKS5nZXRTaXplKCk7XG5cdFx0XHRyb290U2l6ZSA9IGdldFNpemUobm9kZSwgbnVsbCwgbnVsbCwgdHJ1ZSkgfHwgcm9vdFNpemU7XG5cdFx0XHRjb250YWluZXIgPSBTdmdFbGVtZW50LmNyZWF0ZSgnc3ZnJywge1xuXHRcdFx0XHRzdHlsZTogJ3N0cm9rZS13aWR0aDogMXB4OyBzdHJva2UtbWl0ZXJsaW1pdDogMTAnXG5cdFx0XHR9KTtcblx0XHRcdHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXHRcdH1cblx0XHR2YXIgc2V0dGluZ3MgPSBwYXBlci5zZXR0aW5ncyxcblx0XHRcdGFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXgsXG5cdFx0XHRpbnNlcnRJdGVtcyA9IHNldHRpbmdzLmluc2VydEl0ZW1zO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0c2V0dGluZ3MuaW5zZXJ0SXRlbXMgPSBmYWxzZTtcblx0XHR2YXIgaW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuXHRcdHNldHRpbmdzLmluc2VydEl0ZW1zID0gaW5zZXJ0SXRlbXM7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKGlzRWxlbWVudCAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHZhciBvbkltcG9ydCA9IG9wdGlvbnMub25JbXBvcnQsXG5cdFx0XHRcdGRhdGEgPSBpc0VsZW1lbnQgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpO1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChjb250YWluZXIpIHtcblx0XHRcdGJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgb3duZXIpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHsgb25Mb2FkOiBvcHRpb25zIH1cblx0XHRcdFx0OiBvcHRpb25zIHx8IHt9O1xuXHRcdHZhciBzY29wZSA9IHBhcGVyLFxuXHRcdFx0aXRlbSA9IG51bGw7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWQoc3ZnKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBzdmcgPT09ICdvYmplY3QnID8gc3ZnIDogbmV3IHNlbGYuRE9NUGFyc2VyKClcblx0XHRcdFx0XHRcdC5wYXJzZUZyb21TdHJpbmcoc3ZnLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXHRcdFx0XHRpZiAoIW5vZGUubm9kZU5hbWUpIHtcblx0XHRcdFx0XHRub2RlID0gbnVsbDtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHRcdGl0ZW0gPSBpbXBvcnROb2RlKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXHRcdFx0XHRpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5pbnNlcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3duZXIuX2luc2VydEl0ZW0odW5kZWZpbmVkLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgb25Mb2FkID0gb3B0aW9ucy5vbkxvYWQ7XG5cdFx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdFx0b25Mb2FkKGl0ZW0sIHN2Zyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9uRXJyb3IoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25FcnJvcihtZXNzYWdlLCBzdGF0dXMpIHtcblx0XHRcdHZhciBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yO1xuXHRcdFx0aWYgKG9uRXJyb3IpIHtcblx0XHRcdFx0b25FcnJvcihtZXNzYWdlLCBzdGF0dXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0b25Mb2FkKG5vZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0SHR0cC5yZXF1ZXN0KHtcblx0XHRcdFx0XHR1cmw6IHNvdXJjZSxcblx0XHRcdFx0XHRhc3luYzogdHJ1ZSxcblx0XHRcdFx0XHRvbkxvYWQ6IG9uTG9hZCxcblx0XHRcdFx0XHRvbkVycm9yOiBvbkVycm9yXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRvbkxvYWQocmVhZGVyLnJlc3VsdCk7XG5cdFx0XHR9O1xuXHRcdFx0cmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0b25FcnJvcihyZWFkZXIuZXJyb3IpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvbkxvYWQoc291cmNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdGhpcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRoaXMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5CYXNlLmV4cG9ydHMuUGFwZXJTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGdsb2JhbCA9IHRoaXMsXG5cdFx0YWNvcm4gPSBnbG9iYWwuYWNvcm47XG5cdGlmICghYWNvcm4gJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dHJ5IHsgYWNvcm4gPSByZXF1aXJlKCdhY29ybicpOyB9IGNhdGNoKGUpIHt9XG5cdH1cblx0aWYgKCFhY29ybikge1xuXHRcdHZhciBleHBvcnRzLCBtb2R1bGU7XG5cdFx0YWNvcm4gPSBleHBvcnRzID0gbW9kdWxlID0ge307XG5cbihmdW5jdGlvbihyb290LCBtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSByZXR1cm4gbW9kKGV4cG9ydHMpO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgcmV0dXJuIGRlZmluZShbXCJleHBvcnRzXCJdLCBtb2QpO1xuICBtb2Qocm9vdC5hY29ybiB8fCAocm9vdC5hY29ybiA9IHt9KSk7XG59KSh0aGlzLCBmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9IFwiMC41LjBcIjtcblxuICB2YXIgb3B0aW9ucywgaW5wdXQsIGlucHV0TGVuLCBzb3VyY2VGaWxlO1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihpbnB0LCBvcHRzKSB7XG5cdGlucHV0ID0gU3RyaW5nKGlucHQpOyBpbnB1dExlbiA9IGlucHV0Lmxlbmd0aDtcblx0c2V0T3B0aW9ucyhvcHRzKTtcblx0aW5pdFRva2VuU3RhdGUoKTtcblx0cmV0dXJuIHBhcnNlVG9wTGV2ZWwob3B0aW9ucy5wcm9ncmFtKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0ge1xuXHRlY21hVmVyc2lvbjogNSxcblx0c3RyaWN0U2VtaWNvbG9uczogZmFsc2UsXG5cdGFsbG93VHJhaWxpbmdDb21tYXM6IHRydWUsXG5cdGZvcmJpZFJlc2VydmVkOiBmYWxzZSxcblx0YWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuXHRsb2NhdGlvbnM6IGZhbHNlLFxuXHRvbkNvbW1lbnQ6IG51bGwsXG5cdHJhbmdlczogZmFsc2UsXG5cdHByb2dyYW06IG51bGwsXG5cdHNvdXJjZUZpbGU6IG51bGwsXG5cdGRpcmVjdFNvdXJjZUZpbGU6IG51bGxcbiAgfTtcblxuICBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdHMpIHtcblx0b3B0aW9ucyA9IG9wdHMgfHwge307XG5cdGZvciAodmFyIG9wdCBpbiBkZWZhdWx0T3B0aW9ucykgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0KSlcblx0ICBvcHRpb25zW29wdF0gPSBkZWZhdWx0T3B0aW9uc1tvcHRdO1xuXHRzb3VyY2VGaWxlID0gb3B0aW9ucy5zb3VyY2VGaWxlIHx8IG51bGw7XG4gIH1cblxuICB2YXIgZ2V0TGluZUluZm8gPSBleHBvcnRzLmdldExpbmVJbmZvID0gZnVuY3Rpb24oaW5wdXQsIG9mZnNldCkge1xuXHRmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG5cdCAgbGluZUJyZWFrLmxhc3RJbmRleCA9IGN1cjtcblx0ICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCk7XG5cdCAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4IDwgb2Zmc2V0KSB7XG5cdFx0KytsaW5lO1xuXHRcdGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHQgIH0gZWxzZSBicmVhaztcblx0fVxuXHRyZXR1cm4ge2xpbmU6IGxpbmUsIGNvbHVtbjogb2Zmc2V0IC0gY3VyfTtcbiAgfTtcblxuICBleHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24oaW5wdCwgb3B0cykge1xuXHRpbnB1dCA9IFN0cmluZyhpbnB0KTsgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGg7XG5cdHNldE9wdGlvbnMob3B0cyk7XG5cdGluaXRUb2tlblN0YXRlKCk7XG5cblx0dmFyIHQgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0VG9rZW4oZm9yY2VSZWdleHApIHtcblx0ICBsYXN0RW5kID0gdG9rRW5kO1xuXHQgIHJlYWRUb2tlbihmb3JjZVJlZ2V4cCk7XG5cdCAgdC5zdGFydCA9IHRva1N0YXJ0OyB0LmVuZCA9IHRva0VuZDtcblx0ICB0LnN0YXJ0TG9jID0gdG9rU3RhcnRMb2M7IHQuZW5kTG9jID0gdG9rRW5kTG9jO1xuXHQgIHQudHlwZSA9IHRva1R5cGU7IHQudmFsdWUgPSB0b2tWYWw7XG5cdCAgcmV0dXJuIHQ7XG5cdH1cblx0Z2V0VG9rZW4uanVtcFRvID0gZnVuY3Rpb24ocG9zLCByZUFsbG93ZWQpIHtcblx0ICB0b2tQb3MgPSBwb3M7XG5cdCAgaWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdFx0dG9rQ3VyTGluZSA9IDE7XG5cdFx0dG9rTGluZVN0YXJ0ID0gbGluZUJyZWFrLmxhc3RJbmRleCA9IDA7XG5cdFx0dmFyIG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgcG9zKSB7XG5cdFx0ICArK3Rva0N1ckxpbmU7XG5cdFx0ICB0b2tMaW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9XG5cdCAgfVxuXHQgIHRva1JlZ2V4cEFsbG93ZWQgPSByZUFsbG93ZWQ7XG5cdCAgc2tpcFNwYWNlKCk7XG5cdH07XG5cdHJldHVybiBnZXRUb2tlbjtcbiAgfTtcblxuICB2YXIgdG9rUG9zO1xuXG4gIHZhciB0b2tTdGFydCwgdG9rRW5kO1xuXG4gIHZhciB0b2tTdGFydExvYywgdG9rRW5kTG9jO1xuXG4gIHZhciB0b2tUeXBlLCB0b2tWYWw7XG5cbiAgdmFyIHRva1JlZ2V4cEFsbG93ZWQ7XG5cbiAgdmFyIHRva0N1ckxpbmUsIHRva0xpbmVTdGFydDtcblxuICB2YXIgbGFzdFN0YXJ0LCBsYXN0RW5kLCBsYXN0RW5kTG9jO1xuXG4gIHZhciBpbkZ1bmN0aW9uLCBsYWJlbHMsIHN0cmljdDtcblxuICBmdW5jdGlvbiByYWlzZShwb3MsIG1lc3NhZ2UpIHtcblx0dmFyIGxvYyA9IGdldExpbmVJbmZvKGlucHV0LCBwb3MpO1xuXHRtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCI7XG5cdHZhciBlcnIgPSBuZXcgU3ludGF4RXJyb3IobWVzc2FnZSk7XG5cdGVyci5wb3MgPSBwb3M7IGVyci5sb2MgPSBsb2M7IGVyci5yYWlzZWRBdCA9IHRva1Bvcztcblx0dGhyb3cgZXJyO1xuICB9XG5cbiAgdmFyIGVtcHR5ID0gW107XG5cbiAgdmFyIF9udW0gPSB7dHlwZTogXCJudW1cIn0sIF9yZWdleHAgPSB7dHlwZTogXCJyZWdleHBcIn0sIF9zdHJpbmcgPSB7dHlwZTogXCJzdHJpbmdcIn07XG4gIHZhciBfbmFtZSA9IHt0eXBlOiBcIm5hbWVcIn0sIF9lb2YgPSB7dHlwZTogXCJlb2ZcIn07XG5cbiAgdmFyIF9icmVhayA9IHtrZXl3b3JkOiBcImJyZWFrXCJ9LCBfY2FzZSA9IHtrZXl3b3JkOiBcImNhc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9jYXRjaCA9IHtrZXl3b3JkOiBcImNhdGNoXCJ9O1xuICB2YXIgX2NvbnRpbnVlID0ge2tleXdvcmQ6IFwiY29udGludWVcIn0sIF9kZWJ1Z2dlciA9IHtrZXl3b3JkOiBcImRlYnVnZ2VyXCJ9LCBfZGVmYXVsdCA9IHtrZXl3b3JkOiBcImRlZmF1bHRcIn07XG4gIHZhciBfZG8gPSB7a2V5d29yZDogXCJkb1wiLCBpc0xvb3A6IHRydWV9LCBfZWxzZSA9IHtrZXl3b3JkOiBcImVsc2VcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZmluYWxseSA9IHtrZXl3b3JkOiBcImZpbmFsbHlcIn0sIF9mb3IgPSB7a2V5d29yZDogXCJmb3JcIiwgaXNMb29wOiB0cnVlfSwgX2Z1bmN0aW9uID0ge2tleXdvcmQ6IFwiZnVuY3Rpb25cIn07XG4gIHZhciBfaWYgPSB7a2V5d29yZDogXCJpZlwifSwgX3JldHVybiA9IHtrZXl3b3JkOiBcInJldHVyblwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3N3aXRjaCA9IHtrZXl3b3JkOiBcInN3aXRjaFwifTtcbiAgdmFyIF90aHJvdyA9IHtrZXl3b3JkOiBcInRocm93XCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfdHJ5ID0ge2tleXdvcmQ6IFwidHJ5XCJ9LCBfdmFyID0ge2tleXdvcmQ6IFwidmFyXCJ9O1xuICB2YXIgX3doaWxlID0ge2tleXdvcmQ6IFwid2hpbGVcIiwgaXNMb29wOiB0cnVlfSwgX3dpdGggPSB7a2V5d29yZDogXCJ3aXRoXCJ9LCBfbmV3ID0ge2tleXdvcmQ6IFwibmV3XCIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3RoaXMgPSB7a2V5d29yZDogXCJ0aGlzXCJ9O1xuXG4gIHZhciBfbnVsbCA9IHtrZXl3b3JkOiBcIm51bGxcIiwgYXRvbVZhbHVlOiBudWxsfSwgX3RydWUgPSB7a2V5d29yZDogXCJ0cnVlXCIsIGF0b21WYWx1ZTogdHJ1ZX07XG4gIHZhciBfZmFsc2UgPSB7a2V5d29yZDogXCJmYWxzZVwiLCBhdG9tVmFsdWU6IGZhbHNlfTtcblxuICB2YXIgX2luID0ge2tleXdvcmQ6IFwiaW5cIiwgYmlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9O1xuXG4gIHZhciBrZXl3b3JkVHlwZXMgPSB7XCJicmVha1wiOiBfYnJlYWssIFwiY2FzZVwiOiBfY2FzZSwgXCJjYXRjaFwiOiBfY2F0Y2gsXG5cdFx0XHRcdFx0ICBcImNvbnRpbnVlXCI6IF9jb250aW51ZSwgXCJkZWJ1Z2dlclwiOiBfZGVidWdnZXIsIFwiZGVmYXVsdFwiOiBfZGVmYXVsdCxcblx0XHRcdFx0XHQgIFwiZG9cIjogX2RvLCBcImVsc2VcIjogX2Vsc2UsIFwiZmluYWxseVwiOiBfZmluYWxseSwgXCJmb3JcIjogX2Zvcixcblx0XHRcdFx0XHQgIFwiZnVuY3Rpb25cIjogX2Z1bmN0aW9uLCBcImlmXCI6IF9pZiwgXCJyZXR1cm5cIjogX3JldHVybiwgXCJzd2l0Y2hcIjogX3N3aXRjaCxcblx0XHRcdFx0XHQgIFwidGhyb3dcIjogX3Rocm93LCBcInRyeVwiOiBfdHJ5LCBcInZhclwiOiBfdmFyLCBcIndoaWxlXCI6IF93aGlsZSwgXCJ3aXRoXCI6IF93aXRoLFxuXHRcdFx0XHRcdCAgXCJudWxsXCI6IF9udWxsLCBcInRydWVcIjogX3RydWUsIFwiZmFsc2VcIjogX2ZhbHNlLCBcIm5ld1wiOiBfbmV3LCBcImluXCI6IF9pbixcblx0XHRcdFx0XHQgIFwiaW5zdGFuY2VvZlwiOiB7a2V5d29yZDogXCJpbnN0YW5jZW9mXCIsIGJpbm9wOiA3LCBiZWZvcmVFeHByOiB0cnVlfSwgXCJ0aGlzXCI6IF90aGlzLFxuXHRcdFx0XHRcdCAgXCJ0eXBlb2ZcIjoge2tleXdvcmQ6IFwidHlwZW9mXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX0sXG5cdFx0XHRcdFx0ICBcInZvaWRcIjoge2tleXdvcmQ6IFwidm9pZFwiLCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9LFxuXHRcdFx0XHRcdCAgXCJkZWxldGVcIjoge2tleXdvcmQ6IFwiZGVsZXRlXCIsIHByZWZpeDogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX19O1xuXG4gIHZhciBfYnJhY2tldEwgPSB7dHlwZTogXCJbXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfYnJhY2tldFIgPSB7dHlwZTogXCJdXCJ9LCBfYnJhY2VMID0ge3R5cGU6IFwie1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9icmFjZVIgPSB7dHlwZTogXCJ9XCJ9LCBfcGFyZW5MID0ge3R5cGU6IFwiKFwiLCBiZWZvcmVFeHByOiB0cnVlfSwgX3BhcmVuUiA9IHt0eXBlOiBcIilcIn07XG4gIHZhciBfY29tbWEgPSB7dHlwZTogXCIsXCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfc2VtaSA9IHt0eXBlOiBcIjtcIiwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfY29sb24gPSB7dHlwZTogXCI6XCIsIGJlZm9yZUV4cHI6IHRydWV9LCBfZG90ID0ge3R5cGU6IFwiLlwifSwgX3F1ZXN0aW9uID0ge3R5cGU6IFwiP1wiLCBiZWZvcmVFeHByOiB0cnVlfTtcblxuICB2YXIgX3NsYXNoID0ge2Jpbm9wOiAxMCwgYmVmb3JlRXhwcjogdHJ1ZX0sIF9lcSA9IHtpc0Fzc2lnbjogdHJ1ZSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYXNzaWduID0ge2lzQXNzaWduOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9pbmNEZWMgPSB7cG9zdGZpeDogdHJ1ZSwgcHJlZml4OiB0cnVlLCBpc1VwZGF0ZTogdHJ1ZX0sIF9wcmVmaXggPSB7cHJlZml4OiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9sb2dpY2FsT1IgPSB7Ymlub3A6IDEsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2xvZ2ljYWxBTkQgPSB7Ymlub3A6IDIsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdHdpc2VPUiA9IHtiaW5vcDogMywgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZVhPUiA9IHtiaW5vcDogNCwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfYml0d2lzZUFORCA9IHtiaW5vcDogNSwgYmVmb3JlRXhwcjogdHJ1ZX07XG4gIHZhciBfZXF1YWxpdHkgPSB7Ymlub3A6IDYsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX3JlbGF0aW9uYWwgPSB7Ymlub3A6IDcsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX2JpdFNoaWZ0ID0ge2Jpbm9wOiA4LCBiZWZvcmVFeHByOiB0cnVlfTtcbiAgdmFyIF9wbHVzTWluID0ge2Jpbm9wOiA5LCBwcmVmaXg6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgX211bHRpcGx5TW9kdWxvID0ge2Jpbm9wOiAxMCwgYmVmb3JlRXhwcjogdHJ1ZX07XG5cbiAgZXhwb3J0cy50b2tUeXBlcyA9IHticmFja2V0TDogX2JyYWNrZXRMLCBicmFja2V0UjogX2JyYWNrZXRSLCBicmFjZUw6IF9icmFjZUwsIGJyYWNlUjogX2JyYWNlUixcblx0XHRcdFx0XHQgIHBhcmVuTDogX3BhcmVuTCwgcGFyZW5SOiBfcGFyZW5SLCBjb21tYTogX2NvbW1hLCBzZW1pOiBfc2VtaSwgY29sb246IF9jb2xvbixcblx0XHRcdFx0XHQgIGRvdDogX2RvdCwgcXVlc3Rpb246IF9xdWVzdGlvbiwgc2xhc2g6IF9zbGFzaCwgZXE6IF9lcSwgbmFtZTogX25hbWUsIGVvZjogX2VvZixcblx0XHRcdFx0XHQgIG51bTogX251bSwgcmVnZXhwOiBfcmVnZXhwLCBzdHJpbmc6IF9zdHJpbmd9O1xuICBmb3IgKHZhciBrdyBpbiBrZXl3b3JkVHlwZXMpIGV4cG9ydHMudG9rVHlwZXNbXCJfXCIgKyBrd10gPSBrZXl3b3JkVHlwZXNba3ddO1xuXG4gIGZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUod29yZHMpIHtcblx0d29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG5cdHZhciBmID0gXCJcIiwgY2F0cyA9IFtdO1xuXHRvdXQ6IGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcblx0ICBmb3IgKHZhciBqID0gMDsgaiA8IGNhdHMubGVuZ3RoOyArK2opXG5cdFx0aWYgKGNhdHNbal1bMF0ubGVuZ3RoID09IHdvcmRzW2ldLmxlbmd0aCkge1xuXHRcdCAgY2F0c1tqXS5wdXNoKHdvcmRzW2ldKTtcblx0XHQgIGNvbnRpbnVlIG91dDtcblx0XHR9XG5cdCAgY2F0cy5wdXNoKFt3b3Jkc1tpXV0pO1xuXHR9XG5cdGZ1bmN0aW9uIGNvbXBhcmVUbyhhcnIpIHtcblx0ICBpZiAoYXJyLmxlbmd0aCA9PSAxKSByZXR1cm4gZiArPSBcInJldHVybiBzdHIgPT09IFwiICsgSlNPTi5zdHJpbmdpZnkoYXJyWzBdKSArIFwiO1wiO1xuXHQgIGYgKz0gXCJzd2l0Y2goc3RyKXtcIjtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgZiArPSBcImNhc2UgXCIgKyBKU09OLnN0cmluZ2lmeShhcnJbaV0pICsgXCI6XCI7XG5cdCAgZiArPSBcInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcIjtcblx0fVxuXG5cdGlmIChjYXRzLmxlbmd0aCA+IDMpIHtcblx0ICBjYXRzLnNvcnQoZnVuY3Rpb24oYSwgYikge3JldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO30pO1xuXHQgIGYgKz0gXCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYXRzLmxlbmd0aDsgKytpKSB7XG5cdFx0dmFyIGNhdCA9IGNhdHNbaV07XG5cdFx0ZiArPSBcImNhc2UgXCIgKyBjYXRbMF0ubGVuZ3RoICsgXCI6XCI7XG5cdFx0Y29tcGFyZVRvKGNhdCk7XG5cdCAgfVxuXHQgIGYgKz0gXCJ9XCI7XG5cblx0fSBlbHNlIHtcblx0ICBjb21wYXJlVG8od29yZHMpO1xuXHR9XG5cdHJldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIiwgZik7XG4gIH1cblxuICB2YXIgaXNSZXNlcnZlZFdvcmQzID0gbWFrZVByZWRpY2F0ZShcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIik7XG5cbiAgdmFyIGlzUmVzZXJ2ZWRXb3JkNSA9IG1ha2VQcmVkaWNhdGUoXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiKTtcblxuICB2YXIgaXNTdHJpY3RSZXNlcnZlZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKTtcblxuICB2YXIgaXNTdHJpY3RCYWRJZFdvcmQgPSBtYWtlUHJlZGljYXRlKFwiZXZhbCBhcmd1bWVudHNcIik7XG5cbiAgdmFyIGlzS2V5d29yZCA9IG1ha2VQcmVkaWNhdGUoXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIik7XG5cbiAgdmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG4gIHZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxuICB2YXIgbmV3bGluZSA9IC9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcblxuICB2YXIgbGluZUJyZWFrID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2c7XG5cbiAgdmFyIGlzSWRlbnRpZmllclN0YXJ0ID0gZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGZ1bmN0aW9uKGNvZGUpIHtcblx0aWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2O1xuXHRpZiAoY29kZSA8IDkxKSByZXR1cm4gdHJ1ZTtcblx0aWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuXHRpZiAoY29kZSA8IDEyMylyZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9O1xuXG4gIHZhciBpc0lkZW50aWZpZXJDaGFyID0gZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gZnVuY3Rpb24oY29kZSkge1xuXHRpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzY7XG5cdGlmIChjb2RlIDwgNTgpIHJldHVybiB0cnVlO1xuXHRpZiAoY29kZSA8IDY1KSByZXR1cm4gZmFsc2U7XG5cdGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlO1xuXHRpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG5cdGlmIChjb2RlIDwgMTIzKXJldHVybiB0cnVlO1xuXHRyZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGxpbmVfbG9jX3QoKSB7XG5cdHRoaXMubGluZSA9IHRva0N1ckxpbmU7XG5cdHRoaXMuY29sdW1uID0gdG9rUG9zIC0gdG9rTGluZVN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFRva2VuU3RhdGUoKSB7XG5cdHRva0N1ckxpbmUgPSAxO1xuXHR0b2tQb3MgPSB0b2tMaW5lU3RhcnQgPSAwO1xuXHR0b2tSZWdleHBBbGxvd2VkID0gdHJ1ZTtcblx0c2tpcFNwYWNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcblx0dG9rRW5kID0gdG9rUG9zO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva0VuZExvYyA9IG5ldyBsaW5lX2xvY190O1xuXHR0b2tUeXBlID0gdHlwZTtcblx0c2tpcFNwYWNlKCk7XG5cdHRva1ZhbCA9IHZhbDtcblx0dG9rUmVnZXhwQWxsb3dlZCA9IHR5cGUuYmVmb3JlRXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBCbG9ja0NvbW1lbnQoKSB7XG5cdHZhciBzdGFydExvYyA9IG9wdGlvbnMub25Db21tZW50ICYmIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190O1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIGVuZCA9IGlucHV0LmluZGV4T2YoXCIqL1wiLCB0b2tQb3MgKz0gMik7XG5cdGlmIChlbmQgPT09IC0xKSByYWlzZSh0b2tQb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpO1xuXHR0b2tQb3MgPSBlbmQgKyAyO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHtcblx0ICBsaW5lQnJlYWsubGFzdEluZGV4ID0gc3RhcnQ7XG5cdCAgdmFyIG1hdGNoO1xuXHQgIHdoaWxlICgobWF0Y2ggPSBsaW5lQnJlYWsuZXhlYyhpbnB1dCkpICYmIG1hdGNoLmluZGV4IDwgdG9rUG9zKSB7XG5cdFx0Kyt0b2tDdXJMaW5lO1xuXHRcdHRva0xpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHQgIH1cblx0fVxuXHRpZiAob3B0aW9ucy5vbkNvbW1lbnQpXG5cdCAgb3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQpLCBzdGFydCwgdG9rUG9zLFxuXHRcdFx0XHRcdFx0c3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBMaW5lQ29tbWVudCgpIHtcblx0dmFyIHN0YXJ0ID0gdG9rUG9zO1xuXHR2YXIgc3RhcnRMb2MgPSBvcHRpb25zLm9uQ29tbWVudCAmJiBvcHRpb25zLmxvY2F0aW9ucyAmJiBuZXcgbGluZV9sb2NfdDtcblx0dmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MrPTIpO1xuXHR3aGlsZSAodG9rUG9zIDwgaW5wdXRMZW4gJiYgY2ggIT09IDEwICYmIGNoICE9PSAxMyAmJiBjaCAhPT0gODIzMiAmJiBjaCAhPT0gODIzMykge1xuXHQgICsrdG9rUG9zO1xuXHQgIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHR9XG5cdGlmIChvcHRpb25zLm9uQ29tbWVudClcblx0ICBvcHRpb25zLm9uQ29tbWVudChmYWxzZSwgaW5wdXQuc2xpY2Uoc3RhcnQgKyAyLCB0b2tQb3MpLCBzdGFydCwgdG9rUG9zLFxuXHRcdFx0XHRcdFx0c3RhcnRMb2MsIG9wdGlvbnMubG9jYXRpb25zICYmIG5ldyBsaW5lX2xvY190KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBTcGFjZSgpIHtcblx0d2hpbGUgKHRva1BvcyA8IGlucHV0TGVuKSB7XG5cdCAgdmFyIGNoID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHQgIGlmIChjaCA9PT0gMzIpIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2UgaWYgKGNoID09PSAxMykge1xuXHRcdCsrdG9rUG9zO1xuXHRcdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRcdGlmIChuZXh0ID09PSAxMCkge1xuXHRcdCAgKyt0b2tQb3M7XG5cdFx0fVxuXHRcdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdCAgKyt0b2tDdXJMaW5lO1xuXHRcdCAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuXHRcdH1cblx0ICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuXHRcdCsrdG9rUG9zO1xuXHRcdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdCAgKyt0b2tDdXJMaW5lO1xuXHRcdCAgdG9rTGluZVN0YXJ0ID0gdG9rUG9zO1xuXHRcdH1cblx0ICB9IGVsc2UgaWYgKGNoID4gOCAmJiBjaCA8IDE0KSB7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfSBlbHNlIGlmIChjaCA9PT0gNDcpIHtcblx0XHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdFx0aWYgKG5leHQgPT09IDQyKSB7XG5cdFx0ICBza2lwQmxvY2tDb21tZW50KCk7XG5cdFx0fSBlbHNlIGlmIChuZXh0ID09PSA0Nykge1xuXHRcdCAgc2tpcExpbmVDb21tZW50KCk7XG5cdFx0fSBlbHNlIGJyZWFrO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDE2MCkge1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcblx0XHQrK3Rva1Bvcztcblx0ICB9IGVsc2Uge1xuXHRcdGJyZWFrO1xuXHQgIH1cblx0fVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX2RvdCgpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSByZXR1cm4gcmVhZE51bWJlcih0cnVlKTtcblx0Kyt0b2tQb3M7XG5cdHJldHVybiBmaW5pc2hUb2tlbihfZG90KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9zbGFzaCgpIHtcblx0dmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHRpZiAodG9rUmVnZXhwQWxsb3dlZCkgeysrdG9rUG9zOyByZXR1cm4gcmVhZFJlZ2V4cCgpO31cblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfc2xhc2gsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFRva2VuX211bHRfbW9kdWxvKCkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSA2MSkgcmV0dXJuIGZpbmlzaE9wKF9hc3NpZ24sIDIpO1xuXHRyZXR1cm4gZmluaXNoT3AoX211bHRpcGx5TW9kdWxvLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbl9waXBlX2FtcChjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IGNvZGUpIHJldHVybiBmaW5pc2hPcChjb2RlID09PSAxMjQgPyBfbG9naWNhbE9SIDogX2xvZ2ljYWxBTkQsIDIpO1xuXHRpZiAobmV4dCA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IF9iaXR3aXNlT1IgOiBfYml0d2lzZUFORCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fY2FyZXQoKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfYml0d2lzZVhPUiwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdGlmIChuZXh0ID09PSBjb2RlKSB7XG5cdCAgaWYgKG5leHQgPT0gNDUgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PSA2MiAmJlxuXHRcdCAgbmV3bGluZS50ZXN0KGlucHV0LnNsaWNlKGxhc3RFbmQsIHRva1BvcykpKSB7XG5cdFx0dG9rUG9zICs9IDM7XG5cdFx0c2tpcExpbmVDb21tZW50KCk7XG5cdFx0c2tpcFNwYWNlKCk7XG5cdFx0cmV0dXJuIHJlYWRUb2tlbigpO1xuXHQgIH1cblx0ICByZXR1cm4gZmluaXNoT3AoX2luY0RlYywgMik7XG5cdH1cblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2Fzc2lnbiwgMik7XG5cdHJldHVybiBmaW5pc2hPcChfcGx1c01pbiwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fbHRfZ3QoY29kZSkge1xuXHR2YXIgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMSk7XG5cdHZhciBzaXplID0gMTtcblx0aWYgKG5leHQgPT09IGNvZGUpIHtcblx0ICBzaXplID0gY29kZSA9PT0gNjIgJiYgaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAyKSA9PT0gNjIgPyAzIDogMjtcblx0ICBpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyBzaXplKSA9PT0gNjEpIHJldHVybiBmaW5pc2hPcChfYXNzaWduLCBzaXplICsgMSk7XG5cdCAgcmV0dXJuIGZpbmlzaE9wKF9iaXRTaGlmdCwgc2l6ZSk7XG5cdH1cblx0aWYgKG5leHQgPT0gMzMgJiYgY29kZSA9PSA2MCAmJiBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09IDQ1ICYmXG5cdFx0aW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAzKSA9PSA0NSkge1xuXHQgIHRva1BvcyArPSA0O1xuXHQgIHNraXBMaW5lQ29tbWVudCgpO1xuXHQgIHNraXBTcGFjZSgpO1xuXHQgIHJldHVybiByZWFkVG9rZW4oKTtcblx0fVxuXHRpZiAobmV4dCA9PT0gNjEpXG5cdCAgc2l6ZSA9IGlucHV0LmNoYXJDb2RlQXQodG9rUG9zICsgMikgPT09IDYxID8gMyA6IDI7XG5cdHJldHVybiBmaW5pc2hPcChfcmVsYXRpb25hbCwgc2l6ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKSB7XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MgKyAxKTtcblx0aWYgKG5leHQgPT09IDYxKSByZXR1cm4gZmluaXNoT3AoX2VxdWFsaXR5LCBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcblx0cmV0dXJuIGZpbmlzaE9wKGNvZGUgPT09IDYxID8gX2VxIDogX3ByZWZpeCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcblx0c3dpdGNoKGNvZGUpIHtcblx0Y2FzZSA0Njpcblx0ICByZXR1cm4gcmVhZFRva2VuX2RvdCgpO1xuXG5cdGNhc2UgNDA6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuTCk7XG5cdGNhc2UgNDE6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3BhcmVuUik7XG5cdGNhc2UgNTk6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX3NlbWkpO1xuXHRjYXNlIDQ0OiArK3Rva1BvczsgcmV0dXJuIGZpbmlzaFRva2VuKF9jb21tYSk7XG5cdGNhc2UgOTE6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNrZXRMKTtcblx0Y2FzZSA5MzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2tldFIpO1xuXHRjYXNlIDEyMzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfYnJhY2VMKTtcblx0Y2FzZSAxMjU6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2JyYWNlUik7XG5cdGNhc2UgNTg6ICsrdG9rUG9zOyByZXR1cm4gZmluaXNoVG9rZW4oX2NvbG9uKTtcblx0Y2FzZSA2MzogKyt0b2tQb3M7IHJldHVybiBmaW5pc2hUb2tlbihfcXVlc3Rpb24pO1xuXG5cdGNhc2UgNDg6XG5cdCAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyArIDEpO1xuXHQgIGlmIChuZXh0ID09PSAxMjAgfHwgbmV4dCA9PT0gODgpIHJldHVybiByZWFkSGV4TnVtYmVyKCk7XG5cdGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6XG5cdCAgcmV0dXJuIHJlYWROdW1iZXIoZmFsc2UpO1xuXG5cdGNhc2UgMzQ6IGNhc2UgMzk6XG5cdCAgcmV0dXJuIHJlYWRTdHJpbmcoY29kZSk7XG5cblx0Y2FzZSA0Nzpcblx0ICByZXR1cm4gcmVhZFRva2VuX3NsYXNoKGNvZGUpO1xuXG5cdGNhc2UgMzc6IGNhc2UgNDI6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9tdWx0X21vZHVsbygpO1xuXG5cdGNhc2UgMTI0OiBjYXNlIDM4OlxuXHQgIHJldHVybiByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG5cblx0Y2FzZSA5NDpcblx0ICByZXR1cm4gcmVhZFRva2VuX2NhcmV0KCk7XG5cblx0Y2FzZSA0MzogY2FzZSA0NTpcblx0ICByZXR1cm4gcmVhZFRva2VuX3BsdXNfbWluKGNvZGUpO1xuXG5cdGNhc2UgNjA6IGNhc2UgNjI6XG5cdCAgcmV0dXJuIHJlYWRUb2tlbl9sdF9ndChjb2RlKTtcblxuXHRjYXNlIDYxOiBjYXNlIDMzOlxuXHQgIHJldHVybiByZWFkVG9rZW5fZXFfZXhjbChjb2RlKTtcblxuXHRjYXNlIDEyNjpcblx0ICByZXR1cm4gZmluaXNoT3AoX3ByZWZpeCwgMSk7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiByZWFkVG9rZW4oZm9yY2VSZWdleHApIHtcblx0aWYgKCFmb3JjZVJlZ2V4cCkgdG9rU3RhcnQgPSB0b2tQb3M7XG5cdGVsc2UgdG9rUG9zID0gdG9rU3RhcnQgKyAxO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHRva1N0YXJ0TG9jID0gbmV3IGxpbmVfbG9jX3Q7XG5cdGlmIChmb3JjZVJlZ2V4cCkgcmV0dXJuIHJlYWRSZWdleHAoKTtcblx0aWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmV0dXJuIGZpbmlzaFRva2VuKF9lb2YpO1xuXG5cdHZhciBjb2RlID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkgfHwgY29kZSA9PT0gOTIgKSByZXR1cm4gcmVhZFdvcmQoKTtcblxuXHR2YXIgdG9rID0gZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcblxuXHRpZiAodG9rID09PSBmYWxzZSkge1xuXHQgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cdCAgaWYgKGNoID09PSBcIlxcXFxcIiB8fCBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KGNoKSkgcmV0dXJuIHJlYWRXb3JkKCk7XG5cdCAgcmFpc2UodG9rUG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInXCIpO1xuXHR9XG5cdHJldHVybiB0b2s7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG5cdHZhciBzdHIgPSBpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIHNpemUpO1xuXHR0b2tQb3MgKz0gc2l6ZTtcblx0ZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRSZWdleHAoKSB7XG5cdHZhciBjb250ZW50ID0gXCJcIiwgZXNjYXBlZCwgaW5DbGFzcywgc3RhcnQgPSB0b2tQb3M7XG5cdGZvciAoOzspIHtcblx0ICBpZiAodG9rUG9zID49IGlucHV0TGVuKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuXHQgIHZhciBjaCA9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuXHQgIGlmIChuZXdsaW5lLnRlc3QoY2gpKSByYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpO1xuXHQgIGlmICghZXNjYXBlZCkge1xuXHRcdGlmIChjaCA9PT0gXCJbXCIpIGluQ2xhc3MgPSB0cnVlO1xuXHRcdGVsc2UgaWYgKGNoID09PSBcIl1cIiAmJiBpbkNsYXNzKSBpbkNsYXNzID0gZmFsc2U7XG5cdFx0ZWxzZSBpZiAoY2ggPT09IFwiL1wiICYmICFpbkNsYXNzKSBicmVhaztcblx0XHRlc2NhcGVkID0gY2ggPT09IFwiXFxcXFwiO1xuXHQgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2U7XG5cdCAgKyt0b2tQb3M7XG5cdH1cblx0dmFyIGNvbnRlbnQgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKTtcblx0Kyt0b2tQb3M7XG5cdHZhciBtb2RzID0gcmVhZFdvcmQxKCk7XG5cdGlmIChtb2RzICYmICEvXltnbXNpeV0qJC8udGVzdChtb2RzKSkgcmFpc2Uoc3RhcnQsIFwiSW52YWxpZCByZWdleHAgZmxhZ1wiKTtcblx0dHJ5IHtcblx0ICB2YXIgdmFsdWUgPSBuZXcgUmVnRXhwKGNvbnRlbnQsIG1vZHMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdCAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikgcmFpc2Uoc3RhcnQsIGUubWVzc2FnZSk7XG5cdCAgcmFpc2UoZSk7XG5cdH1cblx0cmV0dXJuIGZpbmlzaFRva2VuKF9yZWdleHAsIHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRJbnQocmFkaXgsIGxlbikge1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIHRvdGFsID0gMDtcblx0Zm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG5cdCAgdmFyIGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcyksIHZhbDtcblx0ICBpZiAoY29kZSA+PSA5NykgdmFsID0gY29kZSAtIDk3ICsgMTA7XG5cdCAgZWxzZSBpZiAoY29kZSA+PSA2NSkgdmFsID0gY29kZSAtIDY1ICsgMTA7XG5cdCAgZWxzZSBpZiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB2YWwgPSBjb2RlIC0gNDg7XG5cdCAgZWxzZSB2YWwgPSBJbmZpbml0eTtcblx0ICBpZiAodmFsID49IHJhZGl4KSBicmVhaztcblx0ICArK3Rva1Bvcztcblx0ICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG5cdH1cblx0aWYgKHRva1BvcyA9PT0gc3RhcnQgfHwgbGVuICE9IG51bGwgJiYgdG9rUG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGw7XG5cblx0cmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEhleE51bWJlcigpIHtcblx0dG9rUG9zICs9IDI7XG5cdHZhciB2YWwgPSByZWFkSW50KDE2KTtcblx0aWYgKHZhbCA9PSBudWxsKSByYWlzZSh0b2tTdGFydCArIDIsIFwiRXhwZWN0ZWQgaGV4YWRlY2ltYWwgbnVtYmVyXCIpO1xuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuXHR2YXIgc3RhcnQgPSB0b2tQb3MsIGlzRmxvYXQgPSBmYWxzZSwgb2N0YWwgPSBpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDQ4O1xuXHRpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgcmVhZEludCgxMCkgPT09IG51bGwpIHJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpO1xuXHRpZiAoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpID09PSA0Nikge1xuXHQgICsrdG9rUG9zO1xuXHQgIHJlYWRJbnQoMTApO1xuXHQgIGlzRmxvYXQgPSB0cnVlO1xuXHR9XG5cdHZhciBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpO1xuXHRpZiAobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSB7XG5cdCAgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQoKyt0b2tQb3MpO1xuXHQgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0b2tQb3M7XG5cdCAgaWYgKHJlYWRJbnQoMTApID09PSBudWxsKSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblx0ICBpc0Zsb2F0ID0gdHJ1ZTtcblx0fVxuXHRpZiAoaXNJZGVudGlmaWVyU3RhcnQoaW5wdXQuY2hhckNvZGVBdCh0b2tQb3MpKSkgcmFpc2UodG9rUG9zLCBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO1xuXG5cdHZhciBzdHIgPSBpbnB1dC5zbGljZShzdGFydCwgdG9rUG9zKSwgdmFsO1xuXHRpZiAoaXNGbG9hdCkgdmFsID0gcGFyc2VGbG9hdChzdHIpO1xuXHRlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7XG5cdGVsc2UgaWYgKC9bODldLy50ZXN0KHN0cikgfHwgc3RyaWN0KSByYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTtcblx0ZWxzZSB2YWwgPSBwYXJzZUludChzdHIsIDgpO1xuXHRyZXR1cm4gZmluaXNoVG9rZW4oX251bSwgdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdHJpbmcocXVvdGUpIHtcblx0dG9rUG9zKys7XG5cdHZhciBvdXQgPSBcIlwiO1xuXHRmb3IgKDs7KSB7XG5cdCAgaWYgKHRva1BvcyA+PSBpbnB1dExlbikgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdCAgaWYgKGNoID09PSBxdW90ZSkge1xuXHRcdCsrdG9rUG9zO1xuXHRcdHJldHVybiBmaW5pc2hUb2tlbihfc3RyaW5nLCBvdXQpO1xuXHQgIH1cblx0ICBpZiAoY2ggPT09IDkyKSB7XG5cdFx0Y2ggPSBpbnB1dC5jaGFyQ29kZUF0KCsrdG9rUG9zKTtcblx0XHR2YXIgb2N0YWwgPSAvXlswLTddKy8uZXhlYyhpbnB1dC5zbGljZSh0b2tQb3MsIHRva1BvcyArIDMpKTtcblx0XHRpZiAob2N0YWwpIG9jdGFsID0gb2N0YWxbMF07XG5cdFx0d2hpbGUgKG9jdGFsICYmIHBhcnNlSW50KG9jdGFsLCA4KSA+IDI1NSkgb2N0YWwgPSBvY3RhbC5zbGljZSgwLCAtMSk7XG5cdFx0aWYgKG9jdGFsID09PSBcIjBcIikgb2N0YWwgPSBudWxsO1xuXHRcdCsrdG9rUG9zO1xuXHRcdGlmIChvY3RhbCkge1xuXHRcdCAgaWYgKHN0cmljdCkgcmFpc2UodG9rUG9zIC0gMiwgXCJPY3RhbCBsaXRlcmFsIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdCAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQob2N0YWwsIDgpKTtcblx0XHQgIHRva1BvcyArPSBvY3RhbC5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBzd2l0Y2ggKGNoKSB7XG5cdFx0ICBjYXNlIDExMDogb3V0ICs9IFwiXFxuXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTQ6IG91dCArPSBcIlxcclwiOyBicmVhaztcblx0XHQgIGNhc2UgMTIwOiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcigyKSk7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTc6IG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlYWRIZXhDaGFyKDQpKTsgYnJlYWs7XG5cdFx0ICBjYXNlIDg1OiBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyZWFkSGV4Q2hhcig4KSk7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMTY6IG91dCArPSBcIlxcdFwiOyBicmVhaztcblx0XHQgIGNhc2UgOTg6IG91dCArPSBcIlxcYlwiOyBicmVhaztcblx0XHQgIGNhc2UgMTE4OiBvdXQgKz0gXCJcXHUwMDBiXCI7IGJyZWFrO1xuXHRcdCAgY2FzZSAxMDI6IG91dCArPSBcIlxcZlwiOyBicmVhaztcblx0XHQgIGNhc2UgNDg6IG91dCArPSBcIlxcMFwiOyBicmVhaztcblx0XHQgIGNhc2UgMTM6IGlmIChpbnB1dC5jaGFyQ29kZUF0KHRva1BvcykgPT09IDEwKSArK3Rva1Bvcztcblx0XHQgIGNhc2UgMTA6XG5cdFx0XHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpIHsgdG9rTGluZVN0YXJ0ID0gdG9rUG9zOyArK3Rva0N1ckxpbmU7IH1cblx0XHRcdGJyZWFrO1xuXHRcdCAgZGVmYXVsdDogb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpOyBicmVhaztcblx0XHQgIH1cblx0XHR9XG5cdCAgfSBlbHNlIHtcblx0XHRpZiAoY2ggPT09IDEzIHx8IGNoID09PSAxMCB8fCBjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykgcmFpc2UodG9rU3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTtcblx0XHRvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cdFx0Kyt0b2tQb3M7XG5cdCAgfVxuXHR9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkSGV4Q2hhcihsZW4pIHtcblx0dmFyIG4gPSByZWFkSW50KDE2LCBsZW4pO1xuXHRpZiAobiA9PT0gbnVsbCkgcmFpc2UodG9rU3RhcnQsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7XG5cdHJldHVybiBuO1xuICB9XG5cbiAgdmFyIGNvbnRhaW5zRXNjO1xuXG4gIGZ1bmN0aW9uIHJlYWRXb3JkMSgpIHtcblx0Y29udGFpbnNFc2MgPSBmYWxzZTtcblx0dmFyIHdvcmQsIGZpcnN0ID0gdHJ1ZSwgc3RhcnQgPSB0b2tQb3M7XG5cdGZvciAoOzspIHtcblx0ICB2YXIgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHRva1Bvcyk7XG5cdCAgaWYgKGlzSWRlbnRpZmllckNoYXIoY2gpKSB7XG5cdFx0aWYgKGNvbnRhaW5zRXNjKSB3b3JkICs9IGlucHV0LmNoYXJBdCh0b2tQb3MpO1xuXHRcdCsrdG9rUG9zO1xuXHQgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG5cdFx0aWYgKCFjb250YWluc0VzYykgd29yZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuXHRcdGNvbnRhaW5zRXNjID0gdHJ1ZTtcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdCgrK3Rva1BvcykgIT0gMTE3KVxuXHRcdCAgcmFpc2UodG9rUG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7XG5cdFx0Kyt0b2tQb3M7XG5cdFx0dmFyIGVzYyA9IHJlYWRIZXhDaGFyKDQpO1xuXHRcdHZhciBlc2NTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGVzYyk7XG5cdFx0aWYgKCFlc2NTdHIpIHJhaXNlKHRva1BvcyAtIDEsIFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKTtcblx0XHRpZiAoIShmaXJzdCA/IGlzSWRlbnRpZmllclN0YXJ0KGVzYykgOiBpc0lkZW50aWZpZXJDaGFyKGVzYykpKVxuXHRcdCAgcmFpc2UodG9rUG9zIC0gNCwgXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpO1xuXHRcdHdvcmQgKz0gZXNjU3RyO1xuXHQgIH0gZWxzZSB7XG5cdFx0YnJlYWs7XG5cdCAgfVxuXHQgIGZpcnN0ID0gZmFsc2U7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zRXNjID8gd29yZCA6IGlucHV0LnNsaWNlKHN0YXJ0LCB0b2tQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZFdvcmQoKSB7XG5cdHZhciB3b3JkID0gcmVhZFdvcmQxKCk7XG5cdHZhciB0eXBlID0gX25hbWU7XG5cdGlmICghY29udGFpbnNFc2MgJiYgaXNLZXl3b3JkKHdvcmQpKVxuXHQgIHR5cGUgPSBrZXl3b3JkVHlwZXNbd29yZF07XG5cdHJldHVybiBmaW5pc2hUb2tlbih0eXBlLCB3b3JkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG5cdGxhc3RTdGFydCA9IHRva1N0YXJ0O1xuXHRsYXN0RW5kID0gdG9rRW5kO1xuXHRsYXN0RW5kTG9jID0gdG9rRW5kTG9jO1xuXHRyZWFkVG9rZW4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0cmljdChzdHJjdCkge1xuXHRzdHJpY3QgPSBzdHJjdDtcblx0dG9rUG9zID0gdG9rU3RhcnQ7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHQgIHdoaWxlICh0b2tQb3MgPCB0b2tMaW5lU3RhcnQpIHtcblx0XHR0b2tMaW5lU3RhcnQgPSBpbnB1dC5sYXN0SW5kZXhPZihcIlxcblwiLCB0b2tMaW5lU3RhcnQgLSAyKSArIDE7XG5cdFx0LS10b2tDdXJMaW5lO1xuXHQgIH1cblx0fVxuXHRza2lwU3BhY2UoKTtcblx0cmVhZFRva2VuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBub2RlX3QoKSB7XG5cdHRoaXMudHlwZSA9IG51bGw7XG5cdHRoaXMuc3RhcnQgPSB0b2tTdGFydDtcblx0dGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9kZV9sb2NfdCgpIHtcblx0dGhpcy5zdGFydCA9IHRva1N0YXJ0TG9jO1xuXHR0aGlzLmVuZCA9IG51bGw7XG5cdGlmIChzb3VyY2VGaWxlICE9PSBudWxsKSB0aGlzLnNvdXJjZSA9IHNvdXJjZUZpbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydE5vZGUoKSB7XG5cdHZhciBub2RlID0gbmV3IG5vZGVfdCgpO1xuXHRpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG5cdCAgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuXHRpZiAob3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlKVxuXHQgIG5vZGUuc291cmNlRmlsZSA9IG9wdGlvbnMuZGlyZWN0U291cmNlRmlsZTtcblx0aWYgKG9wdGlvbnMucmFuZ2VzKVxuXHQgIG5vZGUucmFuZ2UgPSBbdG9rU3RhcnQsIDBdO1xuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0Tm9kZUZyb20ob3RoZXIpIHtcblx0dmFyIG5vZGUgPSBuZXcgbm9kZV90KCk7XG5cdG5vZGUuc3RhcnQgPSBvdGhlci5zdGFydDtcblx0aWYgKG9wdGlvbnMubG9jYXRpb25zKSB7XG5cdCAgbm9kZS5sb2MgPSBuZXcgbm9kZV9sb2NfdCgpO1xuXHQgIG5vZGUubG9jLnN0YXJ0ID0gb3RoZXIubG9jLnN0YXJ0O1xuXHR9XG5cdGlmIChvcHRpb25zLnJhbmdlcylcblx0ICBub2RlLnJhbmdlID0gW290aGVyLnJhbmdlWzBdLCAwXTtcblxuXHRyZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuXHRub2RlLnR5cGUgPSB0eXBlO1xuXHRub2RlLmVuZCA9IGxhc3RFbmQ7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucylcblx0ICBub2RlLmxvYy5lbmQgPSBsYXN0RW5kTG9jO1xuXHRpZiAob3B0aW9ucy5yYW5nZXMpXG5cdCAgbm9kZS5yYW5nZVsxXSA9IGxhc3RFbmQ7XG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVc2VTdHJpY3Qoc3RtdCkge1xuXHRyZXR1cm4gb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcblx0ICBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVhdCh0eXBlKSB7XG5cdGlmICh0b2tUeXBlID09PSB0eXBlKSB7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiB0cnVlO1xuXHR9XG4gIH1cblxuICBmdW5jdGlvbiBjYW5JbnNlcnRTZW1pY29sb24oKSB7XG5cdHJldHVybiAhb3B0aW9ucy5zdHJpY3RTZW1pY29sb25zICYmXG5cdCAgKHRva1R5cGUgPT09IF9lb2YgfHwgdG9rVHlwZSA9PT0gX2JyYWNlUiB8fCBuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZW1pY29sb24oKSB7XG5cdGlmICghZWF0KF9zZW1pKSAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh0eXBlKSB7XG5cdGlmICh0b2tUeXBlID09PSB0eXBlKSBuZXh0KCk7XG5cdGVsc2UgdW5leHBlY3RlZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5leHBlY3RlZCgpIHtcblx0cmFpc2UodG9rU3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTFZhbChleHByKSB7XG5cdGlmIChleHByLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGV4cHIudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpXG5cdCAgcmFpc2UoZXhwci5zdGFydCwgXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpO1xuXHRpZiAoc3RyaWN0ICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNTdHJpY3RCYWRJZFdvcmQoZXhwci5uYW1lKSlcblx0ICByYWlzZShleHByLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBcIiArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VUb3BMZXZlbChwcm9ncmFtKSB7XG5cdGxhc3RTdGFydCA9IGxhc3RFbmQgPSB0b2tQb3M7XG5cdGlmIChvcHRpb25zLmxvY2F0aW9ucykgbGFzdEVuZExvYyA9IG5ldyBsaW5lX2xvY190O1xuXHRpbkZ1bmN0aW9uID0gc3RyaWN0ID0gbnVsbDtcblx0bGFiZWxzID0gW107XG5cdHJlYWRUb2tlbigpO1xuXG5cdHZhciBub2RlID0gcHJvZ3JhbSB8fCBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlO1xuXHRpZiAoIXByb2dyYW0pIG5vZGUuYm9keSA9IFtdO1xuXHR3aGlsZSAodG9rVHlwZSAhPT0gX2VvZikge1xuXHQgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBub2RlLmJvZHkucHVzaChzdG10KTtcblx0ICBpZiAoZmlyc3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHNldFN0cmljdCh0cnVlKTtcblx0ICBmaXJzdCA9IGZhbHNlO1xuXHR9XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKTtcbiAgfVxuXG4gIHZhciBsb29wTGFiZWwgPSB7a2luZDogXCJsb29wXCJ9LCBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcblx0aWYgKHRva1R5cGUgPT09IF9zbGFzaCB8fCB0b2tUeXBlID09PSBfYXNzaWduICYmIHRva1ZhbCA9PSBcIi89XCIpXG5cdCAgcmVhZFRva2VuKHRydWUpO1xuXG5cdHZhciBzdGFydHR5cGUgPSB0b2tUeXBlLCBub2RlID0gc3RhcnROb2RlKCk7XG5cblx0c3dpdGNoIChzdGFydHR5cGUpIHtcblx0Y2FzZSBfYnJlYWs6IGNhc2UgX2NvbnRpbnVlOlxuXHQgIG5leHQoKTtcblx0ICB2YXIgaXNCcmVhayA9IHN0YXJ0dHlwZSA9PT0gX2JyZWFrO1xuXHQgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmxhYmVsID0gbnVsbDtcblx0ICBlbHNlIGlmICh0b2tUeXBlICE9PSBfbmFtZSkgdW5leHBlY3RlZCgpO1xuXHQgIGVsc2Uge1xuXHRcdG5vZGUubGFiZWwgPSBwYXJzZUlkZW50KCk7XG5cdFx0c2VtaWNvbG9uKCk7XG5cdCAgfVxuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgbGFiID0gbGFiZWxzW2ldO1xuXHRcdGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuXHRcdCAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgYnJlYWs7XG5cdFx0ICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcblx0XHR9XG5cdCAgfVxuXHQgIGlmIChpID09PSBsYWJlbHMubGVuZ3RoKSByYWlzZShub2RlLnN0YXJ0LCBcIlVuc3ludGFjdGljIFwiICsgc3RhcnR0eXBlLmtleXdvcmQpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2RlYnVnZ2VyOlxuXHQgIG5leHQoKTtcblx0ICBzZW1pY29sb24oKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2RvOlxuXHQgIG5leHQoKTtcblx0ICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXHQgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbGFiZWxzLnBvcCgpO1xuXHQgIGV4cGVjdChfd2hpbGUpO1xuXHQgIG5vZGUudGVzdCA9IHBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX2Zvcjpcblx0ICBuZXh0KCk7XG5cdCAgbGFiZWxzLnB1c2gobG9vcExhYmVsKTtcblx0ICBleHBlY3QoX3BhcmVuTCk7XG5cdCAgaWYgKHRva1R5cGUgPT09IF9zZW1pKSByZXR1cm4gcGFyc2VGb3Iobm9kZSwgbnVsbCk7XG5cdCAgaWYgKHRva1R5cGUgPT09IF92YXIpIHtcblx0XHR2YXIgaW5pdCA9IHN0YXJ0Tm9kZSgpO1xuXHRcdG5leHQoKTtcblx0XHRwYXJzZVZhcihpbml0LCB0cnVlKTtcblx0XHRmaW5pc2hOb2RlKGluaXQsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblx0XHRpZiAoaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmIGVhdChfaW4pKVxuXHRcdCAgcmV0dXJuIHBhcnNlRm9ySW4obm9kZSwgaW5pdCk7XG5cdFx0cmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuXHQgIH1cblx0ICB2YXIgaW5pdCA9IHBhcnNlRXhwcmVzc2lvbihmYWxzZSwgdHJ1ZSk7XG5cdCAgaWYgKGVhdChfaW4pKSB7Y2hlY2tMVmFsKGluaXQpOyByZXR1cm4gcGFyc2VGb3JJbihub2RlLCBpbml0KTt9XG5cdCAgcmV0dXJuIHBhcnNlRm9yKG5vZGUsIGluaXQpO1xuXG5cdGNhc2UgX2Z1bmN0aW9uOlxuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gcGFyc2VGdW5jdGlvbihub2RlLCB0cnVlKTtcblxuXHRjYXNlIF9pZjpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBub2RlLmNvbnNlcXVlbnQgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIG5vZGUuYWx0ZXJuYXRlID0gZWF0KF9lbHNlKSA/IHBhcnNlU3RhdGVtZW50KCkgOiBudWxsO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfcmV0dXJuOlxuXHQgIGlmICghaW5GdW5jdGlvbiAmJiAhb3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcblx0XHRyYWlzZSh0b2tTdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuXHQgIG5leHQoKTtcblxuXHQgIGlmIChlYXQoX3NlbWkpIHx8IGNhbkluc2VydFNlbWljb2xvbigpKSBub2RlLmFyZ3VtZW50ID0gbnVsbDtcblx0ICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHBhcnNlRXhwcmVzc2lvbigpOyBzZW1pY29sb24oKTsgfVxuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuXG5cdGNhc2UgX3N3aXRjaDpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5kaXNjcmltaW5hbnQgPSBwYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuXHQgIG5vZGUuY2FzZXMgPSBbXTtcblx0ICBleHBlY3QoX2JyYWNlTCk7XG5cdCAgbGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuXG5cdCAgZm9yICh2YXIgY3VyLCBzYXdEZWZhdWx0OyB0b2tUeXBlICE9IF9icmFjZVI7KSB7XG5cdFx0aWYgKHRva1R5cGUgPT09IF9jYXNlIHx8IHRva1R5cGUgPT09IF9kZWZhdWx0KSB7XG5cdFx0ICB2YXIgaXNDYXNlID0gdG9rVHlwZSA9PT0gX2Nhc2U7XG5cdFx0ICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuXHRcdCAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHN0YXJ0Tm9kZSgpKTtcblx0XHQgIGN1ci5jb25zZXF1ZW50ID0gW107XG5cdFx0ICBuZXh0KCk7XG5cdFx0ICBpZiAoaXNDYXNlKSBjdXIudGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHRcdCAgZWxzZSB7XG5cdFx0XHRpZiAoc2F3RGVmYXVsdCkgcmFpc2UobGFzdFN0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKTsgc2F3RGVmYXVsdCA9IHRydWU7XG5cdFx0XHRjdXIudGVzdCA9IG51bGw7XG5cdFx0ICB9XG5cdFx0ICBleHBlY3QoX2NvbG9uKTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgaWYgKCFjdXIpIHVuZXhwZWN0ZWQoKTtcblx0XHQgIGN1ci5jb25zZXF1ZW50LnB1c2gocGFyc2VTdGF0ZW1lbnQoKSk7XG5cdFx0fVxuXHQgIH1cblx0ICBpZiAoY3VyKSBmaW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuXHQgIG5leHQoKTtcblx0ICBsYWJlbHMucG9wKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfdGhyb3c6XG5cdCAgbmV4dCgpO1xuXHQgIGlmIChuZXdsaW5lLnRlc3QoaW5wdXQuc2xpY2UobGFzdEVuZCwgdG9rU3RhcnQpKSlcblx0XHRyYWlzZShsYXN0RW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKTtcblx0ICBub2RlLmFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgc2VtaWNvbG9uKCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcblxuXHRjYXNlIF90cnk6XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuYmxvY2sgPSBwYXJzZUJsb2NrKCk7XG5cdCAgbm9kZS5oYW5kbGVyID0gbnVsbDtcblx0ICBpZiAodG9rVHlwZSA9PT0gX2NhdGNoKSB7XG5cdFx0dmFyIGNsYXVzZSA9IHN0YXJ0Tm9kZSgpO1xuXHRcdG5leHQoKTtcblx0XHRleHBlY3QoX3BhcmVuTCk7XG5cdFx0Y2xhdXNlLnBhcmFtID0gcGFyc2VJZGVudCgpO1xuXHRcdGlmIChzdHJpY3QgJiYgaXNTdHJpY3RCYWRJZFdvcmQoY2xhdXNlLnBhcmFtLm5hbWUpKVxuXHRcdCAgcmFpc2UoY2xhdXNlLnBhcmFtLnN0YXJ0LCBcIkJpbmRpbmcgXCIgKyBjbGF1c2UucGFyYW0ubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdGV4cGVjdChfcGFyZW5SKTtcblx0XHRjbGF1c2UuZ3VhcmQgPSBudWxsO1xuXHRcdGNsYXVzZS5ib2R5ID0gcGFyc2VCbG9jaygpO1xuXHRcdG5vZGUuaGFuZGxlciA9IGZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuXHQgIH1cblx0ICBub2RlLmd1YXJkZWRIYW5kbGVycyA9IGVtcHR5O1xuXHQgIG5vZGUuZmluYWxpemVyID0gZWF0KF9maW5hbGx5KSA/IHBhcnNlQmxvY2soKSA6IG51bGw7XG5cdCAgaWYgKCFub2RlLmhhbmRsZXIgJiYgIW5vZGUuZmluYWxpemVyKVxuXHRcdHJhaXNlKG5vZGUuc3RhcnQsIFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF92YXI6XG5cdCAgbmV4dCgpO1xuXHQgIHBhcnNlVmFyKG5vZGUpO1xuXHQgIHNlbWljb2xvbigpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcblxuXHRjYXNlIF93aGlsZTpcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS50ZXN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBsYWJlbHMucHVzaChsb29wTGFiZWwpO1xuXHQgIG5vZGUuYm9keSA9IHBhcnNlU3RhdGVtZW50KCk7XG5cdCAgbGFiZWxzLnBvcCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG5cblx0Y2FzZSBfd2l0aDpcblx0ICBpZiAoc3RyaWN0KSByYWlzZSh0b2tTdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUub2JqZWN0ID0gcGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcblx0ICBub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcblxuXHRjYXNlIF9icmFjZUw6XG5cdCAgcmV0dXJuIHBhcnNlQmxvY2soKTtcblxuXHRjYXNlIF9zZW1pOlxuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuXG5cdGRlZmF1bHQ6XG5cdCAgdmFyIG1heWJlTmFtZSA9IHRva1ZhbCwgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIGlmIChzdGFydHR5cGUgPT09IF9uYW1lICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZWF0KF9jb2xvbikpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7ICsraSlcblx0XHQgIGlmIChsYWJlbHNbaV0ubmFtZSA9PT0gbWF5YmVOYW1lKSByYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuXHRcdHZhciBraW5kID0gdG9rVHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRva1R5cGUgPT09IF9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcblx0XHRsYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kfSk7XG5cdFx0bm9kZS5ib2R5ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0XHRsYWJlbHMucG9wKCk7XG5cdFx0bm9kZS5sYWJlbCA9IGV4cHI7XG5cdFx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuXHQgIH0gZWxzZSB7XG5cdFx0bm9kZS5leHByZXNzaW9uID0gZXhwcjtcblx0XHRzZW1pY29sb24oKTtcblx0XHRyZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG5cdCAgfVxuXHR9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhcmVuRXhwcmVzc2lvbigpIHtcblx0ZXhwZWN0KF9wYXJlbkwpO1xuXHR2YXIgdmFsID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfcGFyZW5SKTtcblx0cmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQmxvY2soYWxsb3dTdHJpY3QpIHtcblx0dmFyIG5vZGUgPSBzdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBzdHJpY3QgPSBmYWxzZSwgb2xkU3RyaWN0O1xuXHRub2RlLmJvZHkgPSBbXTtcblx0ZXhwZWN0KF9icmFjZUwpO1xuXHR3aGlsZSAoIWVhdChfYnJhY2VSKSkge1xuXHQgIHZhciBzdG10ID0gcGFyc2VTdGF0ZW1lbnQoKTtcblx0ICBub2RlLmJvZHkucHVzaChzdG10KTtcblx0ICBpZiAoZmlyc3QgJiYgYWxsb3dTdHJpY3QgJiYgaXNVc2VTdHJpY3Qoc3RtdCkpIHtcblx0XHRvbGRTdHJpY3QgPSBzdHJpY3Q7XG5cdFx0c2V0U3RyaWN0KHN0cmljdCA9IHRydWUpO1xuXHQgIH1cblx0ICBmaXJzdCA9IGZhbHNlO1xuXHR9XG5cdGlmIChzdHJpY3QgJiYgIW9sZFN0cmljdCkgc2V0U3RyaWN0KGZhbHNlKTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcblx0bm9kZS5pbml0ID0gaW5pdDtcblx0ZXhwZWN0KF9zZW1pKTtcblx0bm9kZS50ZXN0ID0gdG9rVHlwZSA9PT0gX3NlbWkgPyBudWxsIDogcGFyc2VFeHByZXNzaW9uKCk7XG5cdGV4cGVjdChfc2VtaSk7XG5cdG5vZGUudXBkYXRlID0gdG9rVHlwZSA9PT0gX3BhcmVuUiA/IG51bGwgOiBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9wYXJlblIpO1xuXHRub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHRsYWJlbHMucG9wKCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGb3JJbihub2RlLCBpbml0KSB7XG5cdG5vZGUubGVmdCA9IGluaXQ7XG5cdG5vZGUucmlnaHQgPSBwYXJzZUV4cHJlc3Npb24oKTtcblx0ZXhwZWN0KF9wYXJlblIpO1xuXHRub2RlLmJvZHkgPSBwYXJzZVN0YXRlbWVudCgpO1xuXHRsYWJlbHMucG9wKCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiRm9ySW5TdGF0ZW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVZhcihub2RlLCBub0luKSB7XG5cdG5vZGUuZGVjbGFyYXRpb25zID0gW107XG5cdG5vZGUua2luZCA9IFwidmFyXCI7XG5cdGZvciAoOzspIHtcblx0ICB2YXIgZGVjbCA9IHN0YXJ0Tm9kZSgpO1xuXHQgIGRlY2wuaWQgPSBwYXJzZUlkZW50KCk7XG5cdCAgaWYgKHN0cmljdCAmJiBpc1N0cmljdEJhZElkV29yZChkZWNsLmlkLm5hbWUpKVxuXHRcdHJhaXNlKGRlY2wuaWQuc3RhcnQsIFwiQmluZGluZyBcIiArIGRlY2wuaWQubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpO1xuXHQgIGRlY2wuaW5pdCA9IGVhdChfZXEpID8gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pIDogbnVsbDtcblx0ICBub2RlLmRlY2xhcmF0aW9ucy5wdXNoKGZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuXHQgIGlmICghZWF0KF9jb21tYSkpIGJyZWFrO1xuXHR9XG5cdHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKG5vQ29tbWEsIG5vSW4pIHtcblx0dmFyIGV4cHIgPSBwYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuXHRpZiAoIW5vQ29tbWEgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuXHQgIG5vZGUuZXhwcmVzc2lvbnMgPSBbZXhwcl07XG5cdCAgd2hpbGUgKGVhdChfY29tbWEpKSBub2RlLmV4cHJlc3Npb25zLnB1c2gocGFyc2VNYXliZUFzc2lnbihub0luKSk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlQXNzaWduKG5vSW4pIHtcblx0dmFyIGxlZnQgPSBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbik7XG5cdGlmICh0b2tUeXBlLmlzQXNzaWduKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGxlZnQpO1xuXHQgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdCAgbm9kZS5sZWZ0ID0gbGVmdDtcblx0ICBuZXh0KCk7XG5cdCAgbm9kZS5yaWdodCA9IHBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG5cdCAgY2hlY2tMVmFsKGxlZnQpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIik7XG5cdH1cblx0cmV0dXJuIGxlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1heWJlQ29uZGl0aW9uYWwobm9Jbikge1xuXHR2YXIgZXhwciA9IHBhcnNlRXhwck9wcyhub0luKTtcblx0aWYgKGVhdChfcXVlc3Rpb24pKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGV4cHIpO1xuXHQgIG5vZGUudGVzdCA9IGV4cHI7XG5cdCAgbm9kZS5jb25zZXF1ZW50ID0gcGFyc2VFeHByZXNzaW9uKHRydWUpO1xuXHQgIGV4cGVjdChfY29sb24pO1xuXHQgIG5vZGUuYWx0ZXJuYXRlID0gcGFyc2VFeHByZXNzaW9uKHRydWUsIG5vSW4pO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByT3BzKG5vSW4pIHtcblx0cmV0dXJuIHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCAtMSwgbm9Jbik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUV4cHJPcChsZWZ0LCBtaW5QcmVjLCBub0luKSB7XG5cdHZhciBwcmVjID0gdG9rVHlwZS5iaW5vcDtcblx0aWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdG9rVHlwZSAhPT0gX2luKSkge1xuXHQgIGlmIChwcmVjID4gbWluUHJlYykge1xuXHRcdHZhciBub2RlID0gc3RhcnROb2RlRnJvbShsZWZ0KTtcblx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXHRcdG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdFx0dmFyIG9wID0gdG9rVHlwZTtcblx0XHRuZXh0KCk7XG5cdFx0bm9kZS5yaWdodCA9IHBhcnNlRXhwck9wKHBhcnNlTWF5YmVVbmFyeSgpLCBwcmVjLCBub0luKTtcblx0XHR2YXIgZXhwck5vZGUgPSBmaW5pc2hOb2RlKG5vZGUsIChvcCA9PT0gX2xvZ2ljYWxPUiB8fCBvcCA9PT0gX2xvZ2ljYWxBTkQpID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpO1xuXHRcdHJldHVybiBwYXJzZUV4cHJPcChleHByTm9kZSwgbWluUHJlYywgbm9Jbik7XG5cdCAgfVxuXHR9XG5cdHJldHVybiBsZWZ0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNYXliZVVuYXJ5KCkge1xuXHRpZiAodG9rVHlwZS5wcmVmaXgpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0b2tUeXBlLmlzVXBkYXRlO1xuXHQgIG5vZGUub3BlcmF0b3IgPSB0b2tWYWw7XG5cdCAgbm9kZS5wcmVmaXggPSB0cnVlO1xuXHQgIHRva1JlZ2V4cEFsbG93ZWQgPSB0cnVlO1xuXHQgIG5leHQoKTtcblx0ICBub2RlLmFyZ3VtZW50ID0gcGFyc2VNYXliZVVuYXJ5KCk7XG5cdCAgaWYgKHVwZGF0ZSkgY2hlY2tMVmFsKG5vZGUuYXJndW1lbnQpO1xuXHQgIGVsc2UgaWYgKHN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG5cdFx0XHQgICBub2RlLmFyZ3VtZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKVxuXHRcdHJhaXNlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgdXBkYXRlID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcblx0fVxuXHR2YXIgZXhwciA9IHBhcnNlRXhwclN1YnNjcmlwdHMoKTtcblx0d2hpbGUgKHRva1R5cGUucG9zdGZpeCAmJiAhY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcblx0ICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZUZyb20oZXhwcik7XG5cdCAgbm9kZS5vcGVyYXRvciA9IHRva1ZhbDtcblx0ICBub2RlLnByZWZpeCA9IGZhbHNlO1xuXHQgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuXHQgIGNoZWNrTFZhbChleHByKTtcblx0ICBuZXh0KCk7XG5cdCAgZXhwciA9IGZpbmlzaE5vZGUobm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpO1xuXHR9XG5cdHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0cygpIHtcblx0cmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhwYXJzZUV4cHJBdG9tKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdWJzY3JpcHRzKGJhc2UsIG5vQ2FsbHMpIHtcblx0aWYgKGVhdChfZG90KSkge1xuXHQgIHZhciBub2RlID0gc3RhcnROb2RlRnJvbShiYXNlKTtcblx0ICBub2RlLm9iamVjdCA9IGJhc2U7XG5cdCAgbm9kZS5wcm9wZXJ0eSA9IHBhcnNlSWRlbnQodHJ1ZSk7XG5cdCAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuXHQgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIiksIG5vQ2FsbHMpO1xuXHR9IGVsc2UgaWYgKGVhdChfYnJhY2tldEwpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuXHQgIG5vZGUub2JqZWN0ID0gYmFzZTtcblx0ICBub2RlLnByb3BlcnR5ID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cdCAgbm9kZS5jb21wdXRlZCA9IHRydWU7XG5cdCAgZXhwZWN0KF9icmFja2V0Uik7XG5cdCAgcmV0dXJuIHBhcnNlU3Vic2NyaXB0cyhmaW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKSwgbm9DYWxscyk7XG5cdH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgZWF0KF9wYXJlbkwpKSB7XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGVGcm9tKGJhc2UpO1xuXHQgIG5vZGUuY2FsbGVlID0gYmFzZTtcblx0ICBub2RlLmFyZ3VtZW50cyA9IHBhcnNlRXhwckxpc3QoX3BhcmVuUiwgZmFsc2UpO1xuXHQgIHJldHVybiBwYXJzZVN1YnNjcmlwdHMoZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpLCBub0NhbGxzKTtcblx0fSBlbHNlIHJldHVybiBiYXNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByQXRvbSgpIHtcblx0c3dpdGNoICh0b2tUeXBlKSB7XG5cdGNhc2UgX3RoaXM6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBuZXh0KCk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKTtcblx0Y2FzZSBfbmFtZTpcblx0ICByZXR1cm4gcGFyc2VJZGVudCgpO1xuXHRjYXNlIF9udW06IGNhc2UgX3N0cmluZzogY2FzZSBfcmVnZXhwOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbm9kZS52YWx1ZSA9IHRva1ZhbDtcblx0ICBub2RlLnJhdyA9IGlucHV0LnNsaWNlKHRva1N0YXJ0LCB0b2tFbmQpO1xuXHQgIG5leHQoKTtcblx0ICByZXR1cm4gZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIik7XG5cblx0Y2FzZSBfbnVsbDogY2FzZSBfdHJ1ZTogY2FzZSBfZmFsc2U6XG5cdCAgdmFyIG5vZGUgPSBzdGFydE5vZGUoKTtcblx0ICBub2RlLnZhbHVlID0gdG9rVHlwZS5hdG9tVmFsdWU7XG5cdCAgbm9kZS5yYXcgPSB0b2tUeXBlLmtleXdvcmQ7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKTtcblxuXHRjYXNlIF9wYXJlbkw6XG5cdCAgdmFyIHRva1N0YXJ0TG9jMSA9IHRva1N0YXJ0TG9jLCB0b2tTdGFydDEgPSB0b2tTdGFydDtcblx0ICBuZXh0KCk7XG5cdCAgdmFyIHZhbCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXHQgIHZhbC5zdGFydCA9IHRva1N0YXJ0MTtcblx0ICB2YWwuZW5kID0gdG9rRW5kO1xuXHQgIGlmIChvcHRpb25zLmxvY2F0aW9ucykge1xuXHRcdHZhbC5sb2Muc3RhcnQgPSB0b2tTdGFydExvYzE7XG5cdFx0dmFsLmxvYy5lbmQgPSB0b2tFbmRMb2M7XG5cdCAgfVxuXHQgIGlmIChvcHRpb25zLnJhbmdlcylcblx0XHR2YWwucmFuZ2UgPSBbdG9rU3RhcnQxLCB0b2tFbmRdO1xuXHQgIGV4cGVjdChfcGFyZW5SKTtcblx0ICByZXR1cm4gdmFsO1xuXG5cdGNhc2UgX2JyYWNrZXRMOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbmV4dCgpO1xuXHQgIG5vZGUuZWxlbWVudHMgPSBwYXJzZUV4cHJMaXN0KF9icmFja2V0UiwgdHJ1ZSwgdHJ1ZSk7XG5cdCAgcmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIik7XG5cblx0Y2FzZSBfYnJhY2VMOlxuXHQgIHJldHVybiBwYXJzZU9iaigpO1xuXG5cdGNhc2UgX2Z1bmN0aW9uOlxuXHQgIHZhciBub2RlID0gc3RhcnROb2RlKCk7XG5cdCAgbmV4dCgpO1xuXHQgIHJldHVybiBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZhbHNlKTtcblxuXHRjYXNlIF9uZXc6XG5cdCAgcmV0dXJuIHBhcnNlTmV3KCk7XG5cblx0ZGVmYXVsdDpcblx0ICB1bmV4cGVjdGVkKCk7XG5cdH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTmV3KCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHRuZXh0KCk7XG5cdG5vZGUuY2FsbGVlID0gcGFyc2VTdWJzY3JpcHRzKHBhcnNlRXhwckF0b20oKSwgdHJ1ZSk7XG5cdGlmIChlYXQoX3BhcmVuTCkpIG5vZGUuYXJndW1lbnRzID0gcGFyc2VFeHByTGlzdChfcGFyZW5SLCBmYWxzZSk7XG5cdGVsc2Ugbm9kZS5hcmd1bWVudHMgPSBlbXB0eTtcblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmooKSB7XG5cdHZhciBub2RlID0gc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgc2F3R2V0U2V0ID0gZmFsc2U7XG5cdG5vZGUucHJvcGVydGllcyA9IFtdO1xuXHRuZXh0KCk7XG5cdHdoaWxlICghZWF0KF9icmFjZVIpKSB7XG5cdCAgaWYgKCFmaXJzdCkge1xuXHRcdGV4cGVjdChfY29tbWEpO1xuXHRcdGlmIChvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYXMgJiYgZWF0KF9icmFjZVIpKSBicmVhaztcblx0ICB9IGVsc2UgZmlyc3QgPSBmYWxzZTtcblxuXHQgIHZhciBwcm9wID0ge2tleTogcGFyc2VQcm9wZXJ0eU5hbWUoKX0sIGlzR2V0U2V0ID0gZmFsc2UsIGtpbmQ7XG5cdCAgaWYgKGVhdChfY29sb24pKSB7XG5cdFx0cHJvcC52YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbih0cnVlKTtcblx0XHRraW5kID0gcHJvcC5raW5kID0gXCJpbml0XCI7XG5cdCAgfSBlbHNlIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDUgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiZcblx0XHRcdFx0IChwcm9wLmtleS5uYW1lID09PSBcImdldFwiIHx8IHByb3Aua2V5Lm5hbWUgPT09IFwic2V0XCIpKSB7XG5cdFx0aXNHZXRTZXQgPSBzYXdHZXRTZXQgPSB0cnVlO1xuXHRcdGtpbmQgPSBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuXHRcdHByb3Aua2V5ID0gcGFyc2VQcm9wZXJ0eU5hbWUoKTtcblx0XHRpZiAodG9rVHlwZSAhPT0gX3BhcmVuTCkgdW5leHBlY3RlZCgpO1xuXHRcdHByb3AudmFsdWUgPSBwYXJzZUZ1bmN0aW9uKHN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG5cdCAgfSBlbHNlIHVuZXhwZWN0ZWQoKTtcblxuXHQgIGlmIChwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAoc3RyaWN0IHx8IHNhd0dldFNldCkpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xuXHRcdCAgdmFyIG90aGVyID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuXHRcdCAgaWYgKG90aGVyLmtleS5uYW1lID09PSBwcm9wLmtleS5uYW1lKSB7XG5cdFx0XHR2YXIgY29uZmxpY3QgPSBraW5kID09IG90aGVyLmtpbmQgfHwgaXNHZXRTZXQgJiYgb3RoZXIua2luZCA9PT0gXCJpbml0XCIgfHxcblx0XHRcdCAga2luZCA9PT0gXCJpbml0XCIgJiYgKG90aGVyLmtpbmQgPT09IFwiZ2V0XCIgfHwgb3RoZXIua2luZCA9PT0gXCJzZXRcIik7XG5cdFx0XHRpZiAoY29uZmxpY3QgJiYgIXN0cmljdCAmJiBraW5kID09PSBcImluaXRcIiAmJiBvdGhlci5raW5kID09PSBcImluaXRcIikgY29uZmxpY3QgPSBmYWxzZTtcblx0XHRcdGlmIChjb25mbGljdCkgcmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpO1xuXHRcdCAgfVxuXHRcdH1cblx0ICB9XG5cdCAgbm9kZS5wcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG5cdH1cblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eU5hbWUoKSB7XG5cdGlmICh0b2tUeXBlID09PSBfbnVtIHx8IHRva1R5cGUgPT09IF9zdHJpbmcpIHJldHVybiBwYXJzZUV4cHJBdG9tKCk7XG5cdHJldHVybiBwYXJzZUlkZW50KHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuXHRpZiAodG9rVHlwZSA9PT0gX25hbWUpIG5vZGUuaWQgPSBwYXJzZUlkZW50KCk7XG5cdGVsc2UgaWYgKGlzU3RhdGVtZW50KSB1bmV4cGVjdGVkKCk7XG5cdGVsc2Ugbm9kZS5pZCA9IG51bGw7XG5cdG5vZGUucGFyYW1zID0gW107XG5cdHZhciBmaXJzdCA9IHRydWU7XG5cdGV4cGVjdChfcGFyZW5MKTtcblx0d2hpbGUgKCFlYXQoX3BhcmVuUikpIHtcblx0ICBpZiAoIWZpcnN0KSBleHBlY3QoX2NvbW1hKTsgZWxzZSBmaXJzdCA9IGZhbHNlO1xuXHQgIG5vZGUucGFyYW1zLnB1c2gocGFyc2VJZGVudCgpKTtcblx0fVxuXG5cdHZhciBvbGRJbkZ1bmMgPSBpbkZ1bmN0aW9uLCBvbGRMYWJlbHMgPSBsYWJlbHM7XG5cdGluRnVuY3Rpb24gPSB0cnVlOyBsYWJlbHMgPSBbXTtcblx0bm9kZS5ib2R5ID0gcGFyc2VCbG9jayh0cnVlKTtcblx0aW5GdW5jdGlvbiA9IG9sZEluRnVuYzsgbGFiZWxzID0gb2xkTGFiZWxzO1xuXG5cdGlmIChzdHJpY3QgfHwgbm9kZS5ib2R5LmJvZHkubGVuZ3RoICYmIGlzVXNlU3RyaWN0KG5vZGUuYm9keS5ib2R5WzBdKSkge1xuXHQgIGZvciAodmFyIGkgPSBub2RlLmlkID8gLTEgOiAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyArK2kpIHtcblx0XHR2YXIgaWQgPSBpIDwgMCA/IG5vZGUuaWQgOiBub2RlLnBhcmFtc1tpXTtcblx0XHRpZiAoaXNTdHJpY3RSZXNlcnZlZFdvcmQoaWQubmFtZSkgfHwgaXNTdHJpY3RCYWRJZFdvcmQoaWQubmFtZSkpXG5cdFx0ICByYWlzZShpZC5zdGFydCwgXCJEZWZpbmluZyAnXCIgKyBpZC5uYW1lICsgXCInIGluIHN0cmljdCBtb2RlXCIpO1xuXHRcdGlmIChpID49IDApIGZvciAodmFyIGogPSAwOyBqIDwgaTsgKytqKSBpZiAoaWQubmFtZSA9PT0gbm9kZS5wYXJhbXNbal0ubmFtZSlcblx0XHQgIHJhaXNlKGlkLnN0YXJ0LCBcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIik7XG5cdCAgfVxuXHR9XG5cblx0cmV0dXJuIGZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByTGlzdChjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5KSB7XG5cdHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcblx0d2hpbGUgKCFlYXQoY2xvc2UpKSB7XG5cdCAgaWYgKCFmaXJzdCkge1xuXHRcdGV4cGVjdChfY29tbWEpO1xuXHRcdGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgb3B0aW9ucy5hbGxvd1RyYWlsaW5nQ29tbWFzICYmIGVhdChjbG9zZSkpIGJyZWFrO1xuXHQgIH0gZWxzZSBmaXJzdCA9IGZhbHNlO1xuXG5cdCAgaWYgKGFsbG93RW1wdHkgJiYgdG9rVHlwZSA9PT0gX2NvbW1hKSBlbHRzLnB1c2gobnVsbCk7XG5cdCAgZWxzZSBlbHRzLnB1c2gocGFyc2VFeHByZXNzaW9uKHRydWUpKTtcblx0fVxuXHRyZXR1cm4gZWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSWRlbnQobGliZXJhbCkge1xuXHR2YXIgbm9kZSA9IHN0YXJ0Tm9kZSgpO1xuXHRpZiAobGliZXJhbCAmJiBvcHRpb25zLmZvcmJpZFJlc2VydmVkID09IFwiZXZlcnl3aGVyZVwiKSBsaWJlcmFsID0gZmFsc2U7XG5cdGlmICh0b2tUeXBlID09PSBfbmFtZSkge1xuXHQgIGlmICghbGliZXJhbCAmJlxuXHRcdCAgKG9wdGlvbnMuZm9yYmlkUmVzZXJ2ZWQgJiZcblx0XHQgICAob3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gMyA/IGlzUmVzZXJ2ZWRXb3JkMyA6IGlzUmVzZXJ2ZWRXb3JkNSkodG9rVmFsKSB8fFxuXHRcdCAgIHN0cmljdCAmJiBpc1N0cmljdFJlc2VydmVkV29yZCh0b2tWYWwpKSAmJlxuXHRcdCAgaW5wdXQuc2xpY2UodG9rU3RhcnQsIHRva0VuZCkuaW5kZXhPZihcIlxcXFxcIikgPT0gLTEpXG5cdFx0cmFpc2UodG9rU3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgdG9rVmFsICsgXCInIGlzIHJlc2VydmVkXCIpO1xuXHQgIG5vZGUubmFtZSA9IHRva1ZhbDtcblx0fSBlbHNlIGlmIChsaWJlcmFsICYmIHRva1R5cGUua2V5d29yZCkge1xuXHQgIG5vZGUubmFtZSA9IHRva1R5cGUua2V5d29yZDtcblx0fSBlbHNlIHtcblx0ICB1bmV4cGVjdGVkKCk7XG5cdH1cblx0dG9rUmVnZXhwQWxsb3dlZCA9IGZhbHNlO1xuXHRuZXh0KCk7XG5cdHJldHVybiBmaW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgfVxuXG59KTtcblxuXHRcdGlmICghYWNvcm4udmVyc2lvbilcblx0XHRcdGFjb3JuID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gKGdsb2JhbC5hY29ybiB8fCBhY29ybikucGFyc2UoY29kZSwgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdfX2VxdWFscycsXG5cdFx0JyE9JzogJ19fZXF1YWxzJ1xuXHR9O1xuXG5cdHZhciB1bmFyeU9wZXJhdG9ycyA9IHtcblx0XHQnLSc6ICdfX25lZ2F0ZScsXG5cdFx0JysnOiAnX19zZWxmJ1xuXHR9O1xuXG5cdHZhciBmaWVsZHMgPSBCYXNlLmVhY2goXG5cdFx0WydhZGQnLCAnc3VidHJhY3QnLCAnbXVsdGlwbHknLCAnZGl2aWRlJywgJ21vZHVsbycsICdlcXVhbHMnLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e1xuXHRcdFx0X19zZWxmOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXHRQb2ludC5pbmplY3QoZmllbGRzKTtcblx0U2l6ZS5pbmplY3QoZmllbGRzKTtcblx0Q29sb3IuaW5qZWN0KGZpZWxkcyk7XG5cblx0ZnVuY3Rpb24gX18kX18obGVmdCwgb3BlcmF0b3IsIHJpZ2h0KSB7XG5cdFx0dmFyIGhhbmRsZXIgPSBiaW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmIChsZWZ0ICYmIGxlZnRbaGFuZGxlcl0pIHtcblx0XHRcdHZhciByZXMgPSBsZWZ0W2hhbmRsZXJdKHJpZ2h0KTtcblx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gJyE9JyA/ICFyZXMgOiByZXM7XG5cdFx0fVxuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuIGxlZnQgKyByaWdodDtcblx0XHRjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcblx0XHRjYXNlICcqJzogcmV0dXJuIGxlZnQgKiByaWdodDtcblx0XHRjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcblx0XHRjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcblx0XHRjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09IHJpZ2h0O1xuXHRcdGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gJF9fKG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHZhciBoYW5kbGVyID0gdW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmICh2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjb21waWxlKGNvZGUsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWNvZGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KG9mZnNldCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpbnNlcnRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW5zZXJ0aW9uID0gaW5zZXJ0aW9uc1tpXTtcblx0XHRcdFx0aWYgKGluc2VydGlvblswXSA+PSBvZmZzZXQpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdG9mZnNldCArPSBpbnNlcnRpb25bMV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvZGUobm9kZSkge1xuXHRcdFx0cmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0XHRnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEJldHdlZW4obGVmdCwgcmlnaHQpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobGVmdC5yYW5nZVsxXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KHJpZ2h0LnJhbmdlWzBdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUNvZGUobm9kZSwgc3RyKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdGVuZCA9IGdldE9mZnNldChub2RlLnJhbmdlWzFdKSxcblx0XHRcdFx0aW5zZXJ0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSBpbnNlcnRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmIChzdGFydCA+IGluc2VydGlvbnNbaV1bMF0pIHtcblx0XHRcdFx0XHRpbnNlcnQgPSBpICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aW5zZXJ0aW9ucy5zcGxpY2UoaW5zZXJ0LCAwLCBbc3RhcnQsIHN0ci5sZW5ndGggLSBlbmQgKyBzdGFydF0pO1xuXHRcdFx0Y29kZSA9IGNvZGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHN0ciArIGNvZGUuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd2Fsa0FTVChub2RlLCBwYXJlbnQpIHtcblx0XHRcdGlmICghbm9kZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5vZGUpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3JhbmdlJyB8fCBrZXkgPT09ICdsb2MnKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHdhbGtBU1QodmFsdWUsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG5vZGUudHlwZSkge1xuXHRcdFx0Y2FzZSAnVW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gdW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUuYXJndW1lbnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJyRfXyhcIicgKyBub2RlLm9wZXJhdG9yICsgJ1wiLCAnXG5cdFx0XHRcdFx0XHRcdCsgYXJnICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ0JpbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiBiaW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdGJldHdlZW4gPSBnZXRCZXR3ZWVuKG5vZGUubGVmdCwgbm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJ19fJF9fKCcgKyBsZWZ0ICsgJywnXG5cdFx0XHRcdFx0XHRcdCsgYmV0d2Vlbi5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwnICsgb3BlcmF0b3IpLFxuXHRcdFx0XHRcdFx0XHRcdCdcIicgKyBvcGVyYXRvciArICdcIicpXG5cdFx0XHRcdFx0XHRcdCsgJywgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuXHRcdFx0Y2FzZSAnQXNzaWdubWVudEV4cHJlc3Npb24nOlxuXHRcdFx0XHR2YXIgcGFyZW50VHlwZSA9IHBhcmVudCAmJiBwYXJlbnQudHlwZTtcblx0XHRcdFx0aWYgKCEoXG5cdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnRm9yU3RhdGVtZW50J1xuXHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ0JpbmFyeUV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdCYmIC9eWz0hPD5dLy50ZXN0KHBhcmVudC5vcGVyYXRvcilcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJyAmJiBwYXJlbnQuY29tcHV0ZWRcblx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdGlmIChub2RlLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCksXG5cdFx0XHRcdFx0XHRcdGV4cCA9ICdfXyRfXygnICsgYXJnICsgJywgXCInICsgbm9kZS5vcGVyYXRvclswXVxuXHRcdFx0XHRcdFx0XHRcdFx0KyAnXCIsIDEpJyxcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJyA9ICcgKyBleHA7XG5cdFx0XHRcdFx0XHRpZiAobm9kZS5wcmVmaXgpIHtcblx0XHRcdFx0XHRcdFx0c3RyID0gJygnICsgc3RyICsgJyknO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyB8fFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJyB8fFxuXHRcdFx0XHRcdFx0XHRwYXJlbnRUeXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoZ2V0Q29kZShwYXJlbnQubGVmdCB8fCBwYXJlbnQuaWQpID09PSBhcmcpXG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gZXhwO1xuXHRcdFx0XHRcdFx0XHRzdHIgPSBhcmcgKyAnOyAnICsgc3RyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgc3RyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKC9eLj0kLy50ZXN0KG5vZGUub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRcdFx0ZXhwID0gbGVmdCArICcgPSBfXyRfXygnICsgbGVmdCArICcsIFwiJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAnICsgcmlnaHQgKyAnKSc7XG5cdFx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIC9eXFwoLipcXCkkLy50ZXN0KGdldENvZGUobm9kZSkpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICcoJyArIGV4cCArICcpJyA6IGV4cCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJzpcblx0XHRcdFx0cmVwbGFjZUNvZGUoe1xuXHRcdFx0XHRcdHJhbmdlOiBbbm9kZS5zdGFydCwgbm9kZS5kZWNsYXJhdGlvbi5zdGFydF1cblx0XHRcdFx0fSwgJ21vZHVsZS5leHBvcnRzID0gJyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbic6XG5cdFx0XHRcdHZhciBkZWNsYXJhdGlvbiA9IG5vZGUuZGVjbGFyYXRpb247XG5cdFx0XHRcdHZhciBzcGVjaWZpZXJzID0gbm9kZS5zcGVjaWZpZXJzO1xuXHRcdFx0XHRpZiAoZGVjbGFyYXRpb24pIHtcblx0XHRcdFx0XHR2YXIgZGVjbGFyYXRpb25zID0gZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zO1xuXHRcdFx0XHRcdGlmIChkZWNsYXJhdGlvbnMpIHtcblx0XHRcdFx0XHRcdGRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlYykge1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShkZWMsICdtb2R1bGUuZXhwb3J0cy4nICsgZ2V0Q29kZShkZWMpKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUoe1xuXHRcdFx0XHRcdFx0XHRyYW5nZTogW1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUuc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0ZGVjbGFyYXRpb24uc3RhcnQgKyBkZWNsYXJhdGlvbi5raW5kLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0XHR9LCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNwZWNpZmllcnMpIHtcblx0XHRcdFx0XHR2YXIgZXhwb3J0cyA9IHNwZWNpZmllcnMubWFwKGZ1bmN0aW9uKHNwZWNpZmllcikge1xuXHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBnZXRDb2RlKHNwZWNpZmllcik7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ21vZHVsZS5leHBvcnRzLicgKyBuYW1lICsgJyA9ICcgKyBuYW1lICsgJzsgJztcblx0XHRcdFx0XHR9KS5qb2luKCcnKTtcblx0XHRcdFx0XHRpZiAoZXhwb3J0cykge1xuXHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgZXhwb3J0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuY29kZVZMUSh2YWx1ZSkge1xuXHRcdFx0dmFyIHJlcyA9ICcnLFxuXHRcdFx0XHRiYXNlNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cdFx0XHR2YWx1ZSA9IChNYXRoLmFicyh2YWx1ZSkgPDwgMSkgKyAodmFsdWUgPCAwID8gMSA6IDApO1xuXHRcdFx0d2hpbGUgKHZhbHVlIHx8ICFyZXMpIHtcblx0XHRcdFx0dmFyIG5leHQgPSB2YWx1ZSAmICgzMiAtIDEpO1xuXHRcdFx0XHR2YWx1ZSA+Pj0gNTtcblx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdG5leHQgfD0gMzI7XG5cdFx0XHRcdHJlcyArPSBiYXNlNjRbbmV4dF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblxuXHRcdHZhciB1cmwgPSBvcHRpb25zLnVybCB8fCAnJyxcblx0XHRcdGFnZW50ID0gcGFwZXIuYWdlbnQsXG5cdFx0XHR2ZXJzaW9uID0gYWdlbnQudmVyc2lvbk51bWJlcixcblx0XHRcdG9mZnNldENvZGUgPSBmYWxzZSxcblx0XHRcdHNvdXJjZU1hcHMgPSBvcHRpb25zLnNvdXJjZU1hcHMsXG5cdFx0XHRzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCBjb2RlLFxuXHRcdFx0bGluZUJyZWFrcyA9IC9cXHJcXG58XFxufFxcci9tZyxcblx0XHRcdG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDAsXG5cdFx0XHRtYXA7XG5cdFx0aWYgKHNvdXJjZU1hcHMgJiYgKGFnZW50LmNocm9tZSAmJiB2ZXJzaW9uID49IDMwXG5cdFx0XHRcdHx8IGFnZW50LndlYmtpdCAmJiB2ZXJzaW9uID49IDUzNy43NlxuXHRcdFx0XHR8fCBhZ2VudC5maXJlZm94ICYmIHZlcnNpb24gPj0gMjNcblx0XHRcdFx0fHwgYWdlbnQubm9kZSkpIHtcblx0XHRcdGlmIChhZ2VudC5ub2RlKSB7XG5cdFx0XHRcdG9mZnNldCAtPSAyO1xuXHRcdFx0fSBlbHNlIGlmICh3aW5kb3cgJiYgdXJsICYmICF3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKHVybCkpIHtcblx0XHRcdFx0dmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTDtcblx0XHRcdFx0b2Zmc2V0ID0gaHRtbC5zdWJzdHIoMCwgaHRtbC5pbmRleE9mKGNvZGUpICsgMSkubWF0Y2goXG5cdFx0XHRcdFx0XHRsaW5lQnJlYWtzKS5sZW5ndGggKyAxO1xuXHRcdFx0fVxuXHRcdFx0b2Zmc2V0Q29kZSA9IG9mZnNldCA+IDAgJiYgIShcblx0XHRcdFx0XHRhZ2VudC5jaHJvbWUgJiYgdmVyc2lvbiA+PSAzNiB8fFxuXHRcdFx0XHRcdGFnZW50LnNhZmFyaSAmJiB2ZXJzaW9uID49IDYwMCB8fFxuXHRcdFx0XHRcdGFnZW50LmZpcmVmb3ggJiYgdmVyc2lvbiA+PSA0MCB8fFxuXHRcdFx0XHRcdGFnZW50Lm5vZGUpO1xuXHRcdFx0dmFyIG1hcHBpbmdzID0gWydBQScgKyBlbmNvZGVWTFEob2Zmc2V0Q29kZSA/IDAgOiBvZmZzZXQpICsgJ0EnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxXG5cdFx0XHRcdFx0KyAob2Zmc2V0Q29kZSA/IG9mZnNldCA6IDApO1xuXHRcdFx0bWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdLFxuXHRcdFx0XHRzb3VyY2VzQ29udGVudDogW3NvdXJjZV1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHdhbGtBU1QocGFyc2UoY29kZSwge1xuXHRcdFx0cmFuZ2VzOiB0cnVlLFxuXHRcdFx0cHJlc2VydmVQYXJlbnM6IHRydWUsXG5cdFx0XHRzb3VyY2VUeXBlOiAnbW9kdWxlJ1xuXHRcdH0pKTtcblx0XHRpZiAobWFwKSB7XG5cdFx0XHRpZiAob2Zmc2V0Q29kZSkge1xuXHRcdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZTtcblx0XHRcdH1cblx0XHRcdGlmICgvXihpbmxpbmV8Ym90aCkkLy50ZXN0KHNvdXJjZU1hcHMpKSB7XG5cdFx0XHRcdGNvZGUgKz0gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0XHQrIHNlbGYuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRcdEpTT04uc3RyaW5naWZ5KG1hcCkpKSk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlICs9IFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArICh1cmwgfHwgJ3BhcGVyc2NyaXB0Jyk7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHNvdXJjZTogc291cmNlLFxuXHRcdFx0Y29kZTogY29kZSxcblx0XHRcdG1hcDogbWFwXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4ZWN1dGUoY29kZSwgc2NvcGUsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXGJ0b29sXFwuXFx3K3xcXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiL1xuXHRcdFx0XHRcdC50ZXN0KGNvZGUpICYmICEvXFxibmV3XFxzK1Rvb2xcXGIvLnRlc3QoY29kZSlcblx0XHRcdFx0XHRcdD8gbmV3IFRvb2woKSA6IG51bGwsXG5cdFx0XHR0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG5cdFx0XHRoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuXHRcdFx0cGFyYW1zID0gW10sXG5cdFx0XHRhcmdzID0gW10sXG5cdFx0XHRmdW5jLFxuXHRcdFx0Y29tcGlsZWQgPSB0eXBlb2YgY29kZSA9PT0gJ29iamVjdCcgPyBjb2RlIDogY29tcGlsZShjb2RlLCBvcHRpb25zKTtcblx0XHRjb2RlID0gY29tcGlsZWQuY29kZTtcblx0XHRmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG5cdFx0XHRcdGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cCgnKFtcXFxcYlxcXFxzXFxcXFddfF4pJ1xuXHRcdFx0XHRcdFx0KyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJncy5wdXNoKHNjb3BlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4cG9zZSh7IF9fJF9fOiBfXyRfXywgJF9fOiAkX18sIHBhcGVyOiBzY29wZSwgdG9vbDogdG9vbCB9LFxuXHRcdFx0XHR0cnVlKTtcblx0XHRleHBvc2Uoc2NvcGUpO1xuXHRcdGNvZGUgPSAndmFyIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfTsgJyArIGNvZGU7XG5cdFx0dmFyIGV4cG9ydHMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdHRoaXMucHVzaCgnbW9kdWxlLmV4cG9ydHMuJyArIGtleSArICcgPSAnICsga2V5ICsgJzsnKTtcblx0XHRcdH1cblx0XHR9LCBbXSkuam9pbignXFxuJyk7XG5cdFx0aWYgKGV4cG9ydHMpIHtcblx0XHRcdGNvZGUgKz0gJ1xcbicgKyBleHBvcnRzO1xuXHRcdH1cblx0XHRjb2RlICs9ICdcXG5yZXR1cm4gbW9kdWxlLmV4cG9ydHM7Jztcblx0XHR2YXIgYWdlbnQgPSBwYXBlci5hZ2VudDtcblx0XHRpZiAoZG9jdW1lbnQgJiYgKGFnZW50LmNocm9tZVxuXHRcdFx0XHR8fCBhZ2VudC5maXJlZm94ICYmIGFnZW50LnZlcnNpb25OdW1iZXIgPCA0MCkpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcblx0XHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0XHRcdGlmIChhZ2VudC5maXJlZm94KVxuXHRcdFx0XHRjb2RlID0gJ1xcbicgKyBjb2RlO1xuXHRcdFx0c2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuXHRcdFx0XHQnZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICtcblx0XHRcdFx0XHRjb2RlICtcblx0XHRcdFx0J1xcbn0nXG5cdFx0XHQpKTtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHRcdGZ1bmMgPSBkb2N1bWVudC5fX3BhcGVyc2NyaXB0X187XG5cdFx0XHRkZWxldGUgZG9jdW1lbnQuX19wYXBlcnNjcmlwdF9fO1xuXHRcdFx0aGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmdW5jID0gRnVuY3Rpb24ocGFyYW1zLCBjb2RlKTtcblx0XHR9XG5cdFx0dmFyIGV4cG9ydHMgPSBmdW5jICYmIGZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3MpO1xuXHRcdHZhciBvYmogPSBleHBvcnRzIHx8IHt9O1xuXHRcdEJhc2UuZWFjaCh0b29sSGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIHZhbHVlID0gb2JqW2tleV07XG5cdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdHRvb2xba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHRpZiAob2JqLm9uUmVzaXplKVxuXHRcdFx0XHR2aWV3LnNldE9uUmVzaXplKG9iai5vblJlc2l6ZSk7XG5cdFx0XHR2aWV3LmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdFx0c2l6ZTogdmlldy5zaXplLFxuXHRcdFx0XHRkZWx0YTogbmV3IFBvaW50KClcblx0XHRcdH0pO1xuXHRcdFx0aWYgKG9iai5vbkZyYW1lKVxuXHRcdFx0XHR2aWV3LnNldE9uRnJhbWUob2JqLm9uRnJhbWUpO1xuXHRcdFx0dmlldy5yZXF1ZXN0VXBkYXRlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBleHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZFNjcmlwdChzY3JpcHQpIHtcblx0XHRpZiAoL150ZXh0XFwvKD86eC18KXBhcGVyc2NyaXB0JC8udGVzdChzY3JpcHQudHlwZSlcblx0XHRcdFx0JiYgUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnaWdub3JlJykgIT09ICd0cnVlJykge1xuXHRcdFx0dmFyIGNhbnZhc0lkID0gUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoc2NyaXB0LCAnY2FudmFzJyksXG5cdFx0XHRcdGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKSxcblx0XHRcdFx0c3JjID0gc2NyaXB0LnNyYyB8fCBzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpLFxuXHRcdFx0XHRhc3luYyA9IFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKHNjcmlwdCwgJ2FzeW5jJyksXG5cdFx0XHRcdHNjb3BlQXR0cmlidXRlID0gJ2RhdGEtcGFwZXItc2NvcGUnO1xuXHRcdFx0aWYgKCFjYW52YXMpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgY2FudmFzIHdpdGggaWQgXCInXG5cdFx0XHRcdFx0XHQrIGNhbnZhc0lkICsgJ1wiJyk7XG5cdFx0XHR2YXIgc2NvcGUgPSBQYXBlclNjb3BlLmdldChjYW52YXMuZ2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlKSlcblx0XHRcdFx0XHRcdHx8IG5ldyBQYXBlclNjb3BlKCkuc2V0dXAoY2FudmFzKTtcblx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUsIHNjb3BlLl9pZCk7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdEh0dHAucmVxdWVzdCh7XG5cdFx0XHRcdFx0dXJsOiBzcmMsXG5cdFx0XHRcdFx0YXN5bmM6IGFzeW5jLFxuXHRcdFx0XHRcdG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG5cdFx0XHRcdFx0b25Mb2FkOiBmdW5jdGlvbihjb2RlKSB7XG5cdFx0XHRcdFx0XHRleGVjdXRlKGNvZGUsIHNjb3BlLCBzcmMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGVjdXRlKHNjcmlwdC5pbm5lckhUTUwsIHNjb3BlLCBzY3JpcHQuYmFzZVVSSSk7XG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScsICd0cnVlJyk7XG5cdFx0XHRyZXR1cm4gc2NvcGU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZEFsbCgpIHtcblx0XHRCYXNlLmVhY2goZG9jdW1lbnQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLFxuXHRcdFx0XHRsb2FkU2NyaXB0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWQoc2NyaXB0KSB7XG5cdFx0cmV0dXJuIHNjcmlwdCA/IGxvYWRTY3JpcHQoc2NyaXB0KSA6IGxvYWRBbGwoKTtcblx0fVxuXG5cdGlmICh3aW5kb3cpIHtcblx0XHRpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuXHRcdFx0c2V0VGltZW91dChsb2FkQWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgeyBsb2FkOiBsb2FkQWxsIH0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlLFxuXHRcdGNhbGN1bGF0ZUJpbmFyeTogX18kX18sXG5cdFx0Y2FsY3VsYXRlVW5hcnk6ICRfX1xuXHR9O1xuXG59LmNhbGwodGhpcyk7XG5cbnZhciBwYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG5cdEJhc2U6IEJhc2UsXG5cdE51bWVyaWNhbDogTnVtZXJpY2FsLFxuXHRLZXk6IEtleSxcblx0RG9tRXZlbnQ6IERvbUV2ZW50LFxuXHREb21FbGVtZW50OiBEb21FbGVtZW50LFxuXHRkb2N1bWVudDogZG9jdW1lbnQsXG5cdHdpbmRvdzogd2luZG93LFxuXHRTeW1ib2w6IFN5bWJvbERlZmluaXRpb24sXG5cdFBsYWNlZFN5bWJvbDogU3ltYm9sSXRlbVxufSkpKCk7XG5cbmlmIChwYXBlci5hZ2VudC5ub2RlKSB7XG5cdHJlcXVpcmUoJy4vbm9kZS9leHRlbmQuanMnKShwYXBlcik7XG59XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcGFwZXI7XG59XG5cbnJldHVybiBwYXBlcjtcbn0uY2FsbCh0aGlzLCB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDogbnVsbCk7XG4iLCIvKipcclxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xyXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICB2YXIgc3RyID0gJyc7XHJcblxyXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xyXG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XHJcbiAgdmFyIHFyeSA9IHt9O1xyXG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcclxuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gIH1cclxuICByZXR1cm4gcXJ5O1xyXG59O1xyXG4iLCIvKipcclxuICogUGFyc2VzIGFuIFVSSVxyXG4gKlxyXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xyXG5cclxudmFyIHBhcnRzID0gW1xyXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xyXG4gICAgdmFyIHNyYyA9IHN0cixcclxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcclxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcclxuXHJcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcclxuICAgICAgICB1cmkgPSB7fSxcclxuICAgICAgICBpID0gMTQ7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcclxuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcclxuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xyXG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXJpO1xyXG59O1xyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gcmFuZG9tQ29sb3IgYnkgRGF2aWQgTWVyZmllbGQgdW5kZXIgdGhlIENDMCBsaWNlbnNlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRtZXJmaWVsZC9yYW5kb21Db2xvci9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgLy8gU3VwcG9ydCBDb21tb25KU1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJhbmRvbUNvbG9yID0gZmFjdG9yeSgpO1xuXG4gICAgLy8gU3VwcG9ydCBOb2RlSlMgJiBDb21wb25lbnQsIHdoaWNoIGFsbG93IG1vZHVsZS5leHBvcnRzIHRvIGJlIGEgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByYW5kb21Db2xvcjtcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IENvbW1vbkpTIDEuMS4xIHNwZWNcbiAgICBleHBvcnRzLnJhbmRvbUNvbG9yID0gcmFuZG9tQ29sb3I7XG5cbiAgLy8gU3VwcG9ydCBBTURcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZhY3RvcnkpO1xuXG4gIC8vIFN1cHBvcnQgdmFuaWxsYSBzY3JpcHQgbG9hZGluZ1xuICB9IGVsc2Uge1xuICAgIHJvb3QucmFuZG9tQ29sb3IgPSBmYWN0b3J5KCk7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbigpIHtcblxuICAvLyBTZWVkIHRvIGdldCByZXBlYXRhYmxlIGNvbG9yc1xuICB2YXIgc2VlZCA9IG51bGw7XG5cbiAgLy8gU2hhcmVkIGNvbG9yIGRpY3Rpb25hcnlcbiAgdmFyIGNvbG9yRGljdGlvbmFyeSA9IHt9O1xuXG4gIC8vIFBvcHVsYXRlIHRoZSBjb2xvciBkaWN0aW9uYXJ5XG4gIGxvYWRDb2xvckJvdW5kcygpO1xuXG4gIC8vIGNoZWNrIGlmIGEgcmFuZ2UgaXMgdGFrZW5cbiAgdmFyIGNvbG9yUmFuZ2VzID0gW107XG5cbiAgdmFyIHJhbmRvbUNvbG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBzZWVkIGFuZCBlbnN1cmUgaXQncyBhblxuICAgIC8vIGludGVnZXIuIE90aGVyd2lzZSwgcmVzZXQgdGhlIHNlZWQgdmFsdWUuXG4gICAgaWYgKG9wdGlvbnMuc2VlZCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2VlZCAhPT0gbnVsbCAmJiBvcHRpb25zLnNlZWQgPT09IHBhcnNlSW50KG9wdGlvbnMuc2VlZCwgMTApKSB7XG4gICAgICBzZWVkID0gb3B0aW9ucy5zZWVkO1xuXG4gICAgLy8gQSBzdHJpbmcgd2FzIHBhc3NlZCBhcyBhIHNlZWRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnNlZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWVkID0gc3RyaW5nVG9JbnRlZ2VyKG9wdGlvbnMuc2VlZCk7XG5cbiAgICAvLyBTb21ldGhpbmcgd2FzIHBhc3NlZCBhcyBhIHNlZWQgYnV0IGl0IHdhc24ndCBhbiBpbnRlZ2VyIG9yIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZWVkICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zZWVkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc2VlZCB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXIgb3Igc3RyaW5nJyk7XG5cbiAgICAvLyBObyBzZWVkLCByZXNldCB0aGUgdmFsdWUgb3V0c2lkZS5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIEgsUyxCO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBnZW5lcmF0ZSBtdWx0aXBsZSBjb2xvcnNcbiAgICBpZiAob3B0aW9ucy5jb3VudCAhPT0gbnVsbCAmJiBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgdmFyIHRvdGFsQ29sb3JzID0gb3B0aW9ucy5jb3VudCxcbiAgICAgICAgICBjb2xvcnMgPSBbXTtcbiAgICAgIC8vIFZhbHVlIGZhbHNlIGF0IGluZGV4IGkgbWVhbnMgdGhlIHJhbmdlIGkgaXMgbm90IHRha2VuIHlldC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5jb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbG9yUmFuZ2VzLnB1c2goZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIG9wdGlvbnMuY291bnQgPSBudWxsO1xuXG4gICAgICB3aGlsZSAodG90YWxDb2xvcnMgPiBjb2xvcnMubGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgZ2VuZXJhdGluZyBtdWx0aXBsZSBjb2xvcnMsXG4gICAgICAgIC8vIGluY3JlbWVtZW50IHRoZSBzZWVkLiBPdGhlcndpc2Ugd2UnZCBqdXN0XG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZSBzYW1lIGNvbG9yIGVhY2ggdGltZS4uLlxuICAgICAgICBpZiAoc2VlZCAmJiBvcHRpb25zLnNlZWQpIG9wdGlvbnMuc2VlZCArPSAxO1xuXG4gICAgICAgIGNvbG9ycy5wdXNoKHJhbmRvbUNvbG9yKG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5jb3VudCA9IHRvdGFsQ29sb3JzO1xuXG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIHBpY2sgYSBodWUgKEgpXG4gICAgSCA9IHBpY2tIdWUob3B0aW9ucyk7XG5cbiAgICAvLyBUaGVuIHVzZSBIIHRvIGRldGVybWluZSBzYXR1cmF0aW9uIChTKVxuICAgIFMgPSBwaWNrU2F0dXJhdGlvbihILCBvcHRpb25zKTtcblxuICAgIC8vIFRoZW4gdXNlIFMgYW5kIEggdG8gZGV0ZXJtaW5lIGJyaWdodG5lc3MgKEIpLlxuICAgIEIgPSBwaWNrQnJpZ2h0bmVzcyhILCBTLCBvcHRpb25zKTtcblxuICAgIC8vIFRoZW4gd2UgcmV0dXJuIHRoZSBIU0IgY29sb3IgaW4gdGhlIGRlc2lyZWQgZm9ybWF0XG4gICAgcmV0dXJuIHNldEZvcm1hdChbSCxTLEJdLCBvcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwaWNrSHVlKG9wdGlvbnMpIHtcbiAgICBpZiAoY29sb3JSYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGh1ZVJhbmdlID0gZ2V0UmVhbEh1ZVJhbmdlKG9wdGlvbnMuaHVlKVxuXG4gICAgICB2YXIgaHVlID0gcmFuZG9tV2l0aGluKGh1ZVJhbmdlKVxuXG4gICAgICAvL0VhY2ggb2YgY29sb3JSYW5nZXMubGVuZ3RoIHJhbmdlcyBoYXMgYSBsZW5ndGggZXF1YWwgYXBwcm94aW1hdGVsbHkgb25lIHN0ZXBcbiAgICAgIHZhciBzdGVwID0gKGh1ZVJhbmdlWzFdIC0gaHVlUmFuZ2VbMF0pIC8gY29sb3JSYW5nZXMubGVuZ3RoXG5cbiAgICAgIHZhciBqID0gcGFyc2VJbnQoKGh1ZSAtIGh1ZVJhbmdlWzBdKSAvIHN0ZXApXG5cbiAgICAgIC8vQ2hlY2sgaWYgdGhlIHJhbmdlIGogaXMgdGFrZW5cbiAgICAgIGlmIChjb2xvclJhbmdlc1tqXSA9PT0gdHJ1ZSkge1xuICAgICAgICBqID0gKGogKyAyKSAlIGNvbG9yUmFuZ2VzLmxlbmd0aFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbG9yUmFuZ2VzW2pdID0gdHJ1ZVxuICAgICAgICAgICB9XG5cbiAgICAgIHZhciBtaW4gPSAoaHVlUmFuZ2VbMF0gKyBqICogc3RlcCkgJSAzNTksXG4gICAgICAgICAgbWF4ID0gKGh1ZVJhbmdlWzBdICsgKGogKyAxKSAqIHN0ZXApICUgMzU5O1xuXG4gICAgICBodWVSYW5nZSA9IFttaW4sIG1heF1cblxuICAgICAgaHVlID0gcmFuZG9tV2l0aGluKGh1ZVJhbmdlKVxuXG4gICAgICBpZiAoaHVlIDwgMCkge2h1ZSA9IDM2MCArIGh1ZTt9XG4gICAgICByZXR1cm4gaHVlXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGh1ZVJhbmdlID0gZ2V0SHVlUmFuZ2Uob3B0aW9ucy5odWUpXG5cbiAgICAgIGh1ZSA9IHJhbmRvbVdpdGhpbihodWVSYW5nZSk7XG4gICAgICAvLyBJbnN0ZWFkIG9mIHN0b3JpbmcgcmVkIGFzIHR3byBzZXBlcmF0ZSByYW5nZXMsXG4gICAgICAvLyB3ZSBncm91cCB0aGVtLCB1c2luZyBuZWdhdGl2ZSBudW1iZXJzXG4gICAgICBpZiAoaHVlIDwgMCkge1xuICAgICAgICBodWUgPSAzNjAgKyBodWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGlja1NhdHVyYXRpb24gKGh1ZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMuaHVlID09PSAnbW9ub2Nocm9tZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmx1bWlub3NpdHkgPT09ICdyYW5kb20nKSB7XG4gICAgICByZXR1cm4gcmFuZG9tV2l0aGluKFswLDEwMF0pO1xuICAgIH1cblxuICAgIHZhciBzYXR1cmF0aW9uUmFuZ2UgPSBnZXRTYXR1cmF0aW9uUmFuZ2UoaHVlKTtcblxuICAgIHZhciBzTWluID0gc2F0dXJhdGlvblJhbmdlWzBdLFxuICAgICAgICBzTWF4ID0gc2F0dXJhdGlvblJhbmdlWzFdO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnYnJpZ2h0JzpcbiAgICAgICAgc01pbiA9IDU1O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIHNNaW4gPSBzTWF4IC0gMTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIHNNYXggPSA1NTtcbiAgICAgICAgYnJlYWs7XG4gICB9XG5cbiAgICByZXR1cm4gcmFuZG9tV2l0aGluKFtzTWluLCBzTWF4XSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBpY2tCcmlnaHRuZXNzIChILCBTLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgYk1pbiA9IGdldE1pbmltdW1CcmlnaHRuZXNzKEgsIFMpLFxuICAgICAgICBiTWF4ID0gMTAwO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIGJNYXggPSBiTWluICsgMjA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIGJNaW4gPSAoYk1heCArIGJNaW4pLzI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYW5kb20nOlxuICAgICAgICBiTWluID0gMDtcbiAgICAgICAgYk1heCA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmRvbVdpdGhpbihbYk1pbiwgYk1heF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Rm9ybWF0IChoc3YsIG9wdGlvbnMpIHtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5mb3JtYXQpIHtcblxuICAgICAgY2FzZSAnaHN2QXJyYXknOlxuICAgICAgICByZXR1cm4gaHN2O1xuXG4gICAgICBjYXNlICdoc2xBcnJheSc6XG4gICAgICAgIHJldHVybiBIU1Z0b0hTTChoc3YpO1xuXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICB2YXIgaHNsID0gSFNWdG9IU0woaHN2KTtcbiAgICAgICAgcmV0dXJuICdoc2woJytoc2xbMF0rJywgJytoc2xbMV0rJyUsICcraHNsWzJdKyclKSc7XG5cbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICB2YXIgaHNsQ29sb3IgPSBIU1Z0b0hTTChoc3YpO1xuICAgICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLmFscGhhIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiAnaHNsYSgnK2hzbENvbG9yWzBdKycsICcraHNsQ29sb3JbMV0rJyUsICcraHNsQ29sb3JbMl0rJyUsICcgKyBhbHBoYSArICcpJztcblxuICAgICAgY2FzZSAncmdiQXJyYXknOlxuICAgICAgICByZXR1cm4gSFNWdG9SR0IoaHN2KTtcblxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgdmFyIHJnYiA9IEhTVnRvUkdCKGhzdik7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyByZ2Iuam9pbignLCAnKSArICcpJztcblxuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIHZhciByZ2JDb2xvciA9IEhTVnRvUkdCKGhzdik7XG4gICAgICAgIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JDb2xvci5qb2luKCcsICcpICsgJywgJyArIGFscGhhICsgJyknO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gSFNWdG9IZXgoaHN2KTtcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbmltdW1CcmlnaHRuZXNzKEgsIFMpIHtcblxuICAgIHZhciBsb3dlckJvdW5kcyA9IGdldENvbG9ySW5mbyhIKS5sb3dlckJvdW5kcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG93ZXJCb3VuZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgIHZhciBzMSA9IGxvd2VyQm91bmRzW2ldWzBdLFxuICAgICAgICAgIHYxID0gbG93ZXJCb3VuZHNbaV1bMV07XG5cbiAgICAgIHZhciBzMiA9IGxvd2VyQm91bmRzW2krMV1bMF0sXG4gICAgICAgICAgdjIgPSBsb3dlckJvdW5kc1tpKzFdWzFdO1xuXG4gICAgICBpZiAoUyA+PSBzMSAmJiBTIDw9IHMyKSB7XG5cbiAgICAgICAgIHZhciBtID0gKHYyIC0gdjEpLyhzMiAtIHMxKSxcbiAgICAgICAgICAgICBiID0gdjEgLSBtKnMxO1xuXG4gICAgICAgICByZXR1cm4gbSpTICsgYjtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SHVlUmFuZ2UgKGNvbG9ySW5wdXQpIHtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VJbnQoY29sb3JJbnB1dCkgPT09ICdudW1iZXInKSB7XG5cbiAgICAgIHZhciBudW1iZXIgPSBwYXJzZUludChjb2xvcklucHV0KTtcblxuICAgICAgaWYgKG51bWJlciA8IDM2MCAmJiBudW1iZXIgPiAwKSB7XG4gICAgICAgIHJldHVybiBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvcklucHV0ID09PSAnc3RyaW5nJykge1xuXG4gICAgICBpZiAoY29sb3JEaWN0aW9uYXJ5W2NvbG9ySW5wdXRdKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGNvbG9yRGljdGlvbmFyeVtjb2xvcklucHV0XTtcbiAgICAgICAgaWYgKGNvbG9yLmh1ZVJhbmdlKSB7cmV0dXJuIGNvbG9yLmh1ZVJhbmdlO31cbiAgICAgIH0gZWxzZSBpZiAoY29sb3JJbnB1dC5tYXRjaCgvXiM/KFswLTlBLUZdezN9fFswLTlBLUZdezZ9KSQvaSkpIHtcbiAgICAgICAgdmFyIGh1ZSA9IEhleFRvSFNCKGNvbG9ySW5wdXQpWzBdO1xuICAgICAgICByZXR1cm4gWyBodWUsIGh1ZSBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbMCwzNjBdO1xuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTYXR1cmF0aW9uUmFuZ2UgKGh1ZSkge1xuICAgIHJldHVybiBnZXRDb2xvckluZm8oaHVlKS5zYXR1cmF0aW9uUmFuZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2xvckluZm8gKGh1ZSkge1xuXG4gICAgLy8gTWFwcyByZWQgY29sb3JzIHRvIG1ha2UgcGlja2luZyBodWUgZWFzaWVyXG4gICAgaWYgKGh1ZSA+PSAzMzQgJiYgaHVlIDw9IDM2MCkge1xuICAgICAgaHVlLT0gMzYwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGNvbG9yTmFtZSBpbiBjb2xvckRpY3Rpb25hcnkpIHtcbiAgICAgICB2YXIgY29sb3IgPSBjb2xvckRpY3Rpb25hcnlbY29sb3JOYW1lXTtcbiAgICAgICBpZiAoY29sb3IuaHVlUmFuZ2UgJiZcbiAgICAgICAgICAgaHVlID49IGNvbG9yLmh1ZVJhbmdlWzBdICYmXG4gICAgICAgICAgIGh1ZSA8PSBjb2xvci5odWVSYW5nZVsxXSkge1xuICAgICAgICAgIHJldHVybiBjb2xvckRpY3Rpb25hcnlbY29sb3JOYW1lXTtcbiAgICAgICB9XG4gICAgfSByZXR1cm4gJ0NvbG9yIG5vdCBmb3VuZCc7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21XaXRoaW4gKHJhbmdlKSB7XG4gICAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICAgIC8vZ2VuZXJhdGUgcmFuZG9tIGV2ZW5seSBkZXN0aW5jdCBudW1iZXIgZnJvbSA6IGh0dHBzOi8vbWFydGluLmFua2VybC5jb20vMjAwOS8xMi8wOS9ob3ctdG8tY3JlYXRlLXJhbmRvbS1jb2xvcnMtcHJvZ3JhbW1hdGljYWxseS9cbiAgICAgIHZhciBnb2xkZW5fcmF0aW8gPSAwLjYxODAzMzk4ODc0OTg5NVxuICAgICAgdmFyIHI9TWF0aC5yYW5kb20oKVxuICAgICAgciArPSBnb2xkZW5fcmF0aW9cbiAgICAgIHIgJT0gMVxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmFuZ2VbMF0gKyByKihyYW5nZVsxXSArIDEgLSByYW5nZVswXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL1NlZWRlZCByYW5kb20gYWxnb3JpdGhtIGZyb20gaHR0cDovL2luZGllZ2Ftci5jb20vZ2VuZXJhdGUtcmVwZWF0YWJsZS1yYW5kb20tbnVtYmVycy1pbi1qcy9cbiAgICAgIHZhciBtYXggPSByYW5nZVsxXSB8fCAxO1xuICAgICAgdmFyIG1pbiA9IHJhbmdlWzBdIHx8IDA7XG4gICAgICBzZWVkID0gKHNlZWQgKiA5MzAxICsgNDkyOTcpICUgMjMzMjgwO1xuICAgICAgdmFyIHJuZCA9IHNlZWQgLyAyMzMyODAuMDtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKG1pbiArIHJuZCAqIChtYXggLSBtaW4pKTtcbn1cbiAgfVxuXG4gIGZ1bmN0aW9uIEhTVnRvSGV4IChoc3Ype1xuXG4gICAgdmFyIHJnYiA9IEhTVnRvUkdCKGhzdik7XG5cbiAgICBmdW5jdGlvbiBjb21wb25lbnRUb0hleChjKSB7XG4gICAgICAgIHZhciBoZXggPSBjLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9XG5cbiAgICB2YXIgaGV4ID0gJyMnICsgY29tcG9uZW50VG9IZXgocmdiWzBdKSArIGNvbXBvbmVudFRvSGV4KHJnYlsxXSkgKyBjb21wb25lbnRUb0hleChyZ2JbMl0pO1xuXG4gICAgcmV0dXJuIGhleDtcblxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29sb3IgKG5hbWUsIGh1ZVJhbmdlLCBsb3dlckJvdW5kcykge1xuXG4gICAgdmFyIHNNaW4gPSBsb3dlckJvdW5kc1swXVswXSxcbiAgICAgICAgc01heCA9IGxvd2VyQm91bmRzW2xvd2VyQm91bmRzLmxlbmd0aCAtIDFdWzBdLFxuXG4gICAgICAgIGJNaW4gPSBsb3dlckJvdW5kc1tsb3dlckJvdW5kcy5sZW5ndGggLSAxXVsxXSxcbiAgICAgICAgYk1heCA9IGxvd2VyQm91bmRzWzBdWzFdO1xuXG4gICAgY29sb3JEaWN0aW9uYXJ5W25hbWVdID0ge1xuICAgICAgaHVlUmFuZ2U6IGh1ZVJhbmdlLFxuICAgICAgbG93ZXJCb3VuZHM6IGxvd2VyQm91bmRzLFxuICAgICAgc2F0dXJhdGlvblJhbmdlOiBbc01pbiwgc01heF0sXG4gICAgICBicmlnaHRuZXNzUmFuZ2U6IFtiTWluLCBiTWF4XVxuICAgIH07XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRDb2xvckJvdW5kcyAoKSB7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdtb25vY2hyb21lJyxcbiAgICAgIG51bGwsXG4gICAgICBbWzAsMF0sWzEwMCwwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncmVkJyxcbiAgICAgIFstMjYsMThdLFxuICAgICAgW1syMCwxMDBdLFszMCw5Ml0sWzQwLDg5XSxbNTAsODVdLFs2MCw3OF0sWzcwLDcwXSxbODAsNjBdLFs5MCw1NV0sWzEwMCw1MF1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ29yYW5nZScsXG4gICAgICBbMTksNDZdLFxuICAgICAgW1syMCwxMDBdLFszMCw5M10sWzQwLDg4XSxbNTAsODZdLFs2MCw4NV0sWzcwLDcwXSxbMTAwLDcwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAneWVsbG93JyxcbiAgICAgIFs0Nyw2Ml0sXG4gICAgICBbWzI1LDEwMF0sWzQwLDk0XSxbNTAsODldLFs2MCw4Nl0sWzcwLDg0XSxbODAsODJdLFs5MCw4MF0sWzEwMCw3NV1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ2dyZWVuJyxcbiAgICAgIFs2MywxNzhdLFxuICAgICAgW1szMCwxMDBdLFs0MCw5MF0sWzUwLDg1XSxbNjAsODFdLFs3MCw3NF0sWzgwLDY0XSxbOTAsNTBdLFsxMDAsNDBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdibHVlJyxcbiAgICAgIFsxNzksIDI1N10sXG4gICAgICBbWzIwLDEwMF0sWzMwLDg2XSxbNDAsODBdLFs1MCw3NF0sWzYwLDYwXSxbNzAsNTJdLFs4MCw0NF0sWzkwLDM5XSxbMTAwLDM1XV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncHVycGxlJyxcbiAgICAgIFsyNTgsIDI4Ml0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDg3XSxbNDAsNzldLFs1MCw3MF0sWzYwLDY1XSxbNzAsNTldLFs4MCw1Ml0sWzkwLDQ1XSxbMTAwLDQyXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAncGluaycsXG4gICAgICBbMjgzLCAzMzRdLFxuICAgICAgW1syMCwxMDBdLFszMCw5MF0sWzQwLDg2XSxbNjAsODRdLFs4MCw4MF0sWzkwLDc1XSxbMTAwLDczXV1cbiAgICApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBIU1Z0b1JHQiAoaHN2KSB7XG5cbiAgICAvLyB0aGlzIGRvZXNuJ3Qgd29yayBmb3IgdGhlIHZhbHVlcyBvZiAwIGFuZCAzNjBcbiAgICAvLyBoZXJlJ3MgdGhlIGhhY2t5IGZpeFxuICAgIHZhciBoID0gaHN2WzBdO1xuICAgIGlmIChoID09PSAwKSB7aCA9IDE7fVxuICAgIGlmIChoID09PSAzNjApIHtoID0gMzU5O31cblxuICAgIC8vIFJlYmFzZSB0aGUgaCxzLHYgdmFsdWVzXG4gICAgaCA9IGgvMzYwO1xuICAgIHZhciBzID0gaHN2WzFdLzEwMCxcbiAgICAgICAgdiA9IGhzdlsyXS8xMDA7XG5cbiAgICB2YXIgaF9pID0gTWF0aC5mbG9vcihoKjYpLFxuICAgICAgZiA9IGggKiA2IC0gaF9pLFxuICAgICAgcCA9IHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IHYgKiAoMSAtIGYqcyksXG4gICAgICB0ID0gdiAqICgxIC0gKDEgLSBmKSpzKSxcbiAgICAgIHIgPSAyNTYsXG4gICAgICBnID0gMjU2LFxuICAgICAgYiA9IDI1NjtcblxuICAgIHN3aXRjaChoX2kpIHtcbiAgICAgIGNhc2UgMDogciA9IHY7IGcgPSB0OyBiID0gcDsgIGJyZWFrO1xuICAgICAgY2FzZSAxOiByID0gcTsgZyA9IHY7IGIgPSBwOyAgYnJlYWs7XG4gICAgICBjYXNlIDI6IHIgPSBwOyBnID0gdjsgYiA9IHQ7ICBicmVhaztcbiAgICAgIGNhc2UgMzogciA9IHA7IGcgPSBxOyBiID0gdjsgIGJyZWFrO1xuICAgICAgY2FzZSA0OiByID0gdDsgZyA9IHA7IGIgPSB2OyAgYnJlYWs7XG4gICAgICBjYXNlIDU6IHIgPSB2OyBnID0gcDsgYiA9IHE7ICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW01hdGguZmxvb3IocioyNTUpLCBNYXRoLmZsb29yKGcqMjU1KSwgTWF0aC5mbG9vcihiKjI1NSldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBIZXhUb0hTQiAoaGV4KSB7XG4gICAgaGV4ID0gaGV4LnJlcGxhY2UoL14jLywgJycpO1xuICAgIGhleCA9IGhleC5sZW5ndGggPT09IDMgPyBoZXgucmVwbGFjZSgvKC4pL2csICckMSQxJykgOiBoZXg7XG5cbiAgICB2YXIgcmVkID0gcGFyc2VJbnQoaGV4LnN1YnN0cigwLCAyKSwgMTYpIC8gMjU1LFxuICAgICAgICAgIGdyZWVuID0gcGFyc2VJbnQoaGV4LnN1YnN0cigyLCAyKSwgMTYpIC8gMjU1LFxuICAgICAgICAgIGJsdWUgPSBwYXJzZUludChoZXguc3Vic3RyKDQsIDIpLCAxNikgLyAyNTU7XG5cbiAgICB2YXIgY01heCA9IE1hdGgubWF4KHJlZCwgZ3JlZW4sIGJsdWUpLFxuICAgICAgICAgIGRlbHRhID0gY01heCAtIE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpLFxuICAgICAgICAgIHNhdHVyYXRpb24gPSBjTWF4ID8gKGRlbHRhIC8gY01heCkgOiAwO1xuXG4gICAgc3dpdGNoIChjTWF4KSB7XG4gICAgICBjYXNlIHJlZDogcmV0dXJuIFsgNjAgKiAoKChncmVlbiAtIGJsdWUpIC8gZGVsdGEpICUgNikgfHwgMCwgc2F0dXJhdGlvbiwgY01heCBdO1xuICAgICAgY2FzZSBncmVlbjogcmV0dXJuIFsgNjAgKiAoKChibHVlIC0gcmVkKSAvIGRlbHRhKSArIDIpIHx8IDAsIHNhdHVyYXRpb24sIGNNYXggXTtcbiAgICAgIGNhc2UgYmx1ZTogcmV0dXJuIFsgNjAgKiAoKChyZWQgLSBncmVlbikgLyBkZWx0YSkgKyA0KSB8fCAwLCBzYXR1cmF0aW9uLCBjTWF4IF07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gSFNWdG9IU0wgKGhzdikge1xuICAgIHZhciBoID0gaHN2WzBdLFxuICAgICAgcyA9IGhzdlsxXS8xMDAsXG4gICAgICB2ID0gaHN2WzJdLzEwMCxcbiAgICAgIGsgPSAoMi1zKSp2O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGgsXG4gICAgICBNYXRoLnJvdW5kKHMqdiAvIChrPDEgPyBrIDogMi1rKSAqIDEwMDAwKSAvIDEwMCxcbiAgICAgIGsvMiAqIDEwMFxuICAgIF07XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0ludGVnZXIgKHN0cmluZykge1xuICAgIHZhciB0b3RhbCA9IDBcbiAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodG90YWwgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIGJyZWFrO1xuICAgICAgdG90YWwgKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsXG4gIH1cblxuICAvLyBnZXQgVGhlIHJhbmdlIG9mIGdpdmVuIGh1ZSB3aGVuIG9wdGlvbnMuY291bnQhPTBcbiAgZnVuY3Rpb24gZ2V0UmVhbEh1ZVJhbmdlKGNvbG9ySHVlKVxuICB7IGlmICghaXNOYU4oY29sb3JIdWUpKSB7XG4gICAgdmFyIG51bWJlciA9IHBhcnNlSW50KGNvbG9ySHVlKTtcblxuICAgIGlmIChudW1iZXIgPCAzNjAgJiYgbnVtYmVyID4gMCkge1xuICAgICAgcmV0dXJuIGdldENvbG9ySW5mbyhjb2xvckh1ZSkuaHVlUmFuZ2VcbiAgICB9XG4gIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY29sb3JIdWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgIGlmIChjb2xvckRpY3Rpb25hcnlbY29sb3JIdWVdKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGNvbG9yRGljdGlvbmFyeVtjb2xvckh1ZV07XG5cbiAgICAgICAgaWYgKGNvbG9yLmh1ZVJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yLmh1ZVJhbmdlXG4gICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29sb3JIdWUubWF0Y2goL14jPyhbMC05QS1GXXszfXxbMC05QS1GXXs2fSkkL2kpKSB7XG4gICAgICAgIHZhciBodWUgPSBIZXhUb0hTQihjb2xvckh1ZSlbMF1cbiAgICAgICAgcmV0dXJuIGdldENvbG9ySW5mbyhodWUpLmh1ZVJhbmdlXG4gICAgfVxuICB9XG5cbiAgICByZXR1cm4gWzAsMzYwXVxufVxuICByZXR1cm4gcmFuZG9tQ29sb3I7XG59KSk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuICB2YXIgbmV3Q29ubmVjdGlvbiA9IG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG4gIHZhciBpbztcblxuICBpZiAobmV3Q29ubmVjdGlvbikge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuICBpZiAocGFyc2VkLnF1ZXJ5ICYmICFvcHRzLnF1ZXJ5KSB7XG4gICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeTtcbiAgfVxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIElFNisgaGFzT3duUHJvcGVydHlcbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIgKHVyaSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0aW5nID0gW107XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHZhciBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5uc3BzLCBuc3ApKSB7XG4gICAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZW5lcmF0ZSBgc29ja2V0LmlkYCBmb3IgdGhlIGdpdmVuIGBuc3BgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5zcFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIChuc3ApIHtcbiAgcmV0dXJuIChuc3AgPT09ICcvJyA/ICcnIDogKG5zcCArICcjJykpICsgdGhpcy5lbmdpbmUuaWQ7XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbiAodikge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoZm4sIG9wdHMpIHtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAncGluZycsIGJpbmQodGhpcywgJ29ucGluZycpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ3BvbmcnLCBiaW5kKHRoaXMsICdvbnBvbmcnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBwaW5nLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlKCk7XG4gIHRoaXMuZW1pdEFsbCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnBvbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdEFsbCgncG9uZycsIG5ldyBEYXRlKCkgLSB0aGlzLmxhc3RQaW5nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24gKG5zcCwgb3B0cykge1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZ2VuZXJhdGVJZChuc3ApO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHtcbiAgICAgIC8vIG1hbnVhbGx5IGNhbGwgaGVyZSBzaW5jZSBjb25uZWN0aW5nIGV2ZW50IGlzIGZpcmVkIGJlZm9yZSBsaXN0ZW5pbmdcbiAgICAgIG9uQ29ubmVjdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29ubmVjdGluZyAoKSB7XG4gICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RpbmcsIHNvY2tldCkpIHtcbiAgICAgIHNlbGYuY29ubmVjdGluZy5wdXNoKHNvY2tldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0aW5nLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGluZy5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHBhY2tldC5xdWVyeSAmJiBwYWNrZXQudHlwZSA9PT0gMCkgcGFja2V0Lm5zcCArPSAnPycgKyBwYWNrZXQucXVlcnk7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbiAoZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0sIHBhY2tldC5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcblxuICB2YXIgc3Vic0xlbmd0aCA9IHRoaXMuc3Vicy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpO1xuICAgIHN1Yi5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMubGFzdFBpbmcgPSBudWxsO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnZGlzY29ubmVjdCcpO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICBpZiAoJ29wZW5pbmcnID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBgb25jbG9zZWAgd2lsbCBub3QgZmlyZSBiZWNhdXNlXG4gICAgLy8gYW4gb3BlbiBldmVudCBuZXZlciBoYXBwZW5lZFxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ29uY2xvc2UnKTtcblxuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcblxuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uIChvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnkyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBjb25uZWN0aW5nOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDEsXG4gIHBpbmc6IDEsXG4gIHBvbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0IChpbywgbnNwLCBvcHRzKSB7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5mbGFncyA9IHt9O1xuICBpZiAob3B0cyAmJiBvcHRzLnF1ZXJ5KSB7XG4gICAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIH1cbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2KSB7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYWNrZXQgPSB7XG4gICAgdHlwZTogKHRoaXMuZmxhZ3MuYmluYXJ5ICE9PSB1bmRlZmluZWQgPyB0aGlzLmZsYWdzLmJpbmFyeSA6IGhhc0JpbihhcmdzKSkgPyBwYXJzZXIuQklOQVJZX0VWRU5UIDogcGFyc2VyLkVWRU5ULFxuICAgIGRhdGE6IGFyZ3NcbiAgfTtcblxuICBwYWNrZXQub3B0aW9ucyA9IHt9O1xuICBwYWNrZXQub3B0aW9ucy5jb21wcmVzcyA9ICF0aGlzLmZsYWdzIHx8IGZhbHNlICE9PSB0aGlzLmZsYWdzLmNvbXByZXNzO1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHRoaXMuZmxhZ3MgPSB7fTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9PSB0aGlzLm5zcCkge1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnkgPSB0eXBlb2YgdGhpcy5xdWVyeSA9PT0gJ29iamVjdCcgPyBwYXJzZXFzLmVuY29kZSh0aGlzLnF1ZXJ5KSA6IHRoaXMucXVlcnk7XG4gICAgICBkZWJ1Zygnc2VuZGluZyBjb25uZWN0IHBhY2tldCB3aXRoIHF1ZXJ5ICVzJywgcXVlcnkpO1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNULCBxdWVyeTogcXVlcnl9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWNrZXQoe3R5cGU6IHBhcnNlci5DT05ORUNUfSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBzYW1lTmFtZXNwYWNlID0gcGFja2V0Lm5zcCA9PT0gdGhpcy5uc3A7XG4gIHZhciByb290TmFtZXNwYWNlRXJyb3IgPSBwYWNrZXQudHlwZSA9PT0gcGFyc2VyLkVSUk9SICYmIHBhY2tldC5uc3AgPT09ICcvJztcblxuICBpZiAoIXNhbWVOYW1lc3BhY2UgJiYgIXJvb3ROYW1lc3BhY2VFcnJvcikgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0ssXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHZhciBhY2sgPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBhY2spIHtcbiAgICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdiYWQgYWNrICVzJywgcGFja2V0LmlkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNvbXByZXNzID0gZnVuY3Rpb24gKGNvbXByZXNzKSB7XG4gIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGJpbmFyeSBmbGFnXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRoZSBlbWl0dGVkIGRhdGEgY29udGFpbnMgYmluYXJ5XG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5iaW5hcnkgPSBmdW5jdGlvbiAoYmluYXJ5KSB7XG4gIHRoaXMuZmxhZ3MuYmluYXJ5ID0gYmluYXJ5O1xuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsICh1cmksIGxvYykge1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIGxvYyA9IGxvYyB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsb2NhdGlvbik7XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9IGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICB2YXIgaXB2NiA9IG9iai5ob3N0LmluZGV4T2YoJzonKSAhPT0gLTE7XG4gIHZhciBob3N0ID0gaXB2NiA/ICdbJyArIG9iai5ob3N0ICsgJ10nIDogb2JqLmhvc3Q7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gJ1tvYmplY3QgQmxvYkNvbnN0cnVjdG9yXScpO1xudmFyIHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKEZpbGUpID09PSAnW29iamVjdCBGaWxlQ29uc3RydWN0b3JdJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBuZXdEYXRhO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEsIGJ1ZmZlcnMpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKCh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0FDSycsXG4gICdFUlJPUicsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQklOQVJZX0FDSydcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbnZhciBFUlJPUl9QQUNLRVQgPSBleHBvcnRzLkVSUk9SICsgJ1wiZW5jb2RlIGVycm9yXCInO1xuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHZhciBzdHIgPSAnJyArIG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9PSBvYmoubnNwKSB7XG4gICAgc3RyICs9IG9iai5uc3AgKyAnLCc7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIHZhciBwYXlsb2FkID0gdHJ5U3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgICBpZiAocGF5bG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgIHN0ciArPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRVJST1JfUEFDS0VUO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZW5jb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIC8vIGxvb2sgdXAgdHlwZVxuICB2YXIgcCA9IHtcbiAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSlcbiAgfTtcblxuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHtcbiAgICByZXR1cm4gZXJyb3IoJ3Vua25vd24gcGFja2V0IHR5cGUgJyArIHAudHlwZSk7XG4gIH1cblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9PSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIHZhciBpc1BheWxvYWRWYWxpZCA9IHBheWxvYWQgIT09IGZhbHNlICYmIChwLnR5cGUgPT09IGV4cG9ydHMuRVJST1IgfHwgaXNBcnJheShwYXlsb2FkKSk7XG4gICAgaWYgKGlzUGF5bG9hZFZhbGlkKSB7XG4gICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXJyb3IoJ2ludmFsaWQgcGF5bG9hZCcpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRyeVBhcnNlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yOiAnICsgbXNnXG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbnZhciB3aXRoTmF0aXZlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nO1xudmFyIHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIGlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSA6IChvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKHdpdGhOYXRpdmVCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKTtcbn1cbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG4gICwgbGVuZ3RoID0gNjRcbiAgLCBtYXAgPSB7fVxuICAsIHNlZWQgPSAwXG4gICwgaSA9IDBcbiAgLCBwcmV2O1xuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gIHZhciBlbmNvZGVkID0gJyc7XG5cbiAgZG8ge1xuICAgIGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gIH0gd2hpbGUgKG51bSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW50ZWdlciB2YWx1ZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBpbnRlZ2VyIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gIHZhciBkZWNvZGVkID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gIH1cblxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24geWVhc3QoKSB7XG4gIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG4gIGlmIChub3cgIT09IHByZXYpIHJldHVybiBzZWVkID0gMCwgcHJldiA9IG5vdztcbiAgcmV0dXJuIG5vdyArJy4nKyBlbmNvZGUoc2VlZCsrKTtcbn1cblxuLy9cbi8vIE1hcCBlYWNoIGNoYXJhY3RlciB0byBpdHMgaW5kZXguXG4vL1xuZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG4vL1xueWVhc3QuZW5jb2RlID0gZW5jb2RlO1xueWVhc3QuZGVjb2RlID0gZGVjb2RlO1xubW9kdWxlLmV4cG9ydHMgPSB5ZWFzdDtcbiIsImltcG9ydCByYW5kb21Db2xvciBmcm9tICdyYW5kb21jb2xvcidcbmltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJ1xuaW1wb3J0IHBhcGVyLCB7IFBvaW50LCBQb2ludFRleHQsIFBhdGgsIFRvb2wsIHByb2plY3QgfSBmcm9tICdwYXBlcidcbmltcG9ydCBpbyBmcm9tICdzb2NrZXQuaW8tY2xpZW50J1xuXG5jb25zdCBzZXJ2ZXIgPSAnaHR0cHM6Ly9zcGVha2luZ2dnLXNlcnZlci5oZXJva3VhcHAuY29tLydcbmxldCBzb2NrZXQgPSBpby5jb25uZWN0KHNlcnZlcilcblxuY29uc3QgZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICBpZiAoc29ja2V0LmNvbm5lY3RlZCkge1xuICAgIHNvY2tldC5lbWl0KGV2ZW50LCAuLi5hcmdzKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdzb2NrZXQgZGlzY29ubmVjdGVkLi4uIFdhaXRpbmcgZm9yIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuJylcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygndGhpcy5zb2NrZXQgcmVjb25uZWN0ZWQuIEVtaXR0aW5nLi4uJylcbiAgICAgIHNvY2tldC5zb2NrZXQuY29ubmVjdCgpXG4gICAgICBzb2NrZXQuZW1pdChldmVudCwgLi4uYXJncylcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IHNlbmRNZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gIGVtaXQoJ21lc3NhZ2UgbmV3JywgbWVzc2FnZSlcbn1cblxuY29uc3QgbGFzdCA9IGFycmF5ID0+IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdXG5cbmNvbnN0IGNvbG9yc0FycmF5ID0gbmIgPT4ge1xuICBjb25zdCBhcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmI7IGkrKykge1xuICAgIGFycmF5LnB1c2gocmFuZG9tQ29sb3IoKSlcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuY29uc3QgcmFuZG9tID0gKG1pbiwgbWF4LCByb3VuZCA9IHRydWUpID0+IHtcbiAgLy8gbWluIGFuZCBtYXggaW5jbHVkZWRcbiAgY29uc3QgcmVzdWx0ID0gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pblxuICByZXR1cm4gcm91bmQgPyBNYXRoLmZsb29yKHJlc3VsdCkgOiByZXN1bHRcbn1cblxuY2xhc3MgUGFwZXJBcHAge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHdvcmQpIHtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lclxuICAgIHRoaXMud29yZCA9IHdvcmRcblxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICBpbml0KCkge1xuICAgIHBhcGVyLnNldHVwKHRoaXMuY29udGFpbmVyKVxuXG4gICAgdGhpcy52dyA9IHdpbmRvdy5pbm5lcldpZHRoIC8gMTAwXG4gICAgdGhpcy50b29sID0gbmV3IFRvb2woKVxuICAgIHRoaXMucGF0aCA9IG5ldyBQYXRoKClcbiAgICB0aGlzLnBvaW50cyA9IHRoaXMud29yZC5sZW5ndGhcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMud29yZC5sZW5ndGhcbiAgICB0aGlzLnN0YXJ0ID0gbmV3IHBhcGVyLlBvaW50KFxuICAgICAgcGFwZXIudmlldy5jZW50ZXIuX3ggLyAyLFxuICAgICAgcGFwZXIudmlldy5jZW50ZXIuX3kgLyAyLFxuICAgIClcblxuICAgIHRoaXMudG9vbC5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgIHRoaXMudG9vbC5hY3RpdmF0ZSgpXG4gIH1cblxuICB1cGRhdGUod29yZCkge1xuICAgIHRoaXMud29yZCA9IHdvcmRcbiAgICB0aGlzLnBvaW50cyA9IHRoaXMud29yZC5sZW5ndGhcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMud29yZC5sZW5ndGhcbiAgICB0aGlzLnBhdGggPSBuZXcgUGF0aCgpXG4gIH1cblxuICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIHByb2plY3QuY2xlYXIoKVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50czsgaSsrKSB7XG4gICAgICB0aGlzLnBhdGguYWRkKFxuICAgICAgICBuZXcgcGFwZXIuUG9pbnQodGhpcy5zdGFydC54ICsgdGhpcy5sZW5ndGggKiBpLCB0aGlzLnN0YXJ0LnkpLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMucGF0aC5maXJzdFNlZ21lbnQucG9pbnQgPSBldmVudCA/IGV2ZW50LnBvaW50IDogdGhpcy5zdGFydFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMgLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHNlZ21lbnQgPSB0aGlzLnBhdGguc2VnbWVudHNbaV1cbiAgICAgIGNvbnN0IG5leHRTZWdtZW50ID0gc2VnbWVudC5uZXh0XG4gICAgICBjb25zdCB2ZWN0b3IgPSBuZXcgcGFwZXIuUG9pbnQoXG4gICAgICAgIHNlZ21lbnQucG9pbnQueCAtIG5leHRTZWdtZW50LnBvaW50LngsXG4gICAgICAgIHNlZ21lbnQucG9pbnQueSAtIG5leHRTZWdtZW50LnBvaW50LnksXG4gICAgICApXG4gICAgICB2ZWN0b3IubGVuZ3RoID0gbGVuZ3RoXG4gICAgICBuZXh0U2VnbWVudC5wb2ludCA9IG5ldyBwYXBlci5Qb2ludChcbiAgICAgICAgc2VnbWVudC5wb2ludC54IC0gdmVjdG9yLngsXG4gICAgICAgIHNlZ21lbnQucG9pbnQueSAtIHZlY3Rvci55LFxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMucGF0aC5zdHJva2VDb2xvciA9ICcjZmZmJ1xuICAgIHRoaXMucGF0aC5zbW9vdGgoeyB0eXBlOiAnY29udGludW91cycgfSlcblxuICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8PSA5MDApIHtcbiAgICAgIHRoaXMuYWxpZ25lZFRleHQodGhpcy53b3JkLCB0aGlzLnBhdGgsIHtcbiAgICAgICAgZm9udFNpemU6IHRoaXMudncgKiA2LFxuICAgICAgICBmb250RmFtaWx5OiAnT3BlbiBTYW5zJyxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWxpZ25lZFRleHQodGhpcy53b3JkLCB0aGlzLnBhdGgsIHtcbiAgICAgICAgZm9udFNpemU6IHRoaXMudncgKiA4LFxuICAgICAgICBmb250RmFtaWx5OiAnT3BlbiBTYW5zJyxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcG9pbnRUZXh0KHN0ciwgc3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IFBvaW50VGV4dCgpXG4gICAgdGV4dC5jb250ZW50ID0gc3RyXG4gICAgdGV4dC5maWxsQ29sb3IgPSAnI2ZmZidcbiAgICB0ZXh0LmJsZW5kTW9kZSA9ICdkaWZmZXJlbmNlJ1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgaWYgKHN0eWxlLmZvbnQpIHRleHQuZm9udCA9IHN0eWxlLmZvbnRcbiAgICAgIGlmIChzdHlsZS5mb250RmFtaWx5KSB0ZXh0LmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5XG4gICAgICBpZiAoc3R5bGUuZm9udFNpemUpIHRleHQuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZVxuICAgICAgaWYgKHN0eWxlLmZvbnRXZWlnaHQpIHRleHQuZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHRcbiAgICB9XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGFsaWduZWRUZXh0KHN0ciwgcGF0aCwgc3R5bGUpIHtcbiAgICBpZiAoc3RyICYmIHN0ci5sZW5ndGggPiAwICYmIHBhdGgpIHtcbiAgICAgIC8vIGNyZWF0ZSBQb2ludFRleHQgb2JqZWN0IGZvciBlYWNoIGdseXBoXG4gICAgICB2YXIgZ2x5cGhUZXh0cyA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbHlwaFRleHRzW2ldID0gdGhpcy5wb2ludFRleHQoc3RyLnN1YnN0cmluZyhpLCBpICsgMSksIHN0eWxlKVxuICAgICAgICBnbHlwaFRleHRzW2ldLmp1c3RpZmljYXRpb24gPSAnY2VudGVyJ1xuICAgICAgfVxuICAgICAgLy8gZm9yIGVhY2ggZ2x5cGggZmluZCBjZW50ZXIgeE9mZnNldFxuICAgICAgbGV0IHhPZmZzZXRzID0gWzBdXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYWlyVGV4dCA9IHRoaXMucG9pbnRUZXh0KHN0ci5zdWJzdHJpbmcoaSAtIDEsIGkgKyAxKSwgc3R5bGUpXG4gICAgICAgIC8vIHBhaXJUZXh0LnJlbW92ZSgpXG4gICAgICAgIHhPZmZzZXRzW2ldID1cbiAgICAgICAgICB4T2Zmc2V0c1tpIC0gMV0gK1xuICAgICAgICAgIHBhaXJUZXh0LmJvdW5kcy53aWR0aCArXG4gICAgICAgICAgZ2x5cGhUZXh0c1tpIC0gMV0uYm91bmRzLndpZHRoIC8gMiAtXG4gICAgICAgICAgZ2x5cGhUZXh0c1tpXS5ib3VuZHMud2lkdGggLyAyXG4gICAgICB9XG4gICAgICAvLyBzZXQgcG9pbnQgZm9yIGVhY2ggZ2x5cGggYW5kIHJvdGF0ZSBnbHlwaCBhcm91bmQgdGhlIHBvaW50XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2VudGVyT2ZmcyA9IHhPZmZzZXRzW2ldXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IGNlbnRlck9mZnMpIHtcbiAgICAgICAgICBpZiAocGF0aC5jbG9zZWQpIHtcbiAgICAgICAgICAgIGNlbnRlck9mZnMgPSBjZW50ZXJPZmZzICUgcGF0aC5sZW5ndGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VudGVyT2ZmcyA9IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VudGVyT2ZmcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZ2x5cGhUZXh0c1tpXS5yZW1vdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhdGhQb2ludCA9IHBhdGguZ2V0UG9pbnRBdChjZW50ZXJPZmZzKVxuICAgICAgICAgIGdseXBoVGV4dHNbaV0ucG9pbnQgPSBwYXRoUG9pbnRcbiAgICAgICAgICBjb25zdCB0YW4gPSBwYXRoLmdldFRhbmdlbnRBdChjZW50ZXJPZmZzKVxuICAgICAgICAgIGdseXBoVGV4dHNbaV0ucm90YXRlKHRhbi5hbmdsZSwgcGF0aFBvaW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlY29nbml0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbGFuZ1NlbGVjdG9yLFxuICAgIGhpc3RvcnlDb250YWluZXIsXG4gICAgc3BlZWNoQ29udGFpbmVyLFxuICAgIHBhcGVyQ29udGFpbmVyLFxuICAgIGJiQ29udGFpbmVyLFxuICApIHtcbiAgICB3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24gPVxuICAgICAgd2luZG93LlNwZWVjaFJlY29nbml0aW9uIHx8XG4gICAgICB3aW5kb3cud2Via2l0U3BlZWNoUmVjb2duaXRpb24gfHxcbiAgICAgIHdpbmRvdy5tb3pTcGVlY2hSZWNvZ25pdGlvbiB8fFxuICAgICAgd2luZG93Lm1zU3BlZWNoUmVjb2duaXRpb24gfHxcbiAgICAgIHdpbmRvdy5vU3BlZWNoUmVjb2duaXRpb25cblxuICAgIGlmICh3aW5kb3cuU3BlZWNoUmVjb2duaXRpb24pIHtcbiAgICAgIHRoaXMuc3BlZWNoQ29udGFpbmVyID0gc3BlZWNoQ29udGFpbmVyXG4gICAgICB0aGlzLnBhcGVyQ29udGFpbmVyID0gcGFwZXJDb250YWluZXJcbiAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lciA9IGhpc3RvcnlDb250YWluZXJcbiAgICAgIHRoaXMuYmJDb250YWluZXIgPSBiYkNvbnRhaW5lclxuICAgICAgdGhpcy5sYW5nU2VsZWN0b3IgPSBsYW5nU2VsZWN0b3JcbiAgICAgIHRoaXMubGFuZyA9IGxhbmdTZWxlY3Rvci52YWx1ZVxuICAgICAgdGhpcy5pbml0KClcbiAgICB9XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMucmVjb2duaXRpb24gPSBuZXcgU3BlZWNoUmVjb2duaXRpb24oKVxuICAgIC8vIHRoaXMucmVjb2duaXRpb24uY29udGludW91cyA9IGZhbHNlO1xuICAgIHRoaXMucmVjb2duaXRpb24uaW50ZXJpbVJlc3VsdCA9IHRydWVcbiAgICB0aGlzLnJlY29nbml0aW9uLmxhbmcgPSB0aGlzLmxhbmdcblxuICAgIHRoaXMubG9nID0gW11cblxuICAgIHRoaXMucGFwZXIgPSBuZXcgUGFwZXJBcHAoXG4gICAgICB0aGlzLnBhcGVyQ29udGFpbmVyLFxuICAgICAgdGhpcy5zcGVlY2hDb250YWluZXIuaW5uZXJIVE1MLFxuICAgIClcblxuICAgIHRoaXMudGV4dCgpXG5cbiAgICBjb25zdCBiYiA9IFtcbiAgICAgICcuL2Fzc2V0cy9iYjEuc3ZnJyxcbiAgICAgICcuL2Fzc2V0cy9iYjIuc3ZnJyxcbiAgICAgICcuL2Fzc2V0cy9iYjMuc3ZnJyxcbiAgICAgICcuL2Fzc2V0cy9iYjQuc3ZnJyxcbiAgICBdXG4gICAgdGhpcy5iYkNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke1xuICAgICAgYmJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYmIubGVuZ3RoKV1cbiAgICB9JylgXG5cbiAgICB0aGlzLmV2ZW50cygpXG4gIH1cblxuICB0ZXh0KHdvcmQpIHtcbiAgICBhbmltZVxuICAgICAgLnRpbWVsaW5lKHtcbiAgICAgICAgZWFzaW5nOiAnZWFzZUluT3V0U2luZScsXG4gICAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICB9KVxuICAgICAgLmFkZCh7XG4gICAgICAgIHRhcmdldHM6IHRoaXMuc3BlZWNoQ29udGFpbmVyLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgfSlcbiAgICAgIC5hZGQoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLnNwZWVjaENvbnRhaW5lcixcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgIH0pXG5cbiAgICB3b3JkID0gd29yZCA/IHdvcmQgOiB0aGlzLnNwZWVjaENvbnRhaW5lci5pbm5lckhUTUxcblxuICAgIGlmICh3b3JkLmxlbmd0aCA8PSAyNCkge1xuICAgICAgY29uc3QgdGV4dCA9IG5ldyBCbG90dGVyLlRleHQod29yZCwge1xuICAgICAgICBmYW1pbHk6ICdPcGVuIFNhbnMnLFxuICAgICAgICBzaXplOlxuICAgICAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCAvIDEwMCkgKlxuICAgICAgICAgIHdvcmQubGVuZ3RoICpcbiAgICAgICAgICAod29yZC5sZW5ndGggPiAxMCA/IDAuMiA6IDAuOCksXG4gICAgICAgIGZpbGw6ICcjZmZmJyxcbiAgICAgICAgcGFkZGluZ0xlZnQ6IDQwLFxuICAgICAgICBwYWRkaW5nUmlnaHQ6IDQwLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IEJsb3R0ZXIuTGlxdWlkRGlzdG9ydE1hdGVyaWFsKClcbiAgICAgIG1hdGVyaWFsLnVuaWZvcm1zLnVWb2xhdGlsaXR5LnZhbHVlID0gYW5pbWUucmFuZG9tKDAuMDQsIDAuMilcbiAgICAgIG1hdGVyaWFsLnVuaWZvcm1zLnVTZWVkLnZhbHVlID0gYW5pbWUucmFuZG9tKDAuMiwgMC40KVxuICAgICAgY29uc3QgYmxvdHRlciA9IG5ldyBCbG90dGVyKG1hdGVyaWFsLCB7IHRleHRzOiB0ZXh0IH0pXG4gICAgICBjb25zdCBzY29wZSA9IGJsb3R0ZXIuZm9yVGV4dCh0ZXh0KVxuXG4gICAgICBibG90dGVyLm5lZWRzVXBkYXRlID0gdHJ1ZVxuXG4gICAgICB0aGlzLnNwZWVjaENvbnRhaW5lci5pbm5lckhUTUwgPSAnJ1xuICAgICAgc2NvcGUuYXBwZW5kVG8odGhpcy5zcGVlY2hDb250YWluZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3BlZWNoQ29udGFpbmVyLmlubmVySFRNTCA9IHdvcmRcbiAgICB9XG4gIH1cblxuICBldmVudHMoKSB7XG4gICAgdGhpcy5vbkxhbmdDaGFuZ2UoKVxuICAgIHRoaXMub25SZXN1bHQoKVxuICAgIHRoaXMub25FbmQoKVxuICAgIHRoaXMuc3RhcnQoKVxuICAgIHRoaXMub25LZXkoKVxuXG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZSA9PiBjb25zb2xlLmxvZyhlKSlcblxuICAgIHNvY2tldC5vbignbWVzc2FnZXMgdXBkYXRlJywgKHsgbWVzc2FnZXMgfSkgPT4ge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZXMpXG4gICAgfSlcblxuICAgIHNvY2tldC5vbignbWVzc2FnZSBuZXcnLCAoeyBtZXNzYWdlLCBtZXNzYWdlcyB9KSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlcywgbWVzc2FnZSlcblxuICAgICAgaWYgKHRoaXMubG9nLmxlbmd0aCA8IG1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG0gPT4gdGhpcy51cGRhdGVMb2cobSwgZmFsc2UpKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbktleSgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGUgPT4ge1xuICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgdGhpcy5jbGVhckxvZygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uTGFuZ0NoYW5nZSgpIHtcbiAgICB0aGlzLmxhbmdTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgIHRoaXMubGFuZyA9IGUudGFyZ2V0LnZhbHVlXG4gICAgICB0aGlzLnJlY29nbml0aW9uLmxhbmcgPSB0aGlzLmxhbmdcbiAgICB9KVxuICB9XG5cbiAgb25SZXN1bHQoKSB7XG4gICAgdGhpcy5yZWNvZ25pdGlvbi5hZGRFdmVudExpc3RlbmVyKCdyZXN1bHQnLCBlID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTG9nKGUpXG4gICAgICBjb25zdCBtZXNzYWdlID0gbGFzdCh0aGlzLmxvZykudHJhbnNjcmlwdFxuXG4gICAgICBzZW5kTWVzc2FnZShtZXNzYWdlKVxuICAgICAgdGhpcy51cGRhdGVTcGVlY2gobWVzc2FnZSlcbiAgICB9KVxuICB9XG5cbiAgb25FbmQoKSB7XG4gICAgdGhpcy5yZWNvZ25pdGlvbi5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLnN0YXJ0LmJpbmQodGhpcykpXG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB0aGlzLnJlY29nbml0aW9uLnN0YXJ0KClcbiAgfVxuXG4gIGNsZWFyTG9nKCkge1xuICAgIHRoaXMubG9nID0gW2xhc3QodGhpcy5sb2cpXVxuICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJ1xuICAgIHRoaXMuYXBwZW5kVG9IaXN0b3J5KGxhc3QodGhpcy5sb2cpKVxuICB9XG5cbiAgdXBkYXRlTG9nKGUsIGlzQ29tcGxldGVkRGF0YSA9IHRydWUpIHtcbiAgICBsZXQgZGF0YVxuICAgIGlmIChpc0NvbXBsZXRlZERhdGEpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBBcnJheS5mcm9tKGUucmVzdWx0cykubWFwKHIgPT4gclswXSlcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIGxhbmc6IHRoaXMubGFuZyxcbiAgICAgICAgdGltZVN0YW1wOiBlLnRpbWVTdGFtcCxcbiAgICAgICAgY29uZmlkZW5jZTogcmVzdWx0cy5tYXAociA9PiByLmNvbmZpZGVuY2UpLFxuICAgICAgICB0cmFuc2NyaXB0OiByZXN1bHRzLm1hcChyID0+IHIudHJhbnNjcmlwdCkuam9pbigpLFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICB0aW1lU3RhbXA6IGUuY3JlYXRlZCxcbiAgICAgICAgdHJhbnNjcmlwdDogZS50ZXh0LFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubG9nLnB1c2goZGF0YSlcbiAgICB0aGlzLmFwcGVuZFRvSGlzdG9yeShkYXRhKVxuXG4gICAgY29uc29sZS5jbGVhcigpXG4gICAgY29uc29sZS50YWJsZSh0aGlzLmxvZylcbiAgfVxuXG4gIHVwZGF0ZVNwZWVjaChzZW50ZW5jZXMpIHtcbiAgICB0aGlzLnRleHQoc2VudGVuY2VzKVxuICAgIHRoaXMucGFwZXIudXBkYXRlKHNlbnRlbmNlcylcbiAgfVxuXG4gIGFwcGVuZFRvSGlzdG9yeShkYXRhKSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuXG4gICAgcC5pbm5lckhUTUwgPSBkYXRhLnRyYW5zY3JpcHRcbiAgICBwLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBkYXRhLnRyYW5zY3JpcHQpXG5cbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBwLFxuICAgICAgdG9wOiBgJHthbmltZS5yYW5kb20oMTAsIDkwKX0lYCxcbiAgICAgIGxlZnQ6IGAke2FuaW1lLnJhbmRvbSgxMCwgOTApfSVgLFxuICAgICAgdHJhbnNsYXRlWDogJy01MCUnLFxuICAgICAgdHJhbnNsYXRlWTogJy01MCUnLFxuICAgICAgZm9udFNpemU6IGAke2FuaW1lLnJhbmRvbSgwLjgsIDIuMil9cmVtYCxcbiAgICAgIG9wYWNpdHk6IGFuaW1lLnJhbmRvbSgwLjEsIDAuNCksXG4gICAgICByb3RhdGU6IGFuaW1lLnJhbmRvbSgwLCAzNjApLFxuICAgIH0pXG5cbiAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kKHApXG4gIH1cbn1cblxuY2xhc3MgV2F2ZWZvcm0ge1xuICBjb25zdHJ1Y3Rvcihzb3VuZCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5zb3VuZCA9IHNvdW5kXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXJcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHNwZWN0cnVtQ29sb3JzOiByYW5kb21Db2xvcih7IGNvdW50OiA1MTIsIGh1ZTogJ2JsdWUnIH0pLFxuICAgICAgYmdDb2xvcnM6IHtcbiAgICAgICAgcmVkOiByYW5kb21Db2xvcih7IGNvdW50OiAzLCBodWU6ICdyZWQnIH0pLFxuICAgICAgICBvcmFuZ2U6IHJhbmRvbUNvbG9yKHsgY291bnQ6IDMsIGh1ZTogJ29yYW5nZScgfSksXG4gICAgICAgIHllbGxvdzogcmFuZG9tQ29sb3IoeyBjb3VudDogMywgaHVlOiAneWVsbG93JyB9KSxcbiAgICAgICAgZ3JlZW46IHJhbmRvbUNvbG9yKHsgY291bnQ6IDMsIGh1ZTogJ2dyZWVuJyB9KSxcbiAgICAgICAgYmx1ZTogcmFuZG9tQ29sb3IoeyBjb3VudDogMywgaHVlOiAnYmx1ZScgfSksXG4gICAgICAgIHB1cnBsZTogcmFuZG9tQ29sb3IoeyBjb3VudDogMywgaHVlOiAncHVycGxlJyB9KSxcbiAgICAgICAgcGluazogcmFuZG9tQ29sb3IoeyBjb3VudDogMywgaHVlOiAncGluaycgfSksXG4gICAgICB9LFxuICAgICAgYm9yZGVySGVpZ2h0OiAwLFxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmJnQ29sb3JzKS5mb3JFYWNoKGJnID0+IHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdhcHBfX3dhdmVmb3JtX19iZycsIGBiZy0tJHtiZ31gKVxuICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmQgPSBgbGluZWFyLWdyYWRpZW50KC02MGRlZywgJHt0aGlzLmNvbmZpZy5iZ0NvbG9yc1tcbiAgICAgICAgYmdcbiAgICAgIF0uam9pbignICwnKX0pYFxuICAgICAgZGl2LnN0eWxlLm9wYWNpdHkgPSBiZyA9PT0gJ2JsdWUnID8gMSA6IDBcblxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KVxuICAgIH0pXG5cbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSA1MTJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSAzMDBcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSlcbiAgICB0aGlzLnJlc2l6ZSgpXG4gIH1cblxuICB1cGRhdGVDb25maWcoaHVlKSB7XG4gICAgaWYgKGh1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBodWUgPSAnYmx1ZSdcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZy5zcGVjdHJ1bUNvbG9ycyA9IHJhbmRvbUNvbG9yKHsgY291bnQ6IDUxMiwgaHVlIH0pXG5cbiAgICBjb25zdCBiZyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYC5iZy0tJHtodWV9YClcbiAgICBjb25zdCByZXN0ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChgLmFwcF9fd2F2ZWZvcm1fX2JnYClcblxuICAgIGFuaW1lXG4gICAgICAudGltZWxpbmUoe1xuICAgICAgICBlYXNpbmc6ICdlYXNlSW5PdXRTaW5lJyxcbiAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIH0pXG4gICAgICAuYWRkKHtcbiAgICAgICAgdGFyZ2V0czogcmVzdCxcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgIH0pXG4gICAgICAuYWRkKFxuICAgICAgICB7XG4gICAgICAgICAgdGFyZ2V0czogYmcsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgfSxcbiAgICAgICAgMCxcbiAgICAgIClcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IHNwZWN0cnVtID0gdGhpcy5zb3VuZC5nZXRTcGVjdHJ1bSgpXG4gICAgY29uc3Qgd2F2ZWZvcm0gPSB0aGlzLnNvdW5kLmdldFdhdmVmb3JtKClcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgc3BlY3RydW0sXG4gICAgICB3YXZlZm9ybSxcbiAgICAgIHNwZWN0cnVtTGVuZ3RoOiBzcGVjdHJ1bS5sZW5ndGgsXG4gICAgICB3YXZlZm9ybUxlbmd0aDogd2F2ZWZvcm0ubGVuZ3RoLFxuICAgIH1cblxuICAgIHRoaXMuYmFja2dyb3VuZCgpXG5cbiAgICB0aGlzLnNwZWN0cnVtKClcblxuICAgIHRoaXMud2F2ZWZvcm0oKVxuXG4gICAgLy8gZHJhdyBmcmVxdWVuY3lcbiAgICAvLyB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAvLyB0aGlzLmN0eC5mb250ID0gJzEwcHggQXJpYWwnO1xuICAgIC8vIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIC8vIHRoaXMuY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAvLyBmb3IgKGxldCBpID0gMCwgbGVuID0gc3BlY3RydW1MZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIC8vICAgaWYgKGkgJSAxMCA9PSAwKSB7XG4gICAgLy8gICAgIHRoaXMuY3R4LnJlY3QoXG4gICAgLy8gICAgICAgaSAqIHNwZWN0cnVtV2lkdGgsXG4gICAgLy8gICAgICAgc3BlY3RydW1IZWlnaHQsXG4gICAgLy8gICAgICAgc3BlY3RydW1XaWR0aCAvIDIsXG4gICAgLy8gICAgICAgYm9yZGVySGVpZ2h0XG4gICAgLy8gICAgICk7XG4gICAgLy8gICAgIHRoaXMuY3R4LmZpbGxUZXh0KFxuICAgIC8vICAgICAgIGksXG4gICAgLy8gICAgICAgaSAqIHNwZWN0cnVtV2lkdGggKyA0LFxuICAgIC8vICAgICAgIHNwZWN0cnVtSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICogMC41XG4gICAgLy8gICAgICk7XG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIC8vIHRoaXMuY3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcbiAgICAvLyB0aGlzLmN0eC5maWxsKCk7XG5cbiAgICAvLyBkcmF3IHRpbWVcbiAgICAvLyB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAvLyB0aGlzLmN0eC50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIC8vIHRoaXMuY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgIC8vIHRoaXMuY3R4LmZvbnQgPSAnMTVweCBBcmlhbCc7XG4gICAgLy8gdGhpcy5jdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgIC8vIHRoaXMuY3R4LmZpbGxUZXh0KFxuICAgIC8vICAgTWF0aC5yb3VuZCh0aGlzLnNvdW5kLnRpbWUgKiAxMCkgLyAxMCArXG4gICAgLy8gICAgICcgLyAnICtcbiAgICAvLyAgICAgTWF0aC5yb3VuZCh0aGlzLnNvdW5kLmR1cmF0aW9uICogMTApIC8gMTAsXG4gICAgLy8gICB0aGlzLmNhbnZhcy53aWR0aCAtIDUsXG4gICAgLy8gICA1XG4gICAgLy8gKTtcbiAgfVxuXG4gIGJhY2tncm91bmQoKSB7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICB0aGlzLmN0eC5yZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gIH1cblxuICBzcGVjdHJ1bSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjdHJ1bSxcbiAgICAgIHNwZWN0cnVtTGVuZ3RoLFxuICAgICAgc3BlY3RydW1Db2xvcnMsXG4gICAgICBib3JkZXJIZWlnaHQsXG4gICAgfSA9IHRoaXMuY29uZmlnXG4gICAgY29uc3Qgc3BlY3RydW1XaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gc3BlY3RydW1MZW5ndGhcbiAgICBjb25zdCBzcGVjdHJ1bUhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIGJvcmRlckhlaWdodFxuICAgIGxldCBzcGVjdHJ1bVZhbHVlID0gbnVsbFxuXG4gICAgc3BlY3RydW0uZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKClcbiAgICAgIHNwZWN0cnVtVmFsdWUgPSBzIC8gMjU2XG4gICAgICB0aGlzLmN0eC5yZWN0KFxuICAgICAgICBpICogc3BlY3RydW1XaWR0aCxcbiAgICAgICAgc3BlY3RydW1IZWlnaHQgLSBzcGVjdHJ1bUhlaWdodCAqIHNwZWN0cnVtVmFsdWUsXG4gICAgICAgIHNwZWN0cnVtV2lkdGggLyAyLFxuICAgICAgICBzcGVjdHJ1bUhlaWdodCAqIHNwZWN0cnVtVmFsdWUsXG4gICAgICApXG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzcGVjdHJ1bUNvbG9yc1tpXVxuICAgICAgdGhpcy5jdHguZmlsbCgpXG4gICAgfSlcbiAgfVxuXG4gIHdhdmVmb3JtKCkge1xuICAgIGNvbnN0IHsgd2F2ZWZvcm0sIHdhdmVmb3JtTGVuZ3RoLCBib3JkZXJIZWlnaHQgfSA9IHRoaXMuY29uZmlnXG4gICAgY29uc3Qgd2F2ZWZvcm1XaWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gd2F2ZWZvcm1MZW5ndGhcbiAgICBjb25zdCB3YXZlZm9ybUhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAtIGJvcmRlckhlaWdodFxuICAgIGxldCB3YXZlZm9ybVZhbHVlID0gbnVsbFxuXG4gICAgdGhpcy5jdHguYmVnaW5QYXRoKClcblxuICAgIHdhdmVmb3JtLmZvckVhY2goKHcsIGkpID0+IHtcbiAgICAgIHdhdmVmb3JtVmFsdWUgPSB3IC8gMjU2XG4gICAgICBpZiAoaSA9PSAwKVxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oaSAqIHdhdmVmb3JtV2lkdGgsIHdhdmVmb3JtSGVpZ2h0ICogd2F2ZWZvcm1WYWx1ZSlcbiAgICAgIGVsc2UgdGhpcy5jdHgubGluZVRvKGkgKiB3YXZlZm9ybVdpZHRoLCB3YXZlZm9ybUhlaWdodCAqIHdhdmVmb3JtVmFsdWUpXG4gICAgfSlcblxuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gJyMwMDAwZmYnXG4gICAgdGhpcy5jdHguc3Ryb2tlKClcbiAgfVxufVxuXG5jbGFzcyBBdWRpb1Byb2Nlc3Npbmcge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHZvbHVtZUNvbnRhaW5lciwgbm90ZUNvbnRhaW5lciwgd2F2ZWZvcm1Db250YWluZXIpIHtcbiAgICB0aGlzLnZvbHVtZUNvbnRhaW5lciA9IHZvbHVtZUNvbnRhaW5lclxuICAgIHRoaXMubm90ZUNvbnRhaW5lciA9IG5vdGVDb250YWluZXJcbiAgICB0aGlzLndhdmVmb3JtID0gbmV3IFdhdmVmb3JtKHRoaXMsIHdhdmVmb3JtQ29udGFpbmVyKVxuXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICB0aGlzLmFuYWx5c2VyID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKVxuICAgIHRoaXMubWljSW5wdXQgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pXG4gICAgdGhpcy5zY3JpcHRQcm9jZXNzb3IgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoMjA0OCwgMSwgMSlcblxuICAgIHRoaXMuYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gMC44XG4gICAgdGhpcy5hbmFseXNlci5mZnRTaXplID0gNTEyXG5cbiAgICB0aGlzLm1pY0lucHV0LmNvbm5lY3QodGhpcy5hbmFseXNlcilcbiAgICB0aGlzLmFuYWx5c2VyLmNvbm5lY3QodGhpcy5zY3JpcHRQcm9jZXNzb3IpXG4gICAgdGhpcy5zY3JpcHRQcm9jZXNzb3IuY29ubmVjdCh0aGlzLmF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbilcblxuICAgIHRoaXMuc2NyaXB0UHJvY2Vzc29yLm9uYXVkaW9wcm9jZXNzID0gdGhpcy5hdWRpb1Byb2Nlc3MuYmluZCh0aGlzKVxuICB9XG5cbiAgYXVkaW9Qcm9jZXNzKCkge1xuICAgIGNvbnN0IHN0cmVhbURhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KVxuXG4gICAgdGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShzdHJlYW1EYXRhKVxuICAgIGNvbnN0IGF2ZXJhZ2UgPSB0aGlzLmdldEF2ZXJhZ2VWb2x1bWUoc3RyZWFtRGF0YSlcblxuICAgIHRoaXMudm9sdW1lQ29udGFpbmVyLmlubmVySFRNTCA9IGF2ZXJhZ2VcbiAgICB0aGlzLndhdmVmb3JtLmRyYXcoKVxuXG4gICAgY29uc3Qgbm90ZSA9IHRoaXMuZ2V0Tm90ZUZyb21QaXRjaCh0aGlzLmdldE5vdGVOYkZyb21QaXRjaChhdmVyYWdlKSlcbiAgICB0aGlzLm5vdGVDb250YWluZXIuaW5uZXJIVE1MID0gbm90ZSA/IG5vdGUgOiAnJ1xuXG4gICAgY29uc3QgaHVlID0gdGhpcy5nZXRIdWVGcm9tTm90ZShub3RlKVxuICAgIHRoaXMud2F2ZWZvcm0udXBkYXRlQ29uZmlnKGh1ZSlcbiAgfVxuXG4gIGdldFNwZWN0cnVtKCkge1xuICAgIGNvbnN0IHN0cmVhbURhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KVxuICAgIHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoc3RyZWFtRGF0YSlcblxuICAgIHJldHVybiBzdHJlYW1EYXRhXG4gIH1cblxuICBnZXRXYXZlZm9ybSgpIHtcbiAgICBjb25zdCBzdHJlYW1EYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudClcbiAgICB0aGlzLmFuYWx5c2VyLmdldEJ5dGVUaW1lRG9tYWluRGF0YShzdHJlYW1EYXRhKVxuXG4gICAgcmV0dXJuIHN0cmVhbURhdGFcbiAgfVxuXG4gIGdldEZyZXF1ZW5jeShmcmVxLCBlbmRGcmVxID0gbnVsbCkge1xuICAgIGxldCBzdW0gPSAwXG4gICAgbGV0IHNwZWN0cnVtID0gdGhpcy5nZXRTcGVjdHJ1bSgpXG4gICAgaWYgKGVuZEZyZXEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChsZXQgaSA9IGZyZXE7IGkgPD0gZW5kRnJlcTsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBzcGVjdHJ1bVtpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bSAvIChlbmRGcmVxIC0gZnJlcSArIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzcGVjdHJ1bVtmcmVxXVxuICAgIH1cbiAgfVxuXG4gIGdldEF2ZXJhZ2VWb2x1bWUoZnJlcXVlbmNpZXMpIHtcbiAgICBsZXQgdmFsdWVzID0gMFxuICAgIGZyZXF1ZW5jaWVzLmZvckVhY2godiA9PiAodmFsdWVzICs9IHYpKVxuXG4gICAgY29uc3QgYXZlcmFnZSA9IHZhbHVlcyAvIGZyZXF1ZW5jaWVzLmxlbmd0aFxuXG4gICAgcmV0dXJuIGF2ZXJhZ2VcbiAgfVxuXG4gIGdldE5vdGVOYkZyb21QaXRjaChmcmVxdWVuY3kpIHtcbiAgICBjb25zdCBub3RlTnVtID0gMTIgKiAoTWF0aC5sb2coZnJlcXVlbmN5IC8gNDQwKSAvIE1hdGgubG9nKDIpKVxuICAgIHJldHVybiBNYXRoLnJvdW5kKG5vdGVOdW0pICsgNjlcbiAgfVxuXG4gIGdldE5vdGVGcm9tUGl0Y2gobm90ZU5iKSB7XG4gICAgY29uc3Qgbm90ZXMgPSBbXG4gICAgICAnQycsXG4gICAgICAnQyMnLFxuICAgICAgJ0QnLFxuICAgICAgJ0QjJyxcbiAgICAgICdFJyxcbiAgICAgICdGJyxcbiAgICAgICdGIycsXG4gICAgICAnRycsXG4gICAgICAnRyMnLFxuICAgICAgJ0EnLFxuICAgICAgJ0EjJyxcbiAgICAgICdCJyxcbiAgICBdXG4gICAgcmV0dXJuIG5vdGVzW25vdGVOYiAlIDEyXVxuICB9XG5cbiAgZ2V0SHVlRnJvbU5vdGUobm90ZSkge1xuICAgIGNvbnN0IGh1ZSA9IHtcbiAgICAgIEM6ICdyZWQnLFxuICAgICAgJ0MjJzogJ3JlZCcsXG4gICAgICBEOiAnb3JhbmdlJyxcbiAgICAgICdEIyc6ICdvcmFuZ2UnLFxuICAgICAgRTogJ3llbGxvdycsXG4gICAgICBGOiAnZ3JlZW4nLFxuICAgICAgJ0YjJzogJ2dyZWVuJyxcbiAgICAgIEc6ICdibHVlJyxcbiAgICAgICdHIyc6ICdibHVlJyxcbiAgICAgIEE6ICdwdXJwbGUnLFxuICAgICAgJ0EjJzogJ3B1cnBsZScsXG4gICAgICBCOiAncGluaycsXG4gICAgfVxuICAgIHJldHVybiBodWVbbm90ZV1cbiAgfVxuXG4gIGdldEZyZXF1ZW5jeUZyb21Ob3RlTnVtYmVyKG5vdGUpIHtcbiAgICByZXR1cm4gNDQwICogTWF0aC5wb3coMiwgKG5vdGUgLSA2OSkgLyAxMilcbiAgfVxuXG4gIGdldENlbnRzT2ZmRnJvbVBpdGNoKGZyZXF1ZW5jeSwgbm90ZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgKDEyMDAgKiBNYXRoLmxvZyhmcmVxdWVuY3kgLyB0aGlzLmZyZXF1ZW5jeUZyb21Ob3RlTnVtYmVyKG5vdGUpKSkgL1xuICAgICAgICBNYXRoLmxvZygyKSxcbiAgICApXG4gIH1cbn1cblxuY2xhc3MgQXBwIHtcbiAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgdGhpcy5yb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHApXG4gICAgdGhpcy5lbHMgPSB7XG4gICAgICBzcGVlY2hDb250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX3NwZWVjaGApLFxuICAgICAgYmJDb250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX2JiYCksXG4gICAgICBwYXBlckNvbnRhaW5lcjogdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoYCR7YXBwfV9fcGFwZXJgKSxcbiAgICAgIGhpc3RvcnlDb250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX2hpc3RvcnlgKSxcbiAgICAgIGxhbmdDb250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX2xhbmcgc2VsZWN0YCksXG4gICAgICB2b2x1bWVDb250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX3ZvbHVtZWApLFxuICAgICAgbm90ZUNvbnRhaW5lcjogdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoYCR7YXBwfV9fbm90ZWApLFxuICAgICAgd2F2ZWZvcm1Db250YWluZXI6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKGAke2FwcH1fX3dhdmVmb3JtYCksXG4gICAgfVxuXG4gICAgdGhpcy5pbml0KClcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBlID0+IHtcbiAgICAgIC8vIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhKCkuY2F0Y2goZSA9PiBjb25zb2xlLmxvZyhlKSlcbiAgICB9KVxuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gICAgICAuZ2V0VXNlck1lZGlhKHsgYXVkaW86IHRydWUgfSlcbiAgICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdFJlY29nbml0aW9uKClcblxuICAgICAgICB0aGlzLmluaXRBdWRpb1Byb2Nlc3Npbmcoc3RyZWFtKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IGNvbnNvbGUubG9nKGUpKVxuICB9XG5cbiAgaW5pdFJlY29nbml0aW9uKCkge1xuICAgIHRoaXMucmVjb2duaXRpb24gPSBuZXcgUmVjb2duaXRpb24oXG4gICAgICB0aGlzLmVscy5sYW5nQ29udGFpbmVyLFxuICAgICAgdGhpcy5lbHMuaGlzdG9yeUNvbnRhaW5lcixcbiAgICAgIHRoaXMuZWxzLnNwZWVjaENvbnRhaW5lcixcbiAgICAgIHRoaXMuZWxzLnBhcGVyQ29udGFpbmVyLFxuICAgICAgdGhpcy5lbHMuYmJDb250YWluZXIsXG4gICAgKVxuICB9XG5cbiAgaW5pdEF1ZGlvUHJvY2Vzc2luZyhzdHJlYW0pIHtcbiAgICB0aGlzLmF1ZGlvUHJvY2Vzc2luZyA9IG5ldyBBdWRpb1Byb2Nlc3NpbmcoXG4gICAgICBzdHJlYW0sXG4gICAgICB0aGlzLmVscy52b2x1bWVDb250YWluZXIsXG4gICAgICB0aGlzLmVscy5ub3RlQ29udGFpbmVyLFxuICAgICAgdGhpcy5lbHMud2F2ZWZvcm1Db250YWluZXIsXG4gICAgKVxuICB9XG59XG5cbndpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gIHdpbmRvdy5hcHAgPSBuZXcgQXBwKCcuYXBwJylcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBhbmltZSh7XG4gICAgICB0YXJnZXRzOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYXBwX19vdmVybGF5JyksXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0U2luZScsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgc2NhbGU6IDBcbiAgICB9KVxuICB9LCA0MDAwKTtcbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=